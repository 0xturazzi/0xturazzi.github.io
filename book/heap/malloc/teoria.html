<!DOCTYPE HTML>
<html lang="pt-br" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Teoria - Um Livrinho Sobre Exploit Dev</title>
        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../../mapa.html">Mapa</a></li><li class="spacer"></li><li class="chapter-item "><a href="../../stack/stack.html">Stack</a></li><li class="chapter-item "><a href="../../stack/phoenix/setup.html">Phoenix Stack</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stack/phoenix/StackZero.html">Stack Zero</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackOne.html">Stack One</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackTwo.html">Stack Two</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackThree.html">Stack Three</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackFour.html">Stack Four</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackFive.html">Stack Five</a></li><li class="chapter-item "><a href="../../stack/phoenix/StackSix.html">Stack Six</a></li></ol></li><li class="chapter-item "><a href="../../stack/mitigacoes.html">Mitigações</a></li><li class="chapter-item "><a href="../../stack/ret2libc.html">Ret2LibC</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>Protostar Stack Six</div></li><li class="chapter-item "><div>Avançado: Múltiplos ret2libc</div></li></ol></li><li class="chapter-item "><a href="../../stack/gotplt.html">GOT e PLT</a></li><li class="chapter-item "><a href="../../stack/rop/intro.html">ROP</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stack/rop/primitivos.html">Primitivos</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stack/rop/ROPE/dump.html">ROPE</a></li></ol></li><li class="chapter-item "><div>Pivot</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stack/rop/ROPE/pivot.html">ROPE: pivot</a></li></ol></li><li class="chapter-item "><a href="../../stack/rop/SROP/SROP.html">SROP</a></li><li class="chapter-item "><a href="../../stack/rop/ret2dlresolve.html">ret2dl-resolve</a></li></ol></li><li class="chapter-item "><a href="../../stack/ASLR/aslr.html">ASLR</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../stack/ASLR/corromperGOT.html">Corromper GOT</a></li><li class="chapter-item "><a href="../../stack/ASLR/ret2plt.html">ret2plt</a></li><li class="chapter-item "><a href="../../stack/ASLR/brute32.html">Bruteforce</a></li></ol></li><li class="chapter-item "><div>Canary</div></li><li class="chapter-item "><div>PIE</div></li><li class="chapter-item "><a href="../../stack/leakAll.html">Extra: Leakando tudo</a></li><li class="spacer"></li><li class="chapter-item "><a href="../../heap/heap.html">Heap (Malloc) </a></li><li class="chapter-item "><a href="../../heap/intro.html">Intro</a></li><li class="chapter-item "><div>Bugs Gerais</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><div>UAF</div><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../heap/geral/uaf/heap-two.html">Exploit Education: Heap Two</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../heap/relacionados/relacionados.html">Conceitos Relacionados</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../heap/relacionados/io_list_all.html">_IO_list_all</a></li></ol></li><li class="chapter-item expanded "><a href="../../heap/malloc/intro.html">Tecnicas</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../heap/malloc/teoria.html" class="active">Teoria</a></li><li class="chapter-item "><a href="../../heap/malloc/fastbinsDup.html">Fastbins Dup</a></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfForce.html">House of Force</a></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfSpirit.html">House of Spirit</a></li><li class="chapter-item "><a href="../../heap/malloc/unsafeUnlink.html">Unsafe Unlink</a></li><li class="chapter-item "><a href="../../heap/malloc/safeUnlink.html">Safe Unlink</a></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfEinherjar.html">House of Einherjar</a></li><li class="chapter-item "><a href="../../heap/malloc/GooglePoisonNull.html">Google Poison Null Byte</a></li><li class="chapter-item "><a href="../../heap/malloc/PartialUnlink.html">Unsorted bins: Partial Unlink</a></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfOrange.html">House of Orange</a></li><li class="chapter-item "><div>House of Prime</div></li><li class="chapter-item "><div>House of Chaos</div></li><li class="chapter-item "><div>House of Roman</div></li><li class="chapter-item "><a href="../../heap/malloc/comboFastUnsorted.html">Combo: Fast+Unsorted</a></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfLore.html">House of Lore</a></li><li class="chapter-item "><div>House of Rust</div></li><li class="chapter-item "><a href="../../heap/malloc/HouseOfRabbit.html">House of Rabbit</a></li><li class="chapter-item "><div>House of Underground</div></li><li class="chapter-item "><div>House of Mind</div></li><li class="chapter-item "><div>House of Storm</div></li><li class="chapter-item "><div>House of Corrosion</div></li><li class="chapter-item "><div>House of Red</div></li><li class="chapter-item "><a href="../../heap/malloc/tcachedup.html">TCache Dup</a></li><li class="chapter-item "><a href="../../heap/malloc/tcachepoison.html">Tcache Poison</a></li><li class="chapter-item "><div>House of Botcake</div></li></ol></li><li class="chapter-item "><div>Extra</div></li><li class="spacer"></li><li class="chapter-item "><a href="../../linux_internals/linux.html">Linux Internals</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Um Livrinho Sobre Exploit Dev</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/0xturazzi/Um-Livrinho-Sobre-Exploit-Dev/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="teoria"><a class="header" href="#teoria">Teoria</a></h1>
<ul>
<li><a href="#teoria">Teoria</a></li>
<li><a href="#chunk">Chunk</a></li>
<li><a href="#top">Top</a></li>
<li><a href="#arena">Arena</a></li>
<li><a href="#binlists">Binlists</a>
<ul>
<li><a href="#fastbins">Fastbins</a></li>
<li><a href="#unsorted-bin">Unsorted bin</a>
<ul>
<li><a href="#remaindering">Remaindering</a></li>
</ul>
</li>
<li><a href="#small-bins">Small Bins</a></li>
<li><a href="#large-bins">Large Bins</a></li>
</ul>
</li>
<li><a href="#outras-opera%C3%A7%C3%B5es">Outras operações</a></li>
<li><a href="#hooks">Hooks</a></li>
<li><a href="#environment">Environment</a>
<ul>
<li><a href="#envs-do-mallopt">Envs do mallopt</a></li>
<li><a href="#envs-do-glibc_tunables">Envs do glibc_tunables</a></li>
</ul>
</li>
<li><a href="#tcache">TCache</a>
<ul>
<li><a href="#struct">Struct</a></li>
<li><a href="#environment-1">Environment</a></li>
<li><a href="#mitiga%C3%A7%C3%B5es">Mitigações</a>
<ul>
<li><a href="#key-229--double-free">Key 2.29 / Double Free</a></li>
<li><a href="#230-count-check">2.30 count check</a></li>
</ul>
</li>
<li><a href="#opera%C3%A7%C3%B5es">Operações</a>
<ul>
<li><a href="#dump--transfer%C3%AAncia">Dump / Transferência</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#obs">Obs</a></li>
</ul>
<p>O Heap é composto por chunks, alocados por meio de <code>malloc()</code> e liberados por meio de <code>free()</code>.</p>
<p>Malloc recebe normalmente 1 parâmetro: tamanho! Porem esse valor a esse valor é 
adicionado <code>0x08</code> e arredondado para cima. Por exemplo:</p>
<ul>
<li>malloc(0x18) -&gt; 0x20 -&gt; 0x20</li>
<li>malloc(0x20) -&gt; 0x28 -&gt; 0x30</li>
<li>malloc(1)    -&gt; 0x20 TAMANHO MINIMO!</li>
</ul>
<p>Esse é o tamanho (<code>size</code>) do chunk!</p>
<h1 id="chunk"><a class="header" href="#chunk">Chunk</a></h1>
<p>O chunk, quando alocado consiste em:</p>
<pre><code>0000000000000000        size      -&gt; Lembrando que size inclui os metadados
0000000000000000 0000000000000000 &lt;- dados do usuário
0000000000000000 0000000000000000
</code></pre>
<p>A visão do usuário e a visão interna de um chunk sao diferentes:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- visão usuário
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- visão malloc
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB &lt;- visão usuário
CCCCCCCCCCCCCCCC 
</code></pre>
<p>Nos vamos usar a visão do malloc daqui em diante! Portanto:
<code>Chunk + 0x08 -&gt; size</code> e <code>Chunk + 0x10 -&gt; dados</code> </p>
<p>O tamanho do chunk, por ser alinhado a 16 bytes, nas usa os últimos 4 bits do size,
e assim eles sao usados pra flags:</p>
<ul>
<li>1 - PREV_INUSE
<ul>
<li><code>1</code> se o <code>chunk adjacente anterior</code> esta em uso (nao free)</li>
<li>Se o <code>chunk anterior</code> esta livre (<code>0</code>), o nosso chunk rouba a ultima qword (a 
logo antes do <code>size</code>) para armazenar o <code>size do chunk anterior</code>: <code>PREV_SIZE</code></li>
</ul>
</li>
<li>2 - IS_MMAPPED
<ul>
<li><code>1</code> se o chunk foi adquirido via <code>mmap</code> </li>
<li>Os outros bits sao ignorados pois: 
<ul>
<li>Nao possui chunks adjacente</li>
<li>Nao faz parte de uma arena</li>
</ul>
</li>
</ul>
</li>
<li>4 - NON_MAIN_ARENA
<ul>
<li><code>0</code> se esta na <code>main_arena</code></li>
<li><code>1</code> se esta em qualquer outra thread</li>
</ul>
</li>
<li>8 - Sem uso atualmente</li>
</ul>
<h1 id="top"><a class="header" href="#top">Top</a></h1>
<p>O chunk <code>top</code> fica na borda do heap:</p>
<pre><code class="language-x86asm">0000000000000000 0000000000000031 &lt;- chunk 1
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC EEEEEEEEEEEEEEEE 
FFFFFFFFFFFFFFFF 0000000000000020 &lt;- chunk 2
AAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBB
CCCCCCCCCCCCCCCC 0000000000003f41 &lt;- top
</code></pre>
<p>O top chunk tem um tamanho enorme, e quando nos alocamos um novo chunk, estamos 
tirando uma fatia dele.</p>
<p>Se ele ficar pequeno de mais, pode ser extendido por meio da syscall <code>sbrk</code> (system 
break)</p>
<p>O system break é um limite de quanta memoria nos podemos gastar, e é controlado pelo 
sistema operacional.</p>
<p>Alem disso, caso o chunk que passe do limite do <code>top</code> seja enorme (0x5000 por 
exemplo) ao envés de gastar o <code>top</code> todo e precisar chamar <code>srbk</code>, basta alocar o 
espaço desse chunk em outro canto usando <code>mmap</code>.</p>
<h1 id="arena"><a class="header" href="#arena">Arena</a></h1>
<p>Uma arena é um agregador de metadados referentes a aquele heap, com cada thread tendo
uma. A da main thread é chamada de <code>main_arena</code> !</p>
<p>Entre os metadados armazenados nos temos, por exemplo:</p>
<ul>
<li>Endereço do top chunk</li>
<li>Head das binlists</li>
<li>Pointer para outras arenas</li>
<li>Quanta memoria o sistema operacional disponibilizou</li>
</ul>
<p>A main_arena é uma variável global, enquanto as outras sao segmentos de heap!</p>
<p>O comportamento do <code>top</code> descrito anteriormente somente ocorre na main_arena</p>
<h1 id="binlists"><a class="header" href="#binlists">Binlists</a></h1>
<p>Quando um chunk nao é mais util, voce pode chamar <code>free()</code> passando o chunk como 
parâmetro!</p>
<p>Quando um chunk é liberado, ele é colocado em uma binlist e a sua estrutura muda!</p>
<p>Binlists sao linked lists (single ou double | circular ou nao circular) que 
armazenam os free chunks, com cada chunk sendo um node na list.</p>
<p>Sao as head dessas binlists que sao armazenadas na main arena!</p>
<p>Elas sao classificadas pelo tamanho do chunk que armazenam:</p>
<ul>
<li>Fastbins: 0x20, 0x30,....., 0x80</li>
<li>Unsorted bin: * </li>
<li>smallbins</li>
<li>largebins</li>
</ul>
<h3 id="fastbins"><a class="header" href="#fastbins">Fastbins</a></h3>
<p>Os fastbins sao usados para rapidamente alocar e liberar chunks.</p>
<p>Cada um deles contem uma singly-linked-list de chunks de mesmo tamanho. </p>
<p>O local aonde ficaria os <code>dados</code>, em um free chunk sera usado para metadados, e 
no caso dos fastbins, por ser uma singly-linked-list somente um pointer (<code>FD</code>) para 
o proximo chunk na lista.</p>
<p>Alem disso, essa lista é nao circular, isto é: o ultimo chunk tem FD=0 (NULL)</p>
<p>Como os fastbins nao sao consolidados com outros free chunks adjacentes, eles sempre
possuem <code>PREV_INUSE</code>=<code>1</code></p>
<p>Então por exemplo um chunk do fastbin 0x30 contem: </p>
<pre><code class="language-x86asm">0000000000000000     size=0x31
        FD       0000000000000000
0000000000000000 0000000000000000
0000000000000000
</code></pre>
<p>Alem disso, os fastbins sao <code>LIFO</code>, assim como uma stack:</p>
<pre><code class="language-C++">head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 4)
head: chunk 4 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 5)
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

free(chunk 10)
head: chunk 10 -&gt; chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)

malloc()
head: chunk 5 -&gt; chunk 1 -&gt; chunk 3 -&gt; 0 (NULL)
</code></pre>
<p>Então por exemplo:</p>
<pre><code class="language-C++">Código:
malloc() 6 vezes
free(Chunk 4)
free(Chunk 2)
free(Chunk 5)
free(Chunk 3)

Main Arena:
Fastbin 0x20 = &amp; Chunk 3   
Fastbin 0x20 : Chunk 3 -&gt; Chunk 5 -&gt; Chunk 2 -&gt; Chunk 4 -&gt; 0 (NULL)

Heap:
0000000000000000 0000000000000021 &lt;- Chunk 1
0000000000000000 0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 2 - Fastbin 0x20 [3]
    &amp; Chunk 4    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 3 - Fastbin 0x20 [4]
    &amp; Chunk 5    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 4 - Fastbin 0x20 [0]
   00000 (NULL)  0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 5 - Fastbin 0x20 [1]
    &amp; Chunk 2    0000000000000000
0000000000000000 0000000000000021 &lt;- Chunk 6
0000000000000000 0000000000000000
0000000000000000 0000000000003d11 &lt;- top
</code></pre>
<h3 id="unsorted-bin"><a class="header" href="#unsorted-bin">Unsorted bin</a></h3>
<p>O unsorted bin armazena chunks de tamanho diversos, que serão distribuídos 
(<strong>SORT</strong>) para uma <code>small</code>/<code>large</code> bin de tamanho apropriado</p>
<p>A Unsorted bin é uma doubly linked list (<code>FD</code> e <code>BK</code>) circular!</p>
<p>Na hora de procurar um chunk de tamanho adequado para um <code>malloc()</code>, começa-se 
a busca pela <code>tail</code> e somente retorna um chunk de tamanho idêntico 
(<code>exact fit</code>) ao pedido! </p>
<p>Conforme essa lista vai sendo atravessada, o processo de <strong>SORT</strong> vai ocorrer!</p>
<p>Quando o chunk de tamanho correto é encontrado, ele sofre um 
<a href="https://0xturazzi.github.io/book/heap/malloc/PartialUnlink.html">parcial unlink</a> !</p>
<h4 id="remaindering"><a class="header" href="#remaindering">Remaindering</a></h4>
<p>Caso a busca chegue no <code>ultimo chunk do unsorted bins</code> e ele seja maior do que 
o pedido, ele sera dividido em 2 em um processo chamado <code>remaindering</code>:</p>
<pre><code> _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|         |
|_________|

Divide o chunk em 2
 _________
|    |size|
| FD | BK |
|         |
|         |
|         |
|_________|
|         |
|         |
|         |
|         |
|_________|

Retorna o primeiro

Coloca o segundo no unsortedbin e 
      o define como last_remainder 
      (pointer na main_arena que 
      aponta para o ultimo chunk
      a ser dividido) 
 _________
|    |size| &lt;- Nosso chunk
|  dados  |
| AAAAAAA |
|         |
|         |
|_________|
|    |size| &lt;-- Unsorted Bins e last_remainder
| FD | BK |
|         |
|         |
|_________|

</code></pre>
<h3 id="small-bins"><a class="header" href="#small-bins">Small Bins</a></h3>
<p>Os small bins sao similares ao unsorted bin, sendo 
<code>double-linked -lists</code> (fd e bk) e circulares. Com essa lista 
sendo <code>FIFO</code>(<code>first-in first-out</code>), os chunks <code>entram/free</code> pela <br />
head e <code>saem/malloc</code> pela tail.</p>
<p>Cada small bins armazena somente um tamanho especifico de chunk, 
de <code>0x20</code> a <code>0x3f0</code>. Como voce pode perceber, existe uma 
intercessão entre os tamanhos de fast e small. Nos podemos 
migrar um fast chunk para o unsorted bins (e consequentemente para 
o respectivo small bins usando malloc consolidate())</p>
<h3 id="large-bins"><a class="header" href="#large-bins">Large Bins</a></h3>
<p>Os Large Bins sao:</p>
<ul>
<li>size &gt;= 0x400</li>
<li>Double linked lists (fd e bk)</li>
<li>Listas Circulares
Existem 64, com apenas 63 sendo usados 
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x440: 0x440, 0x450, 0x460 e 0x470</li>
<li>...</li>
</ul>
</li>
</ul>
<p>Quanto maior o size, mais tamanhos de chunks ele armazena, em uma escala 
logarítmica</p>
<ul>
<li>Large 0x400: 0x400, 0x410, 0x420 e 0x430</li>
<li>Large 0x5000: 0x5000, 0x5010, ... , 0x5ff0</li>
<li>Large 0x80000: size &gt;= 0x80000 (teoricamente infinito)</li>
</ul>
<p>Os chunks ficam em ordem decrescente de tamanho em relação a head:</p>
<p><code>head:&gt; 0x430 --- 0x420 --- 0x410 --- 0x400 &lt;:tail</code> </p>
<p>Para manter essa ordem de tamanho, sao usadas skiplists, explicadas depois.</p>
<p>Os primeiros chunks de cada size, alem de <code>fd</code> e <code>bk</code>, possuem <code>fd_nextsize</code> 
e<code>fd_nextsize</code>. Esses chunks que contem metadados adicionais sao chamados de 
skipchunks</p>
<pre><code class="language-py">head:  0x430  0x430     0x420   0x420   0x410     0x400   0x400 :tail
 ...&gt;|      |&gt;|     |&gt;|      |&gt;|     |&gt;|      |&gt;|      |&gt;|     |&gt;... fd
 ...&lt;| skip |&lt;|     |&lt;| skip |&lt;|     |&lt;| skip |&lt;| skip |&lt;|     |&lt;... bk
        ^ |              ^ |              ^ |      ^ |
.....___| |______________| |______________| |______| |___________.....
            fd_nextsize      fd_nextsize               fd_nextsize

E mesma coisa com o bk_nextsize.

Com o fd_nextsize apontando para um tamanho MENOR
Com o bk_nextsize apontando para um tamanho MAIOR
</code></pre>
<p>Assim, os <code>fd_nextsize</code> e <code>fd_nextsize</code> formam uma 
<code>doubly linked circular list</code>, contendo a primeira instancia de cada tamanho de 
chunk presente naquele largebin. Essa &quot;meta-lista&quot; é a skiplist :D</p>
<p>Quando um chunk de tamanho novo é <code>free()</code>, ele é colocado na skiplist do 
respectivo largebin. Em seguida, todos os chunks com aquele tamanho, serão 
colocados logo apos o primeiro, sem interferir com a skiplist.</p>
<p>Mesma coisa com alocações, com o chunk retirado sendo o mais recente a entrar 
naquela skiplist (<code>LIFO</code>). Portanto o skipchunk sera o ultimo a ser 
alocado entre os chunks daquele tamanho. Assim, nao interferindo com a 
skiplist. </p>
<p>Assim, garantindo a ordem de tamanhos dentro de um largebin :D </p>
<blockquote>
<p>Obs: Quando um chunk <strong>NAO</strong> skipchunk é sort para um large bin, os seus 
bk_nextsize e fd_nextsize SAO <strong>NULLIFICADOS</strong></p>
</blockquote>
<blockquote>
<p>Obs 2: o unlink nos largebins ocorre pelo fd, para evitar 
alocar o skipchunk. E alem disso eles sempre sofrem um unlink <strong>COMPLETO</strong>,
pois o chunk pode vir do meio da lista! (safe unlink)</p>
</blockquote>
<h1 id="outras-operações"><a class="header" href="#outras-operações">Outras operações</a></h1>
<ul>
<li><code>calloc( size )</code>: igual <code>malloc()</code> porem inicializa a região para NULL
<ul>
<li>Ineficiente porem mais seguro</li>
</ul>
</li>
<li><code>mallopt()</code>: altera algumas envs durante o runtime
<ul>
<li>lista delas em: man mallopt</li>
<li>checar configuracao atual no gdb: mp</li>
</ul>
</li>
<li><code>realloc( chunk , size )</code>: muda o tamanho de um chunk
<ul>
<li>Chama <code>free()</code> no chunk, <code>malloc()</code> um novo chunk de tamanho <code>size</code> e transfere os dados do chunk antigo para o novo</li>
<li>Se <code>size == 0</code>, simplesmente atua como um <code>free()</code>: muitos devs nao sabem disso
<ul>
<li>Sanitizam os <code>free()</code>s corretamente, mas esquecem de sanitizar os <code>realloc()</code>s</li>
</ul>
</li>
</ul>
</li>
<li>Consolidar para frente (por exemplo, no free)
<ul>
<li>Algorítimo
<ul>
<li>Começa no endereço do chunk_A </li>
<li>Anda chunk_A.<code>size</code> para encontrar o chunk_B</li>
<li>Anda chunk_B.<code>size</code> para encontrar o chunk_C (sem checar se size é valido)</li>
<li>Checa <code>prev_in_use</code> do chunk_C para saber se o chunk_B é free</li>
<li>Se for free, consolida chunk_A e chunk_B</li>
</ul>
</li>
<li>Evitar
<ul>
<li>Forjar fenceposts apos o chunk_A
<ul>
<li>edit(chunk_A, flat(0, 0, 0, 0x10, 0, 0x10 )) </li>
</ul>
</li>
<li>Alterar chunk_A.size = 0x1
<ul>
<li>Ele vai andar 0 e se auto-checar </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>malloc_consolidate()</code> pega todos os fast chunks de uma arena e os coloca no unsorted bin
<ul>
<li>Assim, consolidando todos os chunks, e diminuindo a fragmentação do heap </li>
<li>Como ele vai contra a logica dos fastbins, somente ocorre em situações extremas</li>
<li>chamado de 2 lugares no malloc, e em 1 no free
<ul>
<li>malloc 
<ul>
<li>malloc &gt;= 0x400 : Apos o consolidate, esse chunk vai ser alocado a partir dos unsorted bins
<ul>
<li>Isso pode ser um problema se voce tiver um chunk falso que nao passe: (fencepost &lt; chunk &lt;= system_mem). Voce tem 2 opções</li>
<li>1 : Criar e liberar um chunk falso logo no inicio do exploit, fazendo com que o malloc aloque ele antes de chegar no chunk_fake</li>
<li>2 : alterar o  size do malloc(0x400) para um valor acima do fast_consolidate_threshold, evitando que o unsorted bin se quer seja pesquisado
<ul>
<li>Cada distro tem um</li>
<li>Padrão: 0x10000 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>free 
<ul>
<li>Se consolidar um chunk normal com um chunk &gt;= fast_consolidate_threshold</li>
<li>O top_chunk obviamente é maior</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="hooks"><a class="header" href="#hooks">Hooks</a></h1>
<ul>
<li>__after_morecore_hook</li>
<li>__morecore
<ul>
<li>os morecore sao ativados quando o top chunk é consumido</li>
<li>difícil de passar argumentos</li>
</ul>
</li>
<li>__free_hook
<ul>
<li>Nao alinhado 16 bytes (addr termina em 8) (nem sempre, depende
do compilador)</li>
</ul>
</li>
<li>__malloc_hook</li>
<li>__malloc_initialize_hook
<ul>
<li>raro de usar, chamado no inicio da execução </li>
</ul>
</li>
<li>__memalign_hook
<ul>
<li>usado quando vc da malloc pedindo um alinhamento especifico </li>
</ul>
</li>
<li>__realloc_hook
<ul>
<li>Nao alinhado 16 bytes (addr termina em 8) (nem sempre, depende 
do compilador)</li>
</ul>
</li>
</ul>
<blockquote>
<p>Dica: Colocar breakpoint em hooks usando hardware breaks
gdb&gt; rwatch __malloc_hook 
Quando o programa tentar dar read nele (pra usa-lo), vai pausar</p>
</blockquote>
<h1 id="environment"><a class="header" href="#environment">Environment</a></h1>
<h2 id="envs-do-mallopt"><a class="header" href="#envs-do-mallopt">Envs do mallopt</a></h2>
<h2 id="envs-do-glibc_tunables"><a class="header" href="#envs-do-glibc_tunables">Envs do glibc_tunables</a></h2>
<p>Algumas controlam o malloc. Vem para o libc em uma unica env: 
<code>glibc_tunables</code></p>
<p>Durante a inicializacao, sao armazenadas logo antes do inicio do 
heap, mesmo se nao forem validas. Assim, voce pode influenciar o 
endereco do inicio do heap</p>
<p>Ignoradas em programas SUID (diff entre uid efetivo e uid user/
group). Alem disso, se  o item tiver o <code>security_level</code> de erase, 
ele nao pode passar para uma child</p>
<p>Para ver as ativas no gdb: <code>p tunable_list[x]</code> </p>
<p>Algumas coisas podem ser setadas aqui tambem, Ex: mmap_threshold</p>
<p>E algumas sao exclusivas:</p>
<ul>
<li>21: tcache_count
<ul>
<li>0 desativa o tcache </li>
</ul>
</li>
</ul>
<h1 id="tcache"><a class="header" href="#tcache">TCache</a></h1>
<p>O TCache (Thread Cache), vem ativado por padrão a partir de 2.25. 
E ele acaba enfraquecendo muitas mitigações, facilitando nossa vida.
Ele também pode ser chamado de Magazine (nome da primeira 
implementação no JEmalloc do Solari)</p>
<p>Cada Thread em um processo recebe uma arena (e heap), porem o 
numero de arenas é limitado pelo numero de cores do processo</p>
<p>Assim, as vezes múltiplas thread dividem a mesma arena, e para 
prevenir races malloc usa locks. Porem, isso deixa ele 
drasticamente mais lento. Portanto foi criado o TCache! </p>
<p>Cada Thread contem o seu, e ele é uma mini-arena (implementado por 
meio de um chunk no heap, com a primeira thread sendo no inicio do 
heap, e as outras, em qualquer posição. Esse chunk se comporta como 
qualquer outro, podendo  por exemplo, ser consolidado)... </p>
<p>Assim, quando uma thread da free, esse chunk pode ir para o seu 
TCache, e em um malloc seguinte ser fornecido por ele, sem precisar 
esperar outra thread terminar suas alocações. Por ser mais rápido, 
ele toma precedente em relação a arena real (Por exemplo um free 
0x20 vai para o <code>Tcachebin 0x20</code> e nao para o <code>fastbin 0x20</code>, o 
mesmo vale para alocações).</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>O Tcache possui duas partes: Counts (contagens) e Entries (entradas)
, 64 de cada </p>
<p>Cada Entry age como uma fastbin, sendo a head de uma lista nao 
circular LIFO (ultimo free = head), de tamanho especifico (0x20 - 
0x410 (maior do que isso vai para os unsortedbins como normalmente acontece)). </p>
<p>A única diferença é que a entry aponta para a <code>data</code> e nao 
para o inicio real do chunk (isso continua pelo resto da lista, com 
o fd apontando para o data)</p>
<p>Ja cada Count mantem uma contagem de quantos elementos estão em cada bin </p>
<blockquote>
<p>OBS: O tamanho do count muda: 1 byte (2.26 a 2.29), 2 bytes (&gt;= 2.30)... Assim, o TCache como um todo pode ter size 0x250 ou 0x290</p>
</blockquote>
<p>Assim, quando vc da free em um chunk 0x20, por exemplo, ao envés de 
ir pro fastbin 0x20, ele vai para o <code>tcachebins [0x20]</code> e a 
primeira qword do tcache sera +=1</p>
<h2 id="environment-1"><a class="header" href="#environment-1">Environment</a></h2>
<ul>
<li>tcache_count
<ul>
<li>encontra usando gdb&gt; mp</li>
<li>Padrão: 7</li>
<li>Cada tcachebin somente pode ter X chunks, caso voce de free e aquele bin 
ja esteja cheio, vai para o comportamento de free normal (0x20 pra fast 0x20 por exemplo)</li>
</ul>
</li>
</ul>
<h2 id="mitigações"><a class="header" href="#mitigações">Mitigações</a></h2>
<h3 id="key-229--double-free"><a class="header" href="#key-229--double-free">Key 2.29 / Double Free</a></h3>
<p>A partir da versão 2.29, quando um chunk vai pro tcachebin, 
o endereço do seu <code>bk</code> é reutilizado como <code>key</code> (aponta para o 
tcache)</p>
<p>Assim, se o chunk tem key, quer dizer que ele esta free... eles 
serão NULL quando alocados</p>
<p>Como se fosse um prev_in_use. mas para o chunk atual</p>
<p>Sempre que um chunk é free (mesmo se nao estiver no tcache), a key 
é checada... se ela aponta para o tcache, corre o risco de ser um 
double free (mas nao da pra ter 100% de certeza pq pode ser so 
bytes aleatórios que coincidiram)</p>
<p>Então para poder checar de novo para ter certeza. ele itera sobre 
<strong>TODOS</strong> os chunks daquele tcache bin vendo se alguém aponta para 
ele. Se encontrar algum, o programa crasha.</p>
<p>Para passar a mitigação:</p>
<ul>
<li>Corromper a Key</li>
<li>Esse check nao ocorre se voce estiver transferindo um chunk</li>
</ul>
<h3 id="230-count-check"><a class="header" href="#230-count-check">2.30 count check</a></h3>
<p>O Tcache nao aloca de um bin com count=0</p>
<h2 id="operações"><a class="header" href="#operações">Operações</a></h2>
<h3 id="dump--transferência"><a class="header" href="#dump--transferência">Dump / Transferência</a></h3>
<p>O <code>tcache 0x20</code> ta vazio</p>
<p>O <code>fast 0x20</code> tem chunks</p>
<p>Se vc alocar um chunk 0x20, ele vai vai vir pra vc, e alguns dos chunks 
do <code>fast 0x20</code> vao ser transferidos para encher o <code>tcache 0x20</code></p>
<blockquote>
<p>Ele faz isso iterando atraves do chunks ate que encontre um fd=0 ou chegue ao limite do tcache_count</p>
</blockquote>
<p>O Mesmo se aplica aos smallbins</p>
<p>Para os unsortedbins, ao envés de alocar um, e transferir o resto, ele vai:</p>
<ul>
<li>Vai andando pelos unsorted bins</li>
<li>SORT os chunks</li>
<li>Se ele tem o tamanho exato que vc pediu, manda pro tcache</li>
<li>Continua</li>
<li>Ao final, pega o ultimo chunk que foi mandado pra tcache e aloca ele</li>
</ul>
<p>Então a ordem é ao contrario: primeira transfere, depois aloca o ultimo a ser transferido</p>
<h1 id="obs"><a class="header" href="#obs">Obs</a></h1>
<ul>
<li>Calloc nao aloca do tcache</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../heap/malloc/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../heap/malloc/fastbinsDup.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../heap/malloc/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../heap/malloc/fastbinsDup.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
